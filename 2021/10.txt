01.
name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]


/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

            // 急刹车场景
        //     _trigger_times["check_ebrake"] = haomo::hios::time::timestamp();
        //     ret |= _co->regist_condition("check_ebrake",
        //                                  std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        //    [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        //    {
        //        ConditionDefine::Value r;
        //        r.is_valid = true;
        //        r.val_bool = false;
        //        auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
        //        for (auto &data : fetch_data)
        //        {
        //            haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
        //            if (!p_mobile_eye_data) {
        //                continue;
        //            }
        //            // 触发间隔要大于1s
        //            if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
        //                continue;
        //            }
        //            if ( p_mobile_eye_data->has_lanes_host())
        //            {
        //                auto lanes_host = p_mobile_eye_data ->lanes_host();
        //                for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_host.lane_marker(i);
        //                     if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //            if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
        //            {
        //                auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
        //                for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_adjacement.lane_marker(i);
        //                     if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //        }
        //        return r;
        //    }));





            // 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               MLOG(dtcl, ERROR) << "successful trigger";
               for (auto &data : fetch_data)
               {
                   MLOG(dtcl, ERROR) << "successful trigger";
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_fishbone_line"] < 1000000 ) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            MLOG(dtcl, ERROR) << "successful trigger";
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       MLOG(dtcl, ERROR) << "successful trigger";
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           MLOG(dtcl, ERROR) << "successful trigger";
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            // 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            // 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_mobile_eye_data->header().stamp()
                   // 触发间隔要大于1s
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_msg_bus->header().stamp()
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            // 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           // 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            // 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo

03.
/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

            // 急刹车场景
        //     _trigger_times["check_ebrake"] = haomo::hios::time::timestamp();
        //     ret |= _co->regist_condition("check_ebrake",
        //                                  std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        //    [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        //    {
        //        ConditionDefine::Value r;
        //        r.is_valid = true;
        //        r.val_bool = false;
        //        auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
        //        for (auto &data : fetch_data)
        //        {
        //            haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
        //            if (!p_mobile_eye_data) {
        //                continue;
        //            }
        //            // 触发间隔要大于1s
        //            if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
        //                continue;
        //            }
        //            if ( p_mobile_eye_data->has_lanes_host())
        //            {
        //                auto lanes_host = p_mobile_eye_data ->lanes_host();
        //                for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_host.lane_marker(i);
        //                     if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //            if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
        //            {
        //                auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
        //                for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_adjacement.lane_marker(i);
        //                     if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //        }
        //        return r;
        //    }));

            //8.  事故定则，急刹触发场景
            _trigger_times["check_emergency_brake"] = haomo::hios::time::timestamp();
            _trigger_times["emergency_brake_start"] = 0;
            _trigger_times["emergency_brake_end"] = 0;
            ret |= _co->regist_condition("check_emergency_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_emergency_brake"]) {
                       continue;
                   }
                   _trigger_times["check_emergency_brake"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() < -0.3) {
                       if (0 ==  _trigger_times["emergency_brake_start"]) {
                           _trigger_times["emergency_brake_start"] = _trigger_times["check_emergency_brake"];
                       } else {
                           _trigger_times["emergency_brake_end"] = _trigger_times["check_emergency_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["emergency_brake_start"] && _trigger_times["emergency_brake_end"] - _trigger_times["emergency_brake_start"] > 10000000) {
                            _trigger_times["emergency_brake_start"] = 0;
                            _trigger_times["emergency_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["emergency_brake_start"] = 0;
                       _trigger_times["emergency_brake_end"]   = 0;
                   }
               }
               return r;
           }));

            //13.  事故定则，点刹触发场景
            _trigger_times["check_point_brake"] = haomo::hios::time::timestamp();
            _trigger_times["point_brake_start"] = 0;
            _trigger_times["point_brake_end"] = 0;
            ret |= _co->regist_condition("check_point_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_point_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_point_brake"]) {
                       continue;
                   }
                   _trigger_times["check_point_brake"] = p_vehicle_data->header().stamp();
                   if ( p_vehicle_data->axrefms2() > -0.1 && p_vehicle_data->axrefms2() < 0.0) {
                       if (0 ==  _trigger_times["point_brake_start"]) {
                           _trigger_times["point_brake_start"] = _trigger_times["check_point_brake"];
                       } else {
                           _trigger_times["point_brake_end"] = _trigger_times["check_point_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["point_brake_start"] && _trigger_times["point_brake_end"] - _trigger_times["point_brake_start"] < 10000000) {
                            _trigger_times["point_brake_start"] = 0;
                            _trigger_times["point_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["point_brake_start"] = 0;
                       _trigger_times["point_brake_end"]   = 0;
                   }
               }
               return r;
           }));


            //14.  事故定则，急加速触发场景   URGENT_ACCELERATE
            _trigger_times["check_urgent_accelerate"] = haomo::hios::time::timestamp();
            _trigger_times["urgent_accelerate_start"] = 0;
            _trigger_times["urgent_accelerate_end"] = 0;
            ret |= _co->regist_condition("check_urgent_accelerate",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_urgent_accelerate"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() > 0.3) {
                       if (0 ==  _trigger_times["urgent_accelerate_start"]) {
                           _trigger_times["urgent_accelerate_start"] = _trigger_times["check_urgent_accelerate"];
                       } else {
                           _trigger_times["urgent_accelerate_end"] = _trigger_times["check_urgent_accelerate"]; 
                       }
                   } else {
                       if (0 != _trigger_times["urgent_accelerate_start"] && _trigger_times["urgent_accelerate_end"] - _trigger_times["urgent_accelerate_start"] > 10000000) {
                            _trigger_times["urgent_accelerate_start"] = 0;
                            _trigger_times["urgent_accelerate_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["urgent_accelerate_start"] = 0;
                       _trigger_times["urgent_accelerate_end"]   = 0;
                   }
               }
               return r;
           }));

            //10  事故定则，上下匝道触发场景
            _trigger_times["check_ramp"] = haomo::hios::time::timestamp();
            _last_nav_road_type = 0;
            ret |= _co->regist_condition("check_ramp",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_hut_msg_bus->header().stamp() <= _trigger_times["check_ramp"]) {
                       continue;
                   }
                   _trigger_times["check_ramp"] = p_vcan_hut_msg_bus->header().stamp();
                   if (7 == p_vcan_hut_msg_bus->nav_road_type()) {
                       if (_last_nav_road_type != 7 ) {
                           _last_nav_road_type = 7;
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = 7;
                   } else {
                        if (_last_nav_road_type == 7 ) {
                           _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                   }
               }
               return r;
           }));


            // 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               MLOG(dtcl, ERROR) << "successful trigger";
               for (auto &data : fetch_data)
               {
                   MLOG(dtcl, ERROR) << "successful trigger";
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_fishbone_line"] < 1000000 ) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            MLOG(dtcl, ERROR) << "successful trigger";
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       MLOG(dtcl, ERROR) << "successful trigger";
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           MLOG(dtcl, ERROR) << "successful trigger";
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            // 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            // 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_mobile_eye_data->header().stamp();
                   // 触发间隔要大于1s
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_msg_bus->header().stamp();
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            // 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           // 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            // 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo


name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 8. 事故定则，急刹触发 P00
    {
        trigger_type: TRI_EBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_emergency_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 13. 事故定则，点刹触发 P00
    {
        trigger_type: TRI_PBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_point_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 14. 事故定则，急加速触发 P00
    {
        trigger_type: TRI_URGENT_ACCELERATE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_urgent_accelerate"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]


name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 8. 事故定则，急刹触发 P00
    {
        trigger_type: TRI_EBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_emergency_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 10. 事故定则，上下匝道触发的数据 P0
    {
        trigger_type: TRI_RAMP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_ramp"
                    op: "eq"
                    value: "true"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 13. 事故定则，点刹触发 P00
    {
        trigger_type: TRI_PBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_point_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 14. 事故定则，急加速触发 P00
    {
        trigger_type: TRI_URGENT_ACCELERATE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_urgent_accelerate"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "true"
                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "LaneChngCfmSwt"
#                        op: "eq"
#                        value: "4"
#                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "true"
                }
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "VoiceBrdcSwt"
#                        op: "eq"
#                        value: "4"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "UsrManSts"
#                        op: "eq"
#                        value: "2"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "AutoSpdSetSwt"
#                        op: "eq"
#                        value: "4"
#                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]

/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

            // 急刹车场景
        //     _trigger_times["check_ebrake"] = haomo::hios::time::timestamp();
        //     ret |= _co->regist_condition("check_ebrake",
        //                                  std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        //    [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        //    {
        //        ConditionDefine::Value r;
        //        r.is_valid = true;
        //        r.val_bool = false;
        //        auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
        //        for (auto &data : fetch_data)
        //        {
        //            haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
        //            if (!p_mobile_eye_data) {
        //                continue;
        //            }
        //            // 触发间隔要大于1s
        //            if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
        //                continue;
        //            }
        //            if ( p_mobile_eye_data->has_lanes_host())
        //            {
        //                auto lanes_host = p_mobile_eye_data ->lanes_host();
        //                for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_host.lane_marker(i);
        //                     if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //            if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
        //            {
        //                auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
        //                for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_adjacement.lane_marker(i);
        //                     if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //        }
        //        return r;
        //    }));

            //8.  事故定则，急刹触发场景
            _trigger_times["check_emergency_brake"] = haomo::hios::time::timestamp();
            _trigger_times["emergency_brake_start"] = 0;
            _trigger_times["emergency_brake_end"] = 0;
            ret |= _co->regist_condition("check_emergency_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_emergency_brake"]) {
                       continue;
                   }
                   _trigger_times["check_emergency_brake"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() < -0.3) {
                       if (0 ==  _trigger_times["emergency_brake_start"]) {
                           _trigger_times["emergency_brake_start"] = _trigger_times["check_emergency_brake"];
                       } else {
                           _trigger_times["emergency_brake_end"] = _trigger_times["check_emergency_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["emergency_brake_start"] && _trigger_times["emergency_brake_end"] - _trigger_times["emergency_brake_start"] > 10000000) {
                            _trigger_times["emergency_brake_start"] = 0;
                            _trigger_times["emergency_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["emergency_brake_start"] = 0;
                       _trigger_times["emergency_brake_end"]   = 0;
                   }
               }
               return r;
           }));



            //10  事故定则，上下匝道触发场景
            _trigger_times["check_ramp"] = haomo::hios::time::timestamp();
            _last_nav_road_type = 0;
            ret |= _co->regist_condition("check_ramp",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_hut_msg_bus->header().stamp() <= _trigger_times["check_ramp"]) {
                       continue;
                   }
                   _trigger_times["check_ramp"] = p_vcan_hut_msg_bus->header().stamp();
                   if (7 == p_vcan_hut_msg_bus->nav_road_type()) {
                       if (_last_nav_road_type != 7 ) {
                           _last_nav_road_type = 7;
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = 7;
                   } else {
                        if (_last_nav_road_type == 7 ) {
                           _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                   }
               }
               return r;
           }));

            //13.  事故定则，点刹触发场景
            _trigger_times["check_point_brake"] = haomo::hios::time::timestamp();
            _trigger_times["point_brake_start"] = 0;
            _trigger_times["point_brake_end"] = 0;
            ret |= _co->regist_condition("check_point_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_point_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_point_brake"]) {
                       continue;
                   }
                   _trigger_times["check_point_brake"] = p_vehicle_data->header().stamp();
                   if ( p_vehicle_data->axrefms2() > -0.1 && p_vehicle_data->axrefms2() < 0.0) {
                       if (0 ==  _trigger_times["point_brake_start"]) {
                           _trigger_times["point_brake_start"] = _trigger_times["check_point_brake"];
                       } else {
                           _trigger_times["point_brake_end"] = _trigger_times["check_point_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["point_brake_start"] && _trigger_times["point_brake_end"] > _trigger_times["point_brake_start"] &&  _trigger_times["point_brake_end"] - _trigger_times["point_brake_start"] < 10000000) {
                            _trigger_times["point_brake_start"] = 0;
                            _trigger_times["point_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["point_brake_start"] = 0;
                       _trigger_times["point_brake_end"]   = 0;
                   }
               }
               return r;
           }));


            //14.  事故定则，急加速触发场景   URGENT_ACCELERATE
            _trigger_times["check_urgent_accelerate"] = haomo::hios::time::timestamp();
            _trigger_times["urgent_accelerate_start"] = 0;
            _trigger_times["urgent_accelerate_end"] = 0;
            ret |= _co->regist_condition("check_urgent_accelerate",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_urgent_accelerate"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() > 0.3) {
                       if (0 ==  _trigger_times["urgent_accelerate_start"]) {
                           _trigger_times["urgent_accelerate_start"] = _trigger_times["check_urgent_accelerate"];
                       } else {
                           _trigger_times["urgent_accelerate_end"] = _trigger_times["check_urgent_accelerate"]; 
                       }
                   } else {
                       if (0 != _trigger_times["urgent_accelerate_start"] && _trigger_times["urgent_accelerate_end"] - _trigger_times["urgent_accelerate_start"] > 10000000) {
                            _trigger_times["urgent_accelerate_start"] = 0;
                            _trigger_times["urgent_accelerate_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["urgent_accelerate_start"] = 0;
                       _trigger_times["urgent_accelerate_end"]   = 0;
                   }
               }
               return r;
           }));

            //26.AI场景积累 相机出现上下颠簸
            _trigger_times["check_camera_bumpy"] = haomo::hios::time::timestamp();
            _trigger_times["camera_bumpy_start"] = 0;
            _trigger_times["camera_bumpy_end"] = 0;
            ret |= _co->regist_condition("check_camera_bumpy",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_camera_bumpy"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_camera_bumpy"]) {
                       continue;
                   }
                   _trigger_times["check_camera_bumpy"] = p_vcan_dms_msg_bus->header().stamp();
                   if (19 == p_vcan_dms_msg_bus->head_pitch_ang() || 20 == p_vcan_dms_msg_bus->head_pitch_ang() || 18 == p_vcan_dms_msg_bus->head_pitch_ang()) {
                       if (0 ==  _trigger_times["camera_bumpy_start"]) {
                           _trigger_times["camera_bumpy_start"] = _trigger_times["check_camera_bumpy"];
                       } else {
                           _trigger_times["camera_bumpy_end"] = _trigger_times["check_camera_bumpy"]; 
                       }
                   } else {
                       if (0 != _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] > _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] - _trigger_times["camera_bumpy_start"] < 10000000) {
                            _trigger_times["camera_bumpy_start"] = 0;
                            _trigger_times["camera_bumpy_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["camera_bumpy_start"] = 0;
                       _trigger_times["camera_bumpy_end"]   = 0;
                   }
               }
               return r;
           }));

            //27.AI场景积累 相机出现上下颠簸
            _trigger_times["check_road_undulation"] = haomo::hios::time::timestamp();
            _trigger_times["road_undulation_start"] = 0;
            _trigger_times["road_undulation_end"] = 0;
            ret |= _co->regist_condition("check_road_undulation",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_road_undulation"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_road_undulation"]) {
                       continue;
                   }
                   _trigger_times["check_road_undulation"] = p_vcan_dms_msg_bus->header().stamp();
                   if (19 == p_vcan_dms_msg_bus->head_pitch_ang() || 20 == p_vcan_dms_msg_bus->head_pitch_ang() || 18 == p_vcan_dms_msg_bus->head_pitch_ang()) {
                       if (0 ==  _trigger_times["road_undulation_start"]) {
                           _trigger_times["road_undulation_start"] = _trigger_times["check_road_undulation"];
                       } else {
                           _trigger_times["road_undulation_end"] = _trigger_times["check_road_undulation"]; 
                       }
                   } else {
                       if (0 != _trigger_times["road_undulation_start"] && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] > 2000000 && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] < 10000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["road_undulation_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["road_undulation_start"] = 0;
                       _trigger_times["road_undulation_end"]   = 0;
                   }
               }
               return r;
           }));

            //28.AI场景积累 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               MLOG(dtcl, ERROR) << "successful trigger";
               for (auto &data : fetch_data)
               {
                   MLOG(dtcl, ERROR) << "successful trigger";
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_fishbone_line"] < 1000000 ) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            MLOG(dtcl, ERROR) << "successful trigger";
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       MLOG(dtcl, ERROR) << "successful trigger";
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           MLOG(dtcl, ERROR) << "successful trigger";
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            //29.AI场景积累 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            //30.AI场景积累 特殊道路场景（上下坡、各型路口）
            _trigger_times["check_special_road"] = haomo::hios::time::timestamp();
            _trigger_times["special_road_start"] = 0;
            _trigger_times["special_road_end"] = 0;
            ret |= _co->regist_condition("check_special_road",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_special_road"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_special_road"]) {
                       continue;
                   }
                   _trigger_times["check_special_road"] = p_vcan_dms_msg_bus->header().stamp();
                   if (14 < p_vcan_dms_msg_bus->head_pitch_ang() && p_vcan_dms_msg_bus->head_pitch_ang() < 24) {
                       if (0 ==  _trigger_times["special_road_start"]) {
                           _trigger_times["special_road_start"] = _trigger_times["check_special_road"];
                       } else {
                           _trigger_times["special_road_end"] = _trigger_times["check_special_road"]; 
                       }
                   } else {
                       if (0 != _trigger_times["special_road_start"] && _trigger_times["special_road_end"] - _trigger_times["special_road_start"] > 5000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["special_road_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["special_road_start"] = 0;
                       _trigger_times["special_road_end"]   = 0;
                   }
               }
               return r;
           }));

            //31.AI场景积累 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_mobile_eye_data->header().stamp();
                   // 触发间隔要大于1s
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_msg_bus->header().stamp();
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            //32.AI场景积累 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           //36.AI场景积累 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //37.AI场景积累 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //39.AI场景积累 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            //40.AI场景积累 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo






name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 8. 事故定则，急刹触发 P00
    {
        trigger_type: TRI_EBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_emergency_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 10. 事故定则，上下匝道触发的数据 P0
    {
        trigger_type: TRI_RAMP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_ramp"
                    op: "eq"
                    value: "true"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 13. 事故定则，点刹触发 P00
    {
        trigger_type: TRI_PBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_point_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 14. 事故定则，急加速触发 P00
    {
        trigger_type: TRI_URGENT_ACCELERATE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_urgent_accelerate"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "true"
                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "LaneChngCfmSwt"
#                        op: "eq"
#                        value: "4"
#                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "true"
                }
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "VoiceBrdcSwt"
#                        op: "eq"
#                        value: "4"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "UsrManSts"
#                        op: "eq"
#                        value: "2"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "AutoSpdSetSwt"
#                        op: "eq"
#                        value: "4"
#                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]

04.
/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

            // 急刹车场景
        //     _trigger_times["check_ebrake"] = haomo::hios::time::timestamp();
        //     ret |= _co->regist_condition("check_ebrake",
        //                                  std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        //    [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        //    {
        //        ConditionDefine::Value r;
        //        r.is_valid = true;
        //        r.val_bool = false;
        //        auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
        //        for (auto &data : fetch_data)
        //        {
        //            haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
        //            if (!p_mobile_eye_data) {
        //                continue;
        //            }
        //            // 触发间隔要大于1s
        //            if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
        //                continue;
        //            }
        //            if ( p_mobile_eye_data->has_lanes_host())
        //            {
        //                auto lanes_host = p_mobile_eye_data ->lanes_host();
        //                for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_host.lane_marker(i);
        //                     if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //            if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
        //            {
        //                auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
        //                for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_adjacement.lane_marker(i);
        //                     if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //        }
        //        return r;
        //    }));

            //8.  事故定则，急刹触发场景
            _trigger_times["check_emergency_brake"] = haomo::hios::time::timestamp();
            _trigger_times["emergency_brake_start"] = 0;
            _trigger_times["emergency_brake_end"] = 0;
            ret |= _co->regist_condition("check_emergency_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_emergency_brake"]) {
                       continue;
                   }
                   _trigger_times["check_emergency_brake"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() < -0.3) {
                       if (0 ==  _trigger_times["emergency_brake_start"]) {
                           _trigger_times["emergency_brake_start"] = _trigger_times["check_emergency_brake"];
                       } else {
                           _trigger_times["emergency_brake_end"] = _trigger_times["check_emergency_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["emergency_brake_start"] && _trigger_times["emergency_brake_end"] - _trigger_times["emergency_brake_start"] > 10000000) {
                            _trigger_times["emergency_brake_start"] = 0;
                            _trigger_times["emergency_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["emergency_brake_start"] = 0;
                       _trigger_times["emergency_brake_end"]   = 0;
                   }
               }
               return r;
           }));



            //10  事故定则，上下匝道触发场景
            _trigger_times["check_ramp"] = haomo::hios::time::timestamp();
            _last_nav_road_type = 0;
            ret |= _co->regist_condition("check_ramp",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_hut_msg_bus->header().stamp() <= _trigger_times["check_ramp"]) {
                       continue;
                   }
                   _trigger_times["check_ramp"] = p_vcan_hut_msg_bus->header().stamp();
                   if (7 == p_vcan_hut_msg_bus->nav_road_type()) {
                       if (_last_nav_road_type != 7 ) {
                           _last_nav_road_type = 7;
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = 7;
                   } else {
                        if (_last_nav_road_type == 7 ) {
                           _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                   }
               }
               return r;
           }));

            //13.  事故定则，点刹触发场景
            _trigger_times["check_point_brake"] = haomo::hios::time::timestamp();
            _trigger_times["point_brake_start"] = 0;
            _trigger_times["point_brake_end"] = 0;
            ret |= _co->regist_condition("check_point_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_point_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_point_brake"]) {
                       continue;
                   }
                   _trigger_times["check_point_brake"] = p_vehicle_data->header().stamp();
                   if ( p_vehicle_data->axrefms2() > -0.1 && p_vehicle_data->axrefms2() < 0.0) {
                       if (0 ==  _trigger_times["point_brake_start"]) {
                           _trigger_times["point_brake_start"] = _trigger_times["check_point_brake"];
                       } else {
                           _trigger_times["point_brake_end"] = _trigger_times["check_point_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["point_brake_start"] && _trigger_times["point_brake_end"] > _trigger_times["point_brake_start"] &&  _trigger_times["point_brake_end"] - _trigger_times["point_brake_start"] < 10000000) {
                            _trigger_times["point_brake_start"] = 0;
                            _trigger_times["point_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["point_brake_start"] = 0;
                       _trigger_times["point_brake_end"]   = 0;
                   }
               }
               return r;
           }));


            //14.  事故定则，急加速触发场景   URGENT_ACCELERATE
            _trigger_times["check_urgent_accelerate"] = haomo::hios::time::timestamp();
            _trigger_times["urgent_accelerate_start"] = 0;
            _trigger_times["urgent_accelerate_end"] = 0;
            ret |= _co->regist_condition("check_urgent_accelerate",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_urgent_accelerate"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() > 0.3) {
                       if (0 ==  _trigger_times["urgent_accelerate_start"]) {
                           _trigger_times["urgent_accelerate_start"] = _trigger_times["check_urgent_accelerate"];
                       } else {
                           _trigger_times["urgent_accelerate_end"] = _trigger_times["check_urgent_accelerate"]; 
                       }
                   } else {
                       if (0 != _trigger_times["urgent_accelerate_start"] && _trigger_times["urgent_accelerate_end"] - _trigger_times["urgent_accelerate_start"] > 10000000) {
                            _trigger_times["urgent_accelerate_start"] = 0;
                            _trigger_times["urgent_accelerate_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["urgent_accelerate_start"] = 0;
                       _trigger_times["urgent_accelerate_end"]   = 0;
                   }
               }
               return r;
           }));

            //16. 用户数据分析，ADAS功能开启触发   hmi_acc_fd1_data
            _trigger_times["check_adas_open"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_adas_open",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("HmiAccFd1Bus",_trigger_times["check_adas_open"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Data *p_vehicle_data = dynamic_cast<haomo::hios::HmiAccFd1Data *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
               }
               return r;
           }));

            //19. 用户数据分析，变道功能取消触发   hmi_acc_fd1_data
            _trigger_times["check_change_lane_canceled"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_change_lane_canceled",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("plan_alc_decs_data",_trigger_times["check_change_lane_canceled"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::PlanAlcDecsBus *p_plan_alc_desc_bus = dynamic_cast<haomo::hios::PlanAlcDecsBus *>(data.get());
                   if (!p_plan_alc_desc_bus) {
                       continue;
                   }
                   // 时间要大于记录时间_last_plan_alc_lccancelreason
                   if (p_plan_alc_desc_bus->header().stamp() <= _trigger_times["check_change_lane_canceled"]) {
                       continue;
                   }
                   _trigger_times["check_change_lane_canceled"] = p_plan_alc_desc_bus->header().stamp();
                   if ()
               }
               return r;
           }));

            //26.AI场景积累 相机出现上下颠簸
            _trigger_times["check_camera_bumpy"] = haomo::hios::time::timestamp();
            _trigger_times["camera_bumpy_start"] = 0;
            _trigger_times["camera_bumpy_end"] = 0;
            ret |= _co->regist_condition("check_camera_bumpy",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_camera_bumpy"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_camera_bumpy"]) {
                       continue;
                   }
                   _trigger_times["check_camera_bumpy"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["camera_bumpy_start"]) {
                           _trigger_times["camera_bumpy_start"] = _trigger_times["check_camera_bumpy"];
                       } else {
                           _trigger_times["camera_bumpy_end"] = _trigger_times["check_camera_bumpy"]; 
                       }
                   } else {
                       if (0 != _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] > _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] - _trigger_times["camera_bumpy_start"] < 2000000) {
                            _trigger_times["camera_bumpy_start"] = 0;
                            _trigger_times["camera_bumpy_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["camera_bumpy_start"] = 0;
                       _trigger_times["camera_bumpy_end"]   = 0;
                   }
               }
               return r;
           }));

            //27.AI场景积累 道路起伏场景，道路起伏
            _trigger_times["check_road_undulation"] = haomo::hios::time::timestamp();
            _trigger_times["road_undulation_start"] = 0;
            _trigger_times["road_undulation_end"] = 0;
            ret |= _co->regist_condition("check_road_undulation",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_road_undulation"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_road_undulation"]) {
                       continue;
                   }
                   _trigger_times["check_road_undulation"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["road_undulation_start"]) {
                           _trigger_times["road_undulation_start"] = _trigger_times["check_road_undulation"];
                       } else {
                           _trigger_times["road_undulation_end"] = _trigger_times["check_road_undulation"]; 
                       }
                   } else {
                       if (0 != _trigger_times["road_undulation_start"] && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] > 2000000 && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] < 10000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["road_undulation_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["road_undulation_start"] = 0;
                       _trigger_times["road_undulation_end"]   = 0;
                   }
               }
               return r;
           }));

            //28.AI场景积累 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               MLOG(dtcl, ERROR) << "successful trigger";
               for (auto &data : fetch_data)
               {
                   MLOG(dtcl, ERROR) << "successful trigger";
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_fishbone_line"] < 1000000 ) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            MLOG(dtcl, ERROR) << "successful trigger";
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       MLOG(dtcl, ERROR) << "successful trigger";
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           MLOG(dtcl, ERROR) << "successful trigger";
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            //29.AI场景积累 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            //30.AI场景积累 特殊道路场景（上下坡、各型路口）
            _trigger_times["check_special_road"] = haomo::hios::time::timestamp();
            _trigger_times["special_road_start"] = 0;
            _trigger_times["special_road_end"] = 0;
            ret |= _co->regist_condition("check_special_road",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_special_road"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_special_road"]) {
                       continue;
                   }
                   _trigger_times["check_special_road"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (14 <= p_vcan_dms_msg_bus->head_pitch_ang() && 24 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["special_road_start"]) {
                           _trigger_times["special_road_start"] = _trigger_times["check_special_road"];
                       } else {
                           _trigger_times["special_road_end"] = _trigger_times["check_special_road"]; 
                       }
                   } else {
                       if (0 != _trigger_times["special_road_start"] && _trigger_times["special_road_end"] - _trigger_times["special_road_start"] > 5000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["special_road_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["special_road_start"] = 0;
                       _trigger_times["special_road_end"]   = 0;
                   }
               }
               return r;
           }));

            //31.AI场景积累 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_mobile_eye_data->header().stamp();
                   // 触发间隔要大于1s
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_msg_bus->header().stamp();
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            //32.AI场景积累 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           //36.AI场景积累 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //37.AI场景积累 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //39.AI场景积累 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            //40.AI场景积累 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo

name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 8. 事故定则，急刹触发 P00
    {
        trigger_type: TRI_EBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_emergency_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 10. 事故定则，上下匝道触发的数据 P0
    {
        trigger_type: TRI_RAMP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_ramp"
                    op: "eq"
                    value: "true"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 13. 事故定则，点刹触发 P00
    {
        trigger_type: TRI_PBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_point_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 14. 事故定则，急加速触发 P00
    {
        trigger_type: TRI_URGENT_ACCELERATE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_urgent_accelerate"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "true"
                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "LaneChngCfmSwt"
#                        op: "eq"
#                        value: "4"
#                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "true"
                }
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "VoiceBrdcSwt"
#                        op: "eq"
#                        value: "4"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "UsrManSts"
#                        op: "eq"
#                        value: "2"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "AutoSpdSetSwt"
#                        op: "eq"
#                        value: "4"
#                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 26. AI场景积累 相机出现上下颠簸 P0
    {
        trigger_type: TRI_CAMERA_BUMPY
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_camera_bumpy"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 27. AI场景积累 道路起伏场景，道路起伏 P0
    {
        trigger_type: TRI_ROAD_UNDULATION
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_road_undulation"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 30. AI场景积累 特殊道路场景（上下坡、各型路口） P0
    {
        trigger_type: TRI_SPECIAL_ROAD
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_special_road"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]

/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

            // 急刹车场景
        //     _trigger_times["check_ebrake"] = haomo::hios::time::timestamp();
        //     ret |= _co->regist_condition("check_ebrake",
        //                                  std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        //    [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        //    {
        //        ConditionDefine::Value r;
        //        r.is_valid = true;
        //        r.val_bool = false;
        //        auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
        //        for (auto &data : fetch_data)
        //        {
        //            haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
        //            if (!p_mobile_eye_data) {
        //                continue;
        //            }
        //            // 触发间隔要大于1s
        //            if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
        //                continue;
        //            }
        //            if ( p_mobile_eye_data->has_lanes_host())
        //            {
        //                auto lanes_host = p_mobile_eye_data ->lanes_host();
        //                for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_host.lane_marker(i);
        //                     if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //            if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
        //            {
        //                auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
        //                for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
        //                     auto lane_marker = lanes_adjacement.lane_marker(i);
        //                     if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
        //                         _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
        //                         MLOG(dtcl, INFO) << "successful trigger";
        //                         r.val_bool = true;
        //                         return r;
        //                     }
        //                }
        //            }
        //        }
        //        return r;
        //    }));

            //8.  事故定则，急刹触发场景
            _trigger_times["check_emergency_brake"] = haomo::hios::time::timestamp();
            _trigger_times["emergency_brake_start"] = 0;
            _trigger_times["emergency_brake_end"] = 0;
            ret |= _co->regist_condition("check_emergency_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_emergency_brake"]) {
                       continue;
                   }
                   _trigger_times["check_emergency_brake"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() < -0.3) {
                       if (0 ==  _trigger_times["emergency_brake_start"]) {
                           _trigger_times["emergency_brake_start"] = _trigger_times["check_emergency_brake"];
                       } else {
                           _trigger_times["emergency_brake_end"] = _trigger_times["check_emergency_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["emergency_brake_start"] && _trigger_times["emergency_brake_end"] - _trigger_times["emergency_brake_start"] > 10000000) {
                            _trigger_times["emergency_brake_start"] = 0;
                            _trigger_times["emergency_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["emergency_brake_start"] = 0;
                       _trigger_times["emergency_brake_end"]   = 0;
                   }
               }
               return r;
           }));



            //10  事故定则，上下匝道触发场景
            _trigger_times["check_ramp"] = haomo::hios::time::timestamp();
            _last_nav_road_type = 0;
            ret |= _co->regist_condition("check_ramp",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data",_trigger_times["check_emergency_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_hut_msg_bus->header().stamp() <= _trigger_times["check_ramp"]) {
                       continue;
                   }
                   _trigger_times["check_ramp"] = p_vcan_hut_msg_bus->header().stamp();
                   if (7 == p_vcan_hut_msg_bus->nav_road_type()) {
                       if (_last_nav_road_type != 7 ) {
                           _last_nav_road_type = 7;
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = 7;
                   } else {
                        if (_last_nav_road_type == 7 ) {
                           _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                   }
               }
               return r;
           }));

            //13.  事故定则，点刹触发场景
            _trigger_times["check_point_brake"] = haomo::hios::time::timestamp();
            _trigger_times["point_brake_start"] = 0;
            _trigger_times["point_brake_end"] = 0;
            ret |= _co->regist_condition("check_point_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_point_brake"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_point_brake"]) {
                       continue;
                   }
                   _trigger_times["check_point_brake"] = p_vehicle_data->header().stamp();
                   if ( p_vehicle_data->axrefms2() > -0.1 && p_vehicle_data->axrefms2() < 0.0) {
                       if (0 ==  _trigger_times["point_brake_start"]) {
                           _trigger_times["point_brake_start"] = _trigger_times["check_point_brake"];
                       } else {
                           _trigger_times["point_brake_end"] = _trigger_times["check_point_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["point_brake_start"] && _trigger_times["point_brake_end"] > _trigger_times["point_brake_start"] &&  _trigger_times["point_brake_end"] - _trigger_times["point_brake_start"] < 10000000) {
                            _trigger_times["point_brake_start"] = 0;
                            _trigger_times["point_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["point_brake_start"] = 0;
                       _trigger_times["point_brake_end"]   = 0;
                   }
               }
               return r;
           }));


            //14.  事故定则，急加速触发场景   URGENT_ACCELERATE
            _trigger_times["check_urgent_accelerate"] = haomo::hios::time::timestamp();
            _trigger_times["urgent_accelerate_start"] = 0;
            _trigger_times["urgent_accelerate_end"] = 0;
            ret |= _co->regist_condition("check_urgent_accelerate",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_urgent_accelerate"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() > 0.3) {
                       if (0 ==  _trigger_times["urgent_accelerate_start"]) {
                           _trigger_times["urgent_accelerate_start"] = _trigger_times["check_urgent_accelerate"];
                       } else {
                           _trigger_times["urgent_accelerate_end"] = _trigger_times["check_urgent_accelerate"]; 
                       }
                   } else {
                       if (0 != _trigger_times["urgent_accelerate_start"] && _trigger_times["urgent_accelerate_end"] - _trigger_times["urgent_accelerate_start"] > 10000000) {
                            _trigger_times["urgent_accelerate_start"] = 0;
                            _trigger_times["urgent_accelerate_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["urgent_accelerate_start"] = 0;
                       _trigger_times["urgent_accelerate_end"]   = 0;
                   }
               }
               return r;
           }));



            //16. 用户数据分析，ADAS功能开启触发   hmi_acc_fd1_data
            _trigger_times["check_adas_open"] = haomo::hios::time::timestamp();

            _longctrl_modsts_time = haomo::hios::time::timestamp();
            _tja_ica_moddisp_time = haomo::hios::time::timestamp();
            _noh_sts_time         = haomo::hios::time::timestamp();

            ret |= _co->regist_condition("check_adas_open",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd1_data",_longctrl_modsts_time, now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Bus *p_hmi_acc_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                   if (!p_hmi_acc_fd1_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd1_bus->header().stamp() <= _longctrl_modsts_time) {
                       continue;
                   }
                   _longctrl_modsts_time = p_hmi_acc_fd1_bus->header().stamp();
                   uint32_t longctrl_modsts = p_hmi_acc_fd1_bus->longctrl_modsts();
                   if ( (2 == _last_longctrl_modsts || 1 == _last_longctrl_modsts) && (3 == longctrl_modsts || 4 == longctrl_modsts || 5 == longctrl_modsts || 6 == longctrl_modsts)) {
                       r.val_bool = true;
                       _last_longctrl_modsts = longctrl_modsts;
                       break;
                   }
                   _last_longctrl_modsts = longctrl_modsts;
               }
               fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd2_data",_tja_ica_moddisp_time, now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd2Bus *p_hmi_acc_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                   if (!p_hmi_acc_fd2_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd2_bus->header().stamp() <= _tja_ica_moddisp_time) {
                       continue;
                   }
                   _tja_ica_moddisp_time = p_hmi_acc_fd2_bus->header().stamp();
                   uint32_t tja_ica_moddisp = p_hmi_acc_fd2_bus->tja_ica_moddisp();
                   if ( 3 == _last_tja_ica_moddisp && 2  == tja_ica_moddisp ) {
                       r.val_bool = true;
                       _last_tja_ica_moddisp = tja_ica_moddisp;
                       break;
                   }
                   _last_tja_ica_moddisp = tja_ica_moddisp;
               }

               fetch_data = ::haomo::hios::dao::msg::history_between("vsm_hmi_data",_noh_sts_time, now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmHmiBus *p_vsm_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                   if (!p_vsm_hmi_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_vsm_hmi_bus->header().stamp() <= _noh_sts_time) {
                       continue;
                   }
                   _noh_sts_time = p_vsm_hmi_bus->header().stamp();
                   if ((0 == _last_noh_sts || 1 == _last_noh_sts) && (2 == p_vsm_hmi_bus->noh_sts() || 3 == p_vsm_hmi_bus->noh_sts())) {
                       _last_noh_sts = p_vsm_hmi_bus->noh_sts();
                       r.val_bool = true;
                       break;
                   }
                   _last_noh_sts = p_vsm_hmi_bus->noh_sts();
               }
               return r;
           }));

            //17. 用户数据分析，ADAS功能关闭触发
            _trigger_times["check_adas_close"] = haomo::hios::time::timestamp();

            _close_longctrl_modsts_time = haomo::hios::time::timestamp();
            _close_tja_ica_moddisp_time = haomo::hios::time::timestamp();
            _close_noh_sts_time         = haomo::hios::time::timestamp();

            ret |= _co->regist_condition("check_adas_close",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd1_data",_close_longctrl_modsts_time, now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Bus *p_hmi_acc_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                   if (!p_hmi_acc_fd1_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd1_bus->header().stamp() <= _close_longctrl_modsts_time) {
                       continue;
                   }
                   _close_longctrl_modsts_time = p_hmi_acc_fd1_bus->header().stamp();
                   uint32_t longctrl_modsts = p_hmi_acc_fd1_bus->longctrl_modsts();
                   if ( (3 == _close_last_longctrl_modsts || 4 == _close_last_longctrl_modsts || 5 == _close_last_longctrl_modsts || 6 == _close_last_longctrl_modsts) && (1 == longctrl_modsts || 2 == longctrl_modsts || 7 == longctrl_modsts)) {
                       r.val_bool = true;
                       _close_last_longctrl_modsts = longctrl_modsts;
                       break;
                   }
                   _close_last_longctrl_modsts = longctrl_modsts;
               }
               fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd2_data",_close_tja_ica_moddisp_time, now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd2Bus *p_hmi_acc_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                   if (!p_hmi_acc_fd2_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd2_bus->header().stamp() <= _close_tja_ica_moddisp_time) {
                       continue;
                   }
                   _close_tja_ica_moddisp_time = p_hmi_acc_fd2_bus->header().stamp();
                   uint32_t tja_ica_moddisp = p_hmi_acc_fd2_bus->tja_ica_moddisp();
                   if ( 2 == _close_last_tja_ica_moddisp && 2 != tja_ica_moddisp ) {
                       r.val_bool = true;
                       _close_last_tja_ica_moddisp = tja_ica_moddisp;
                       break;
                   }
                   _close_last_tja_ica_moddisp = tja_ica_moddisp;
               }

               fetch_data = ::haomo::hios::dao::msg::history_between("vsm_hmi_data",_close_noh_sts_time, now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmHmiBus *p_vsm_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                   if (!p_vsm_hmi_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_vsm_hmi_bus->header().stamp() <= _close_noh_sts_time) {
                       continue;
                   }
                   _close_noh_sts_time = p_vsm_hmi_bus->header().stamp();
                   if ((2 == _close_last_noh_sts || 3 == _close_last_noh_sts) && (0 == p_vsm_hmi_bus->noh_sts() || 1 == p_vsm_hmi_bus->noh_sts())) {
                       _close_last_noh_sts = p_vsm_hmi_bus->noh_sts();
                       r.val_bool = true;
                       break;
                   }
                   _close_last_noh_sts = p_vsm_hmi_bus->noh_sts();
               }
               return r;
           }));

            //19. 用户数据分析，变道功能取消触发   
            _trigger_times["check_change_lane_canceled"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_change_lane_canceled",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("plan_alc_decs_data",_trigger_times["check_change_lane_canceled"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::PlanAlcDecsBus *p_plan_alc_desc_bus = dynamic_cast<haomo::hios::PlanAlcDecsBus *>(data.get());
                   if (!p_plan_alc_desc_bus) {
                       continue;
                   }
                   // 时间要大于记录时间_last_plan_alc_lccancelreason
                   if (p_plan_alc_desc_bus->header().stamp() <= _trigger_times["check_change_lane_canceled"]) {
                       continue;
                   }
                   _trigger_times["check_change_lane_canceled"] = p_plan_alc_desc_bus->header().stamp();
                   if (0 == _last_plan_alc_lccancelreason && 0 != p_plan_alc_desc_bus->plan_alc_lccancelreason()) {
                       _last_plan_alc_lccancelreason = p_plan_alc_desc_bus->plan_alc_lccancelreason();
                       r.val_bool = true;
                       return r;
                   } else {
                       _last_plan_alc_lccancelreason = p_plan_alc_desc_bus->plan_alc_lccancelreason();
                   }
               }
               return r;
           }));

            //26.AI场景积累 相机出现上下颠簸
            _trigger_times["check_camera_bumpy"] = haomo::hios::time::timestamp();
            _trigger_times["camera_bumpy_start"] = 0;
            _trigger_times["camera_bumpy_end"] = 0;
            ret |= _co->regist_condition("check_camera_bumpy",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_camera_bumpy"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_camera_bumpy"]) {
                       continue;
                   }
                   _trigger_times["check_camera_bumpy"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["camera_bumpy_start"]) {
                           _trigger_times["camera_bumpy_start"] = _trigger_times["check_camera_bumpy"];
                       } else {
                           _trigger_times["camera_bumpy_end"] = _trigger_times["check_camera_bumpy"]; 
                       }
                   } else {
                       if (0 != _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] > _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] - _trigger_times["camera_bumpy_start"] < 2000000) {
                            _trigger_times["camera_bumpy_start"] = 0;
                            _trigger_times["camera_bumpy_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["camera_bumpy_start"] = 0;
                       _trigger_times["camera_bumpy_end"]   = 0;
                   }
               }
               return r;
           }));

            //27.AI场景积累 道路起伏场景，道路起伏
            _trigger_times["check_road_undulation"] = haomo::hios::time::timestamp();
            _trigger_times["road_undulation_start"] = 0;
            _trigger_times["road_undulation_end"] = 0;
            ret |= _co->regist_condition("check_road_undulation",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_road_undulation"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_road_undulation"]) {
                       continue;
                   }
                   _trigger_times["check_road_undulation"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["road_undulation_start"]) {
                           _trigger_times["road_undulation_start"] = _trigger_times["check_road_undulation"];
                       } else {
                           _trigger_times["road_undulation_end"] = _trigger_times["check_road_undulation"]; 
                       }
                   } else {
                       if (0 != _trigger_times["road_undulation_start"] && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] > 2000000 && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] < 10000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["road_undulation_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["road_undulation_start"] = 0;
                       _trigger_times["road_undulation_end"]   = 0;
                   }
               }
               return r;
           }));

            //28.AI场景积累 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               MLOG(dtcl, ERROR) << "successful trigger";
               for (auto &data : fetch_data)
               {
                   MLOG(dtcl, ERROR) << "successful trigger";
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_fishbone_line"] < 1000000 ) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "successful trigger";
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            MLOG(dtcl, ERROR) << "successful trigger";
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       MLOG(dtcl, ERROR) << "successful trigger";
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           MLOG(dtcl, ERROR) << "successful trigger";
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, ERROR) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            //29.AI场景积累 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            //30.AI场景积累 特殊道路场景（上下坡、各型路口）
            _trigger_times["check_special_road"] = haomo::hios::time::timestamp();
            _trigger_times["special_road_start"] = 0;
            _trigger_times["special_road_end"] = 0;
            ret |= _co->regist_condition("check_special_road",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_special_road"], now);
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_special_road"]) {
                       continue;
                   }
                   _trigger_times["check_special_road"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (14 <= p_vcan_dms_msg_bus->head_pitch_ang() && 24 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["special_road_start"]) {
                           _trigger_times["special_road_start"] = _trigger_times["check_special_road"];
                       } else {
                           _trigger_times["special_road_end"] = _trigger_times["check_special_road"]; 
                       }
                   } else {
                       if (0 != _trigger_times["special_road_start"] && _trigger_times["special_road_end"] - _trigger_times["special_road_start"] > 5000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["special_road_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["special_road_start"] = 0;
                       _trigger_times["special_road_end"]   = 0;
                   }
               }
               return r;
           }));

            //31.AI场景积累 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_mobile_eye_data->header().stamp();
                   // 触发间隔要大于1s
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   uint64_t now_time = haomo::hios::time::timestamp(); 
                   uint64_t stamp = p_msg_bus->header().stamp();
                   if (now_time - stamp >1000000 || stamp - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            //32.AI场景积累 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           //36.AI场景积累 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //37.AI场景积累 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //39.AI场景积累 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            //40.AI场景积累 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo


name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 8. 事故定则，急刹触发 P00
    {
        trigger_type: TRI_EBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_emergency_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 10. 事故定则，上下匝道触发的数据 P0
    {
        trigger_type: TRI_RAMP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_ramp"
                    op: "eq"
                    value: "true"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 13. 事故定则，点刹触发 P00
    {
        trigger_type: TRI_PBRAKE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_point_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 14. 事故定则，急加速触发 P00
    {
        trigger_type: TRI_URGENT_ACCELERATE
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_urgent_accelerate"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 16. 用户数据分析，ADAS功能开启触发 P0
    {
        trigger_type: TRI_ADAS_OPEN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_adas_open"
                        op: "eq"
                        value: "true"
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd1_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_hmi_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 16. 用户数据分析，ADAS功能关闭触发 P0
    {
        trigger_type: TRI_ADAS_CLOSE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_adas_close"
                        op: "eq"
                        value: "true"
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd1_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_hmi_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 19. 用户数据分析，ADAS功能关闭触发 P0
    {
        trigger_type: TRI_ADAS_CLOSE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                    {
                        type: "check_change_lane_canceled"
                        op: "eq"
                        value: "true"
                    }
                ]

        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "true"
                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "LaneChngCfmSwt"
#                        op: "eq"
#                        value: "4"
#                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "true"
                },
                {
                        type: "cond_bool"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "true"
                }
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "VoiceBrdcSwt"
#                        op: "eq"
#                        value: "4"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "UsrManSts"
#                        op: "eq"
#                        value: "2"
#                },
#                {
#                        type: "cond_uint32"
#                        topic: "vcan_hut_data"
#                        fields: "AutoSpdSetSwt"
#                        op: "eq"
#                        value: "4"
#                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 26. AI场景积累 相机出现上下颠簸 P0
    {
        trigger_type: TRI_CAMERA_BUMPY
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_camera_bumpy"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 27. AI场景积累 道路起伏场景，道路起伏 P0
    {
        trigger_type: TRI_ROAD_UNDULATION
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_road_undulation"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 30. AI场景积累 特殊道路场景（上下坡、各型路口） P0
    {
        trigger_type: TRI_SPECIAL_ROAD
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_special_road"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]
























    # 16. 用户数据分析，ADAS功能关闭触发 P0
    {
        trigger_type: TRI_ADAS_CLOSE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_adas_close"
                        op: "eq"
                        value: "true"
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd1_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_hmi_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 19. 用户数据分析，变道功能取消触发 P0
    {
        trigger_type: TRI_CHANGE_LANE_CANCELED
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                    {
                        type: "check_change_lane_canceled"
                        op: "eq"
                        value: "true"
                    }
                ]

        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },

09. 下午面试两人 

/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include <algorithm>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
        _update_oss_address = sts_token_str[haomo::v2x::key_PREFIX].asString();
        _update_bucket_name = sts_token_str[haomo::v2x::key_BUCKET_NAME].asString();
        _update_oss_url = sts_token_str[haomo::v2x::key_END_POINT].asString();
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(dtcl, ERROR) << "Failed to init ipc node";
        return 1;
    }
    _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        // std::string oss_upload_directory_path = _update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_directory_path = _update_oss_address +get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", _update_bucket_name, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", _update_bucket_name, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   auto fsm_substate = p_fsmdata->fsm_substate();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE && fsm_substate != FsmState::REMOTE_ARRIVED && fsm_substate != FsmState::ADS_ARRIVED)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));


            //8.  事故定则，急刹触发场景
            _trigger_times["check_emergency_brake"] = haomo::hios::time::timestamp();
            _trigger_times["emergency_brake_start"] = 0;
            _trigger_times["emergency_brake_end"] = 0;
            ret |= _co->regist_condition("check_emergency_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_emergency_brake"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_emergency_brake"]) {
                       continue;
                   }
                   _trigger_times["check_emergency_brake"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() < -0.3) {
                       if (0 ==  _trigger_times["emergency_brake_start"]) {
                           _trigger_times["emergency_brake_start"] = _trigger_times["check_emergency_brake"];
                       } else {
                           _trigger_times["emergency_brake_end"] = _trigger_times["check_emergency_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["emergency_brake_start"] && _trigger_times["emergency_brake_end"] - _trigger_times["emergency_brake_start"] > 1000000) {
                            _trigger_times["emergency_brake_start"] = 0;
                            _trigger_times["emergency_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["emergency_brake_start"] = 0;
                       _trigger_times["emergency_brake_end"]   = 0;
                   }
               }
               return r;
           }));



            //10  事故定则，上下匝道触发场景
            _trigger_times["check_ramp"] = haomo::hios::time::timestamp();
            _last_nav_road_type = 0;
            ret |= _co->regist_condition("check_ramp",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data",_trigger_times["check_emergency_brake"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_hut_msg_bus->header().stamp() <= _trigger_times["check_ramp"]) {
                       continue;
                   }
                   _trigger_times["check_ramp"] = p_vcan_hut_msg_bus->header().stamp();
                   if (7 == p_vcan_hut_msg_bus->nav_road_type()) {
                       if (_last_nav_road_type != 7 ) {
                           _last_nav_road_type = 7;
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = 7;
                   } else {
                        if (_last_nav_road_type == 7 ) {
                           _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                   }
               }
               return r;
           }));

            //13.  事故定则，点刹触发场景
            _trigger_times["check_point_brake"] = haomo::hios::time::timestamp();
            _trigger_times["point_brake_start"] = 0;
            _trigger_times["point_brake_end"] = 0;
            ret |= _co->regist_condition("check_point_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_point_brake"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_point_brake"]) {
                       continue;
                   }
                   _trigger_times["check_point_brake"] = p_vehicle_data->header().stamp();
                   if ( p_vehicle_data->axrefms2() > -0.1 && p_vehicle_data->axrefms2() < 0.0) {
                       if (0 ==  _trigger_times["point_brake_start"]) {
                           _trigger_times["point_brake_start"] = _trigger_times["check_point_brake"];
                       } else {
                           _trigger_times["point_brake_end"] = _trigger_times["check_point_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["point_brake_start"] && _trigger_times["point_brake_end"] > _trigger_times["point_brake_start"] &&  _trigger_times["point_brake_end"] - _trigger_times["point_brake_start"] < 1000000) {
                            _trigger_times["point_brake_start"] = 0;
                            _trigger_times["point_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["point_brake_start"] = 0;
                       _trigger_times["point_brake_end"]   = 0;
                   }
               }
               return r;
           }));


            //14.  事故定则，急加速触发场景   URGENT_ACCELERATE
            _trigger_times["check_urgent_accelerate"] = haomo::hios::time::timestamp();
            _trigger_times["urgent_accelerate_start"] = 0;
            _trigger_times["urgent_accelerate_end"] = 0;
            ret |= _co->regist_condition("check_urgent_accelerate",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_urgent_accelerate"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() > 0.3) {
                       if (0 ==  _trigger_times["urgent_accelerate_start"]) {
                           _trigger_times["urgent_accelerate_start"] = _trigger_times["check_urgent_accelerate"];
                       } else {
                           _trigger_times["urgent_accelerate_end"] = _trigger_times["check_urgent_accelerate"]; 
                       }
                   } else {
                       if (0 != _trigger_times["urgent_accelerate_start"] && _trigger_times["urgent_accelerate_end"] - _trigger_times["urgent_accelerate_start"] > 1000000) {
                            _trigger_times["urgent_accelerate_start"] = 0;
                            _trigger_times["urgent_accelerate_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["urgent_accelerate_start"] = 0;
                       _trigger_times["urgent_accelerate_end"]   = 0;
                   }
               }
               return r;
           }));



            //16. 用户数据分析，ADAS功能开启触发   hmi_acc_fd1_data
            _trigger_times["check_adas_open"] = haomo::hios::time::timestamp();

            _longctrl_modsts_time = haomo::hios::time::timestamp();
            _tja_ica_moddisp_time = haomo::hios::time::timestamp();
            _noh_sts_time         = haomo::hios::time::timestamp();

            ret |= _co->regist_condition("check_adas_open",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd1_data",_longctrl_modsts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Bus *p_hmi_acc_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                   if (!p_hmi_acc_fd1_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd1_bus->header().stamp() <= _longctrl_modsts_time) {
                       continue;
                   }
                   _longctrl_modsts_time = p_hmi_acc_fd1_bus->header().stamp();
                   uint32_t longctrl_modsts = p_hmi_acc_fd1_bus->longctrl_modsts();
                   if ( (2 == _last_longctrl_modsts || 1 == _last_longctrl_modsts) && (3 == longctrl_modsts || 4 == longctrl_modsts || 5 == longctrl_modsts || 6 == longctrl_modsts)) {
                       r.val_bool = true;
                       _last_longctrl_modsts = longctrl_modsts;
                       break;
                   }
                   _last_longctrl_modsts = longctrl_modsts;
               }
               fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd2_data",_tja_ica_moddisp_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd2Bus *p_hmi_acc_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                   if (!p_hmi_acc_fd2_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd2_bus->header().stamp() <= _tja_ica_moddisp_time) {
                       continue;
                   }
                   _tja_ica_moddisp_time = p_hmi_acc_fd2_bus->header().stamp();
                   uint32_t tja_ica_moddisp = p_hmi_acc_fd2_bus->tja_ica_moddisp();
                   if ( 3 == _last_tja_ica_moddisp && 2  == tja_ica_moddisp ) {
                       r.val_bool = true;
                       _last_tja_ica_moddisp = tja_ica_moddisp;
                       break;
                   }
                   _last_tja_ica_moddisp = tja_ica_moddisp;
               }

               fetch_data = ::haomo::hios::dao::msg::history_between("vsm_hmi_data",_noh_sts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmHmiBus *p_vsm_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                   if (!p_vsm_hmi_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_vsm_hmi_bus->header().stamp() <= _noh_sts_time) {
                       continue;
                   }
                   _noh_sts_time = p_vsm_hmi_bus->header().stamp();
                   if ((0 == _last_noh_sts || 1 == _last_noh_sts) && (2 == p_vsm_hmi_bus->noh_sts() || 3 == p_vsm_hmi_bus->noh_sts())) {
                       _last_noh_sts = p_vsm_hmi_bus->noh_sts();
                       r.val_bool = true;
                       break;
                   }
                   _last_noh_sts = p_vsm_hmi_bus->noh_sts();
               }
               return r;
           }));

            //17. 用户数据分析，ADAS功能关闭触发
            _trigger_times["check_adas_close"] = haomo::hios::time::timestamp();

            _close_longctrl_modsts_time = haomo::hios::time::timestamp();
            _close_tja_ica_moddisp_time = haomo::hios::time::timestamp();
            _close_noh_sts_time         = haomo::hios::time::timestamp();

            ret |= _co->regist_condition("check_adas_close",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd1_data",_close_longctrl_modsts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Bus *p_hmi_acc_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                   if (!p_hmi_acc_fd1_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd1_bus->header().stamp() <= _close_longctrl_modsts_time) {
                       continue;
                   }
                   _close_longctrl_modsts_time = p_hmi_acc_fd1_bus->header().stamp();
                   uint32_t longctrl_modsts = p_hmi_acc_fd1_bus->longctrl_modsts();
                   if ( (3 == _close_last_longctrl_modsts || 4 == _close_last_longctrl_modsts || 5 == _close_last_longctrl_modsts || 6 == _close_last_longctrl_modsts) && (1 == longctrl_modsts || 2 == longctrl_modsts || 7 == longctrl_modsts)) {
                       r.val_bool = true;
                       _close_last_longctrl_modsts = longctrl_modsts;
                       break;
                   }
                   _close_last_longctrl_modsts = longctrl_modsts;
               }
               fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd2_data",_close_tja_ica_moddisp_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd2Bus *p_hmi_acc_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                   if (!p_hmi_acc_fd2_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd2_bus->header().stamp() <= _close_tja_ica_moddisp_time) {
                       continue;
                   }
                   _close_tja_ica_moddisp_time = p_hmi_acc_fd2_bus->header().stamp();
                   uint32_t tja_ica_moddisp = p_hmi_acc_fd2_bus->tja_ica_moddisp();
                   if ( 2 == _close_last_tja_ica_moddisp && 2 != tja_ica_moddisp ) {
                       r.val_bool = true;
                       _close_last_tja_ica_moddisp = tja_ica_moddisp;
                       break;
                   }
                   _close_last_tja_ica_moddisp = tja_ica_moddisp;
               }

               fetch_data = ::haomo::hios::dao::msg::history_between("vsm_hmi_data",_close_noh_sts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmHmiBus *p_vsm_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                   if (!p_vsm_hmi_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_vsm_hmi_bus->header().stamp() <= _close_noh_sts_time) {
                       continue;
                   }
                   _close_noh_sts_time = p_vsm_hmi_bus->header().stamp();
                   if ((2 == _close_last_noh_sts || 3 == _close_last_noh_sts) && (0 == p_vsm_hmi_bus->noh_sts() || 1 == p_vsm_hmi_bus->noh_sts())) {
                       _close_last_noh_sts = p_vsm_hmi_bus->noh_sts();
                       r.val_bool = true;
                       break;
                   }
                   _close_last_noh_sts = p_vsm_hmi_bus->noh_sts();
               }
               return r;
           }));

            //19. 用户数据分析，变道功能取消触发   
            _trigger_times["check_change_lane_canceled"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_change_lane_canceled",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("plan_alc_decs_data",_trigger_times["check_change_lane_canceled"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::PlanAlcDecsBus *p_plan_alc_desc_bus = dynamic_cast<haomo::hios::PlanAlcDecsBus *>(data.get());
                   if (!p_plan_alc_desc_bus) {
                       continue;
                   }
                   // 时间要大于记录时间_last_plan_alc_lccancelreason
                   if (p_plan_alc_desc_bus->header().stamp() <= _trigger_times["check_change_lane_canceled"]) {
                       continue;
                   }
                   _trigger_times["check_change_lane_canceled"] = p_plan_alc_desc_bus->header().stamp();
                   if (0 == _last_plan_alc_lccancelreason && 0 != p_plan_alc_desc_bus->plan_alc_lccancelreason()) {
                       _last_plan_alc_lccancelreason = p_plan_alc_desc_bus->plan_alc_lccancelreason();
                       r.val_bool = true;
                       return r;
                   } else {
                       _last_plan_alc_lccancelreason = p_plan_alc_desc_bus->plan_alc_lccancelreason();
                   }
               }
               return r;
           }));

            //26.AI场景积累 相机出现上下颠簸
            _trigger_times["check_camera_bumpy"] = haomo::hios::time::timestamp();
            _trigger_times["camera_bumpy_start"] = 0;
            _trigger_times["camera_bumpy_end"] = 0;
            ret |= _co->regist_condition("check_camera_bumpy",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_camera_bumpy"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_camera_bumpy"]) {
                       continue;
                   }
                   _trigger_times["check_camera_bumpy"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["camera_bumpy_start"]) {
                           _trigger_times["camera_bumpy_start"] = _trigger_times["check_camera_bumpy"];
                       } else {
                           _trigger_times["camera_bumpy_end"] = _trigger_times["check_camera_bumpy"]; 
                       }
                   } else {
                       if (0 != _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] > _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] - _trigger_times["camera_bumpy_start"] < 200000) {
                            _trigger_times["camera_bumpy_start"] = 0;
                            _trigger_times["camera_bumpy_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["camera_bumpy_start"] = 0;
                       _trigger_times["camera_bumpy_end"]   = 0;
                   }
               }
               return r;
           }));

            //27.AI场景积累 道路起伏场景，道路起伏
            _trigger_times["check_road_undulation"] = haomo::hios::time::timestamp();
            _trigger_times["road_undulation_start"] = 0;
            _trigger_times["road_undulation_end"] = 0;
            ret |= _co->regist_condition("check_road_undulation",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_road_undulation"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_road_undulation"]) {
                       continue;
                   }
                   _trigger_times["check_road_undulation"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["road_undulation_start"]) {
                           _trigger_times["road_undulation_start"] = _trigger_times["check_road_undulation"];
                       } else {
                           _trigger_times["road_undulation_end"] = _trigger_times["check_road_undulation"]; 
                       }
                   } else {
                       if (0 != _trigger_times["road_undulation_start"] && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] > 200000 && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] < 1000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["road_undulation_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["road_undulation_start"] = 0;
                       _trigger_times["road_undulation_end"]   = 0;
                   }
               }
               return r;
           }));

            //28.AI场景积累 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_fishbone_line"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_fishbone_line"]  ) {
                       continue;
                   }
                   _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            //29.AI场景积累 地面无车道线场景
            _trigger_times["check_no_lane_line"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_no_lane_line"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_no_lane_line"]) {
                       continue;
                   }
                   _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            //30.AI场景积累 特殊道路场景（上下坡、各型路口）
            _trigger_times["check_special_road"] = haomo::hios::time::timestamp();
            _trigger_times["special_road_start"] = 0;
            _trigger_times["special_road_end"] = 0;
            ret |= _co->regist_condition("check_special_road",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_special_road"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "stamp: " << p_vcan_dms_msg_bus->header().stamp();
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_special_road"]) {
                       continue;
                   }
                    _trigger_times["check_special_road"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (14 <= p_vcan_dms_msg_bus->head_pitch_ang() && 24 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["special_road_start"]) {
                           _trigger_times["special_road_start"] = _trigger_times["check_special_road"];
                       } else {
                           _trigger_times["special_road_end"] = _trigger_times["check_special_road"]; 
                       }
                   } else {
                       if (0 != _trigger_times["special_road_start"] && _trigger_times["special_road_end"] - _trigger_times["special_road_start"] > 5000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["special_road_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["special_road_start"] = 0;
                       _trigger_times["special_road_end"]   = 0;
                   }
               }
               return r;
           }));

            //31.AI场景积累 特殊天气场景
            _trigger_times["check_special_weather_scene"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_special_weather_scene"], now);
               _trigger_times["check_special_weather_scene"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::history_between("vcan_csa_data", _trigger_times["check_special_weather_scene"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       return r;
                   }
               }
           return r;
           }));

            //32.AI场景积累 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_lane_line_covered"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_lane_line_covered"] ) {
                       continue;
                   }
                   _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();

                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           //36.AI场景积累 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_animal"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_animal"] ) {
                       continue;
                   }
                   _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //37.AI场景积累 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_general_obstacle"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_general_obstacle"]) {
                       continue;
                   }
                   _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           //39.AI场景积累 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_mini_car"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_mini_car"] ) {
                       continue;
                   }
                   _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            //40.AI场景积累 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               int64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_large_truck"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_large_truck"] ) {
                       continue;
                   }
                   _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

            _trigger_times["check_adas_closed"] = 0;
            // 检查自动驾驶是否关闭
            ret |= _co->regist_condition("check_adas_closed",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            {
                 ConditionDefine::Value r;
                 r.is_valid = true;
                 r.val_bool = false;
                 uint64_t now = haomo::hios::time::timestamp(); 
                 auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd1_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd1Bus *p_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                     if(!p_fd1_bus || p_fd1_bus->header().stamp() + 1000000 < now ) {
                         continue;
                     }
                     auto modsts = p_fd1_bus->longctrl_modsts();
                     if (!(modsts == 3 || modsts == 4 || modsts == 5 || modsts == 6)) {
                         r.val_bool = true;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd2_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd2Bus *p_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                     if(!p_fd2_bus|| p_fd2_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto moddisp = p_fd2_bus->tja_ica_moddisp();
                     if (moddisp != 2) {
                         r.val_bool = true;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("vsm_hmi_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::VsmHmiBus *p_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                     if(!p_hmi_bus || p_hmi_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto noh_sts = p_hmi_bus->noh_sts();
                     if (!(noh_sts == 2 || noh_sts == 3)) {
                         r.val_bool = true;
                     }
                 }
                return r;
            }));

            _trigger_times["check_adas_open"] = 0;
            // 检查自动驾驶是否开启
            ret |= _co->regist_condition("check_adas_open",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            {
                 ConditionDefine::Value r;
                 r.is_valid = true;
                 r.val_bool = false;
                 uint64_t now = haomo::hios::time::timestamp(); 
                 auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd1_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd1Bus *p_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                     if(!p_fd1_bus || p_fd1_bus->header().stamp() + 1000000 < now ) {
                         continue;
                     }
                     auto modsts = p_fd1_bus->longctrl_modsts();
                     if ((modsts == 3 || modsts == 4 || modsts == 5 || modsts == 6)) {
                         r.val_bool = true;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd2_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd2Bus *p_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                     if(!p_fd2_bus|| p_fd2_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto moddisp = p_fd2_bus->tja_ica_moddisp();
                     if (moddisp == 2) {
                         r.val_bool = true;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("vsm_hmi_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::VsmHmiBus *p_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                     if(!p_hmi_bus || p_hmi_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto noh_sts = p_hmi_bus->noh_sts();
                     if ((noh_sts == 2 || noh_sts == 3)) {
                         r.val_bool = true;
                     }
                 }
                return r;
            }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo
     
12. 上午m1雷达
    下午 
    13:52 

    begin_time 改为-5    一次触发时长12s
    下午配置文件中触发时间

13. 上午确认8号车m1状态
    工作沟通

    下午编写规则

2021年10月15日
    研发工作：
        1. 数据回传1.5修复采集时长不一致问题。修改HMI触发，接管触发规则。
    下周计划：
        1、ICU1.5提测。
        2、采集数据加密方案调研。
        3、采集数据统计脚本编写

15.  name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 20 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 20
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                },
                {
                    type: "check_adas_opened"
                    op: "eq"
                    value: "true"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 20 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_take_over"
                        op: "eq"
                        value: "true"
                    }
                ]
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 20  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 8. 事故定则，急刹触发 P00
    {
        trigger_type: TRI_EBRAKE
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_emergency_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 10. 事故定则，上下匝道触发的数据 P0
    {
        trigger_type: TRI_RAMP
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_ramp"
                    op: "eq"
                    value: "true"
                },
                {
                    type: "check_adas_opened"
                    op: "eq"
                    value: "true"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_adas_opened"
                    op: "eq"
                    value: "true"
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 13. 事故定则，点刹触发 P00
    {
        trigger_type: TRI_PBRAKE
        trigger_priority : 1
        duration_time : 10
        video_trigger_counts : 3
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_point_brake"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -5    # 5s前数据
                duration_time : 10  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 14. 事故定则，急加速触发 P00
    {
        trigger_type: TRI_URGENT_ACCELERATE
        trigger_priority : 1
        duration_time : 10
        video_trigger_counts : 3
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "vehicle_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                },
                {
                    type: "check_urgent_accelerate"
                    op: "eq"
                    value: "true"
                }
            ]
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 10  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 16. 用户数据分析，ADAS功能开启触发 P0
    {
        trigger_type: TRI_ADAS_OPEN
        trigger_priority : 1
        duration_time : 2
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_adas_open"
                        op: "eq"
                        value: "true"
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd1_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_hmi_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                }
        }
        datas : [
            {
                begin_time : -1    # 10s前数据
                duration_time : 2  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 17. 用户数据分析，ADAS功能关闭触发 P0
    {
        trigger_type: TRI_ADAS_CLOSE
        trigger_priority : 1
        duration_time : 2
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "check_adas_close"
                        op: "eq"
                        value: "true"
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd1_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_acc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_hmi_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                }
        }
        datas : [
            {
                begin_time : -1    # 10s前数据
                duration_time : 2  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 19. 用户数据分析，变道功能取消触发 P0
    {
        trigger_type: TRI_CHANGE_LANE_CANCELED
        trigger_priority : 1
        duration_time : 20
        video_trigger_counts : 3
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_change_lane_canceled"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]

        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 1
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_hmi_operation"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : 0    # 10s前数据
                duration_time : 1  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 26. AI场景积累 相机出现上下颠簸 P0
    {
        trigger_type: TRI_CAMERA_BUMPY
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_camera_bumpy"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 27. AI场景积累 道路起伏场景，道路起伏 P0
    {
        trigger_type: TRI_ROAD_UNDULATION
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_road_undulation"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 29. AI场景积累，地面无车道线场景 P0
    {
        trigger_type: TRI_NO_LANE_LINE
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_no_lane_line"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 30. AI场景积累 特殊道路场景（上下坡、各型路口） P0
    {
        trigger_type: TRI_SPECIAL_ROAD
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_dms_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_special_road"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 31. AI场景积累，特殊天气场景（雨、雪、使用雨刷器） P0
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_special_weather_scene"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 32. AI场景积累，车道线被遮挡情况 P0
    {
        trigger_type: TRI_LANE_LINE_COVERED
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_lane_line_covered"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 36. AI场景积累，动物、家禽等特殊动物出现的场景 P0
    {
        trigger_type: TRI_ANIMAL
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_animal"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 37. AI场景积累，一般障碍物 P0
    {
        trigger_type: TRI_GENERAL_OBSTACLE
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_general_obstacle"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 39. AI场景积累，微型汽车场景，例如知豆，欧拉等 P0
    {
        trigger_type: TRI_MINI_CAR
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_mini_car"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 40. AI场景积累，大型货车（车辆长度>=7m）场景，重点关注挂车等平板车辆 P0
    {
        trigger_type: TRI_LARGE_TRUCK
        trigger_priority : 1
        duration_time : 15
        video_trigger_counts : 1
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    },
                    {
                        type: "check_large_truck"
                        op: "eq"
                        value: "true"
                    },
                    {
                        type: "check_adas_opened"
                        op: "eq"
                        value: "true"
                    }
                ]
                
        }
        datas : [
            {
                begin_time : -5    # 10s前数据
                duration_time : 15  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]

#define DEFINE_TYPE_TIME(type)  uint64_t _##type##_last_time = 0

#define DEFINE_BOOL_CONDITION(type, condition)    \
            bool _##type##_last_##condition = false

#define REF_TYPE_TIME(type)   _##type##_last_time

#define REF_BOOL_CONDITION(type, condition)   _##type##_last_##condition
 

            //4  接管触发相关数据
            DEFINE_TYPE_TIME(take_over);
            DEFINE_BOOL_CONDITION(take_over, hwadataclct_overridehwaexit);
            DEFINE_BOOL_CONDITION(take_over, hwadataclct_driverbrakehwaexit);
            DEFINE_BOOL_CONDITION(take_over, hwadataclct_driversteerhwaexit);
            DEFINE_BOOL_CONDITION(take_over, accdataclct_overrideaccexit);
            DEFINE_BOOL_CONDITION(take_over, accdataclct_driverbrakeaccexit);


            //23  hmi操作触发相关数据
            DEFINE_TYPE_TIME(hmi);
            DEFINE_BOOL_CONDITION(hmi, hwa_swtreq);
            DEFINE_BOOL_CONDITION(hmi, alc_swtreq);
            DEFINE_BOOL_CONDITION(hmi, noh_swt_req);
            DEFINE_BOOL_CONDITION(hmi, noh_act_req);

            /**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include <algorithm>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
        _update_oss_address = sts_token_str[haomo::v2x::key_PREFIX].asString();
        _update_bucket_name = sts_token_str[haomo::v2x::key_BUCKET_NAME].asString();
        _update_oss_url = sts_token_str[haomo::v2x::key_END_POINT].asString();
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(dtcl, ERROR) << "Failed to init ipc node";
        return 1;
    }
   
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
     
// _ipc_node->publish("avp_rule_update","","helloworld");

// _ipc_node->publish("avp_request","","helloworld");
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size() << "  content:" << trigger_des_str;

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        // std::string oss_upload_directory_path = _update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_directory_path = _update_oss_address +get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                    MLOG(dtcl, ERROR) << " upload string size:"<< curr_task->_oss_upload_data.size()
                                      << "\n upload string max_size:"<< curr_task->_oss_upload_data.max_size();  
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", _update_bucket_name, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", _update_bucket_name, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    _ipc_node->stop();
    _ipc_node->release();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   auto fsm_substate = p_fsmdata->fsm_substate();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE && fsm_substate != FsmState::REMOTE_ARRIVED && fsm_substate != FsmState::ADS_ARRIVED)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

            //4  事故定则，接管触发场景
            REF_TYPE_TIME(take_over) = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_take_over",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vsm_dataclct_data", REF_TYPE_TIME(take_over), now);
               REF_TYPE_TIME(take_over) = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmDataclctInfoBus * p_data = dynamic_cast<haomo::hios::VsmDataclctInfoBus *>(data.get());
                   if (!p_data) {
                       continue;
                   }
                   if(p_data->hwadataclct_overridehwaexit() && REF_BOOL_CONDITION(take_over, hwadataclct_overridehwaexit) == false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(take_over, hwadataclct_overridehwaexit) = p_data->hwadataclct_overridehwaexit();

                   if(p_data->hwadataclct_driverbrakehwaexit() && REF_BOOL_CONDITION(take_over, hwadataclct_driverbrakehwaexit) ==false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(take_over, hwadataclct_driverbrakehwaexit) = p_data->hwadataclct_driverbrakehwaexit();
                                    
                   if(p_data->hwadataclct_driversteerhwaexit() && REF_BOOL_CONDITION(take_over, hwadataclct_driversteerhwaexit) == false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(take_over, hwadataclct_driversteerhwaexit) = p_data->hwadataclct_driversteerhwaexit();
                                      
                   if(p_data->accdataclct_overrideaccexit() && REF_BOOL_CONDITION(take_over, accdataclct_overrideaccexit) ==false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(take_over, accdataclct_overrideaccexit) = p_data->accdataclct_overrideaccexit();

                                                         
                   if(p_data->accdataclct_driverbrakeaccexit() && REF_BOOL_CONDITION(take_over, accdataclct_driverbrakeaccexit) ==false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(take_over, accdataclct_driverbrakeaccexit) = p_data->accdataclct_driverbrakeaccexit();

               }
               return r;
           }));

            //8.  事故定则，急刹触发场景
            _trigger_times["check_emergency_brake"] = haomo::hios::time::timestamp();
            _trigger_times["emergency_brake_start"] = 0;
            _trigger_times["emergency_brake_end"] = 0;
            ret |= _co->regist_condition("check_emergency_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_emergency_brake"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_emergency_brake"]) {
                       continue;
                   }
                   _trigger_times["check_emergency_brake"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() < -0.3) {
                       if (0 ==  _trigger_times["emergency_brake_start"]) {
                           _trigger_times["emergency_brake_start"] = _trigger_times["check_emergency_brake"];
                       } else {
                           _trigger_times["emergency_brake_end"] = _trigger_times["check_emergency_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["emergency_brake_start"] && _trigger_times["emergency_brake_end"] - _trigger_times["emergency_brake_start"] > 1000000) {
                            _trigger_times["emergency_brake_start"] = 0;
                            _trigger_times["emergency_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["emergency_brake_start"] = 0;
                       _trigger_times["emergency_brake_end"]   = 0;
                   }
               }
               return r;
           }));



            //10  事故定则，上下匝道触发场景
            _trigger_times["check_ramp"] = haomo::hios::time::timestamp();
            _last_nav_road_type = 0;
            ret |= _co->regist_condition("check_ramp",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data",_trigger_times["check_emergency_brake"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_vcan_hut_msg_bus->header().stamp() <= _trigger_times["check_ramp"]) {
                       continue;
                   }
                   _trigger_times["check_ramp"] = p_vcan_hut_msg_bus->header().stamp();
                   if (7 == p_vcan_hut_msg_bus->nav_road_type()) {
                       if (_last_nav_road_type != 7 ) {
                           _last_nav_road_type = 7;
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = 7;
                   } else {
                        if (_last_nav_road_type == 7 ) {
                           _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                           r.val_bool = true;
                           return r; 
                       }
                       _last_nav_road_type = p_vcan_hut_msg_bus->nav_road_type();
                   }
               }
               return r;
           }));

            //13.  事故定则，点刹触发场景
            _trigger_times["check_point_brake"] = haomo::hios::time::timestamp();
            _trigger_times["point_brake_start"] = 0;
            _trigger_times["point_brake_end"] = 0;
            ret |= _co->regist_condition("check_point_brake",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_point_brake"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_point_brake"]) {
                       continue;
                   }
                   _trigger_times["check_point_brake"] = p_vehicle_data->header().stamp();
                   if ( p_vehicle_data->axrefms2() > -0.1 && p_vehicle_data->axrefms2() < 0.0) {
                       if (0 ==  _trigger_times["point_brake_start"]) {
                           _trigger_times["point_brake_start"] = _trigger_times["check_point_brake"];
                       } else {
                           _trigger_times["point_brake_end"] = _trigger_times["check_point_brake"]; 
                       }
                   } else {
                       if (0 != _trigger_times["point_brake_start"] && _trigger_times["point_brake_end"] > _trigger_times["point_brake_start"] &&  _trigger_times["point_brake_end"] - _trigger_times["point_brake_start"] < 1000000) {
                            _trigger_times["point_brake_start"] = 0;
                            _trigger_times["point_brake_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["point_brake_start"] = 0;
                       _trigger_times["point_brake_end"]   = 0;
                   }
               }
               return r;
           }));


            //14.  事故定则，急加速触发场景   URGENT_ACCELERATE
            _trigger_times["check_urgent_accelerate"] = haomo::hios::time::timestamp();
            _trigger_times["urgent_accelerate_start"] = 0;
            _trigger_times["urgent_accelerate_end"] = 0;
            ret |= _co->regist_condition("check_urgent_accelerate",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data",_trigger_times["check_urgent_accelerate"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VehiInfoEvent *p_vehicle_data = dynamic_cast<haomo::hios::VehiInfoEvent *>(data.get());
                   if (!p_vehicle_data) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vehicle_data->header().stamp() <= _trigger_times["check_urgent_accelerate"]) {
                       continue;
                   }
                   _trigger_times["check_urgent_accelerate"] = p_vehicle_data->header().stamp();
                   if (p_vehicle_data->axrefms2() > 0.3) {
                       if (0 ==  _trigger_times["urgent_accelerate_start"]) {
                           _trigger_times["urgent_accelerate_start"] = _trigger_times["check_urgent_accelerate"];
                       } else {
                           _trigger_times["urgent_accelerate_end"] = _trigger_times["check_urgent_accelerate"]; 
                       }
                   } else {
                       if (0 != _trigger_times["urgent_accelerate_start"] && _trigger_times["urgent_accelerate_end"] - _trigger_times["urgent_accelerate_start"] > 1000000) {
                            _trigger_times["urgent_accelerate_start"] = 0;
                            _trigger_times["urgent_accelerate_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["urgent_accelerate_start"] = 0;
                       _trigger_times["urgent_accelerate_end"]   = 0;
                   }
               }
               return r;
           }));



            //16. 用户数据分析，ADAS功能开启触发   hmi_acc_fd1_data
            _trigger_times["check_adas_open"] = haomo::hios::time::timestamp();

            _longctrl_modsts_time = haomo::hios::time::timestamp();
            _tja_ica_moddisp_time = haomo::hios::time::timestamp();
            _noh_sts_time         = haomo::hios::time::timestamp();

            ret |= _co->regist_condition("check_adas_open",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd1_data",_longctrl_modsts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Bus *p_hmi_acc_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                   if (!p_hmi_acc_fd1_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd1_bus->header().stamp() <= _longctrl_modsts_time) {
                       continue;
                   }
                   _longctrl_modsts_time = p_hmi_acc_fd1_bus->header().stamp();
                   uint32_t longctrl_modsts = p_hmi_acc_fd1_bus->longctrl_modsts();
                   if ( (2 == _last_longctrl_modsts || 1 == _last_longctrl_modsts) && (3 == longctrl_modsts || 4 == longctrl_modsts || 5 == longctrl_modsts || 6 == longctrl_modsts)) {
                       r.val_bool = true;
                       _last_longctrl_modsts = longctrl_modsts;
                       break;
                   }
                   _last_longctrl_modsts = longctrl_modsts;
               }
               fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd2_data",_tja_ica_moddisp_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd2Bus *p_hmi_acc_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                   if (!p_hmi_acc_fd2_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd2_bus->header().stamp() <= _tja_ica_moddisp_time) {
                       continue;
                   }
                   _tja_ica_moddisp_time = p_hmi_acc_fd2_bus->header().stamp();
                   uint32_t tja_ica_moddisp = p_hmi_acc_fd2_bus->tja_ica_moddisp();
                   if ( 3 == _last_tja_ica_moddisp && 2  == tja_ica_moddisp ) {
                       r.val_bool = true;
                       _last_tja_ica_moddisp = tja_ica_moddisp;
                       break;
                   }
                   _last_tja_ica_moddisp = tja_ica_moddisp;
               }

               fetch_data = ::haomo::hios::dao::msg::history_between("vsm_hmi_data",_noh_sts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmHmiBus *p_vsm_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                   if (!p_vsm_hmi_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_vsm_hmi_bus->header().stamp() <= _noh_sts_time) {
                       continue;
                   }
                   _noh_sts_time = p_vsm_hmi_bus->header().stamp();
                   if ((0 == _last_noh_sts || 1 == _last_noh_sts) && (2 == p_vsm_hmi_bus->noh_sts() || 3 == p_vsm_hmi_bus->noh_sts())) {
                       _last_noh_sts = p_vsm_hmi_bus->noh_sts();
                       r.val_bool = true;
                       break;
                   }
                   _last_noh_sts = p_vsm_hmi_bus->noh_sts();
               }
               return r;
           }));

            //17. 用户数据分析，ADAS功能关闭触发
            _trigger_times["check_adas_close"] = haomo::hios::time::timestamp();

            _close_longctrl_modsts_time = haomo::hios::time::timestamp();
            _close_tja_ica_moddisp_time = haomo::hios::time::timestamp();
            _close_noh_sts_time         = haomo::hios::time::timestamp();

            ret |= _co->regist_condition("check_adas_close",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd1_data",_close_longctrl_modsts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd1Bus *p_hmi_acc_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                   if (!p_hmi_acc_fd1_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd1_bus->header().stamp() <= _close_longctrl_modsts_time) {
                       continue;
                   }
                   _close_longctrl_modsts_time = p_hmi_acc_fd1_bus->header().stamp();
                   uint32_t longctrl_modsts = p_hmi_acc_fd1_bus->longctrl_modsts();
                   if ( (3 == _close_last_longctrl_modsts || 4 == _close_last_longctrl_modsts || 5 == _close_last_longctrl_modsts || 6 == _close_last_longctrl_modsts) && (1 == longctrl_modsts || 2 == longctrl_modsts || 7 == longctrl_modsts)) {
                       r.val_bool = true;
                       _close_last_longctrl_modsts = longctrl_modsts;
                       break;
                   }
                   _close_last_longctrl_modsts = longctrl_modsts;
               }
               fetch_data = ::haomo::hios::dao::msg::history_between("hmi_acc_fd2_data",_close_tja_ica_moddisp_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::HmiAccFd2Bus *p_hmi_acc_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                   if (!p_hmi_acc_fd2_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_hmi_acc_fd2_bus->header().stamp() <= _close_tja_ica_moddisp_time) {
                       continue;
                   }
                   _close_tja_ica_moddisp_time = p_hmi_acc_fd2_bus->header().stamp();
                   uint32_t tja_ica_moddisp = p_hmi_acc_fd2_bus->tja_ica_moddisp();
                   if ( 2 == _close_last_tja_ica_moddisp && 2 != tja_ica_moddisp ) {
                       r.val_bool = true;
                       _close_last_tja_ica_moddisp = tja_ica_moddisp;
                       break;
                   }
                   _close_last_tja_ica_moddisp = tja_ica_moddisp;
               }

               fetch_data = ::haomo::hios::dao::msg::history_between("vsm_hmi_data",_close_noh_sts_time, now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VsmHmiBus *p_vsm_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                   if (!p_vsm_hmi_bus) {
                       continue;
                   }
                   // 时间要大于记录时间  longctrl_modsts
                   if (p_vsm_hmi_bus->header().stamp() <= _close_noh_sts_time) {
                       continue;
                   }
                   _close_noh_sts_time = p_vsm_hmi_bus->header().stamp();
                   if ((2 == _close_last_noh_sts || 3 == _close_last_noh_sts) && (0 == p_vsm_hmi_bus->noh_sts() || 1 == p_vsm_hmi_bus->noh_sts())) {
                       _close_last_noh_sts = p_vsm_hmi_bus->noh_sts();
                       r.val_bool = true;
                       break;
                   }
                   _close_last_noh_sts = p_vsm_hmi_bus->noh_sts();
               }
               return r;
           }));

            //19. 用户数据分析，变道功能取消触发   
            _trigger_times["check_change_lane_canceled"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_change_lane_canceled",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("plan_alc_decs_data",_trigger_times["check_change_lane_canceled"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::PlanAlcDecsBus *p_plan_alc_desc_bus = dynamic_cast<haomo::hios::PlanAlcDecsBus *>(data.get());
                   if (!p_plan_alc_desc_bus) {
                       continue;
                   }
                   // 时间要大于记录时间_last_plan_alc_lccancelreason
                   if (p_plan_alc_desc_bus->header().stamp() <= _trigger_times["check_change_lane_canceled"]) {
                       continue;
                   }
                   _trigger_times["check_change_lane_canceled"] = p_plan_alc_desc_bus->header().stamp();
                   if (0 == _last_plan_alc_lccancelreason && 0 != p_plan_alc_desc_bus->plan_alc_lccancelreason()) {
                       _last_plan_alc_lccancelreason = p_plan_alc_desc_bus->plan_alc_lccancelreason();
                       r.val_bool = true;
                       return r;
                   } else {
                       _last_plan_alc_lccancelreason = p_plan_alc_desc_bus->plan_alc_lccancelreason();
                   }
               }
               return r;
           }));

            //23. 用户数据分析，HMI操作触发触发
            REF_TYPE_TIME(hmi) = haomo::hios::time::timestamp();
            _trigger_times["check_hmi_operation"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_hmi_operation",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_hut_data", REF_TYPE_TIME(hmi), now);
               REF_TYPE_TIME(hmi) = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanHutMsgBus *p_vcan_hut_msg_bus = dynamic_cast<haomo::hios::VcanHutMsgBus *>(data.get());
                   if (!p_vcan_hut_msg_bus) {
                       continue;
                   }
                   if(p_vcan_hut_msg_bus->hwa_swtreq() && REF_BOOL_CONDITION(hmi, hwa_swtreq) == false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(hmi, hwa_swtreq) = p_vcan_hut_msg_bus->hwa_swtreq();

                   if(p_vcan_hut_msg_bus->alc_swtreq() && REF_BOOL_CONDITION(hmi, alc_swtreq) ==false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(hmi, alc_swtreq) = p_vcan_hut_msg_bus->alc_swtreq();
                                    
                   if(p_vcan_hut_msg_bus->noh_swt_req() && REF_BOOL_CONDITION(hmi, noh_swt_req) == false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(hmi, noh_swt_req) = p_vcan_hut_msg_bus->noh_swt_req();
                                      
                   if(p_vcan_hut_msg_bus->noh_act_req() && REF_BOOL_CONDITION(hmi, noh_act_req) ==false) {
                       r.val_bool = true;
                   }
                   REF_BOOL_CONDITION(hmi, noh_act_req) = p_vcan_hut_msg_bus->noh_act_req();

               }
               return r;
           }));

            //26.AI场景积累 相机出现上下颠簸
            _trigger_times["check_camera_bumpy"] = haomo::hios::time::timestamp();
            _trigger_times["camera_bumpy_start"] = 0;
            _trigger_times["camera_bumpy_end"] = 0;
            ret |= _co->regist_condition("check_camera_bumpy",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_camera_bumpy"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_camera_bumpy"]) {
                       continue;
                   }
                   _trigger_times["check_camera_bumpy"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["camera_bumpy_start"]) {
                           _trigger_times["camera_bumpy_start"] = _trigger_times["check_camera_bumpy"];
                       } else {
                           _trigger_times["camera_bumpy_end"] = _trigger_times["check_camera_bumpy"]; 
                       }
                   } else {
                       if (0 != _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] > _trigger_times["camera_bumpy_start"] && _trigger_times["camera_bumpy_end"] - _trigger_times["camera_bumpy_start"] < 200000) {
                            _trigger_times["camera_bumpy_start"] = 0;
                            _trigger_times["camera_bumpy_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["camera_bumpy_start"] = 0;
                       _trigger_times["camera_bumpy_end"]   = 0;
                   }
               }
               return r;
           }));

            //27.AI场景积累 道路起伏场景，道路起伏
            _trigger_times["check_road_undulation"] = haomo::hios::time::timestamp();
            _trigger_times["road_undulation_start"] = 0;
            _trigger_times["road_undulation_end"] = 0;
            ret |= _co->regist_condition("check_road_undulation",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_road_undulation"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_road_undulation"]) {
                       continue;
                   }
                   _trigger_times["check_road_undulation"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (17 <= p_vcan_dms_msg_bus->head_pitch_ang() && 21 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["road_undulation_start"]) {
                           _trigger_times["road_undulation_start"] = _trigger_times["check_road_undulation"];
                       } else {
                           _trigger_times["road_undulation_end"] = _trigger_times["check_road_undulation"]; 
                       }
                   } else {
                       if (0 != _trigger_times["road_undulation_start"] && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] > 200000 && _trigger_times["road_undulation_end"] - _trigger_times["road_undulation_start"] < 1000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["road_undulation_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["road_undulation_start"] = 0;
                       _trigger_times["road_undulation_end"]   = 0;
                   }
               }
               return r;
           }));

            //28.AI场景积累 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_fishbone_line"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_fishbone_line"]  ) {
                       continue;
                   }
                   _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            //29.AI场景积累 地面无车道线场景
            _trigger_times["check_no_lane_line"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_no_lane_line"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->header().stamp() <= _trigger_times["check_no_lane_line"]) {
                       continue;
                   }
                   _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            //30.AI场景积累 特殊道路场景（上下坡、各型路口）
            _trigger_times["check_special_road"] = haomo::hios::time::timestamp();
            _trigger_times["special_road_start"] = 0;
            _trigger_times["special_road_end"] = 0;
            ret |= _co->regist_condition("check_special_road",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("vcan_dms_data",_trigger_times["check_special_road"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanDmsMsgBus *p_vcan_dms_msg_bus = dynamic_cast<haomo::hios::VcanDmsMsgBus *>(data.get());
                   if (!p_vcan_dms_msg_bus) {
                       continue;
                   }
                   MLOG(dtcl, ERROR) << "stamp: " << p_vcan_dms_msg_bus->header().stamp();
                   // 时间要大于记录时间
                   if (p_vcan_dms_msg_bus->header().stamp() <= _trigger_times["check_special_road"]) {
                       continue;
                   }
                    _trigger_times["check_special_road"] = p_vcan_dms_msg_bus->header().stamp();
                   if (! (14 <= p_vcan_dms_msg_bus->head_pitch_ang() && 24 >= p_vcan_dms_msg_bus->head_pitch_ang())) {
                       if (0 ==  _trigger_times["special_road_start"]) {
                           _trigger_times["special_road_start"] = _trigger_times["check_special_road"];
                       } else {
                           _trigger_times["special_road_end"] = _trigger_times["check_special_road"]; 
                       }
                   } else {
                       if (0 != _trigger_times["special_road_start"] && _trigger_times["special_road_end"] - _trigger_times["special_road_start"] > 5000000) {
                            _trigger_times["road_undulation_start"] = 0;
                            _trigger_times["special_road_end"] = 0;
                            r.val_bool = true;
                            return r;
                       }
                       _trigger_times["special_road_start"] = 0;
                       _trigger_times["special_road_end"]   = 0;
                   }
               }
               return r;
           }));

            //31.AI场景积累 特殊天气场景
            _trigger_times["check_special_weather_scene"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_special_weather_scene"], now);
               _trigger_times["check_special_weather_scene"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::history_between("vcan_csa_data", _trigger_times["check_special_weather_scene"], now);
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                   }
               }
           return r;
           }));

            //32.AI场景积累 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_lane_line_covered"], now);
               _trigger_times["check_lane_line_covered"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                           }
                       }
                   }
               }
            return r;
           }));


           //36.AI场景积累 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_animal"], now);
               _trigger_times["check_animal"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                            }
                       }
                   }
               }
            return r;
           }));


           //37.AI场景积累 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_general_obstacle"], now);
               _trigger_times["check_general_obstacle"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                            }
                       }
                   }
               }
            return r;
           }));


           //39.AI场景积累 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               uint64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_mini_car"], now);
               _trigger_times["check_mini_car"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                            }
                       }
                   }
               }
            return r;
           }));
        
            //40.AI场景积累 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = haomo::hios::time::timestamp();
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               int64_t now = haomo::hios::time::timestamp();
               auto fetch_data = ::haomo::hios::dao::msg::history_between("camera_eq4_data", _trigger_times["check_large_truck"], now);
               _trigger_times["check_large_truck"] = now;
               std::reverse(fetch_data.begin(), fetch_data.end());
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }

                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                            }
                       }
                   }
               }
            return r;
           }));

            _trigger_times["check_adas_closed"] = 0;
            // 检查自动驾驶是否关闭
            ret |= _co->regist_condition("check_adas_closed",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            {
                 ConditionDefine::Value r;
                 r.is_valid = true;
                 r.val_bool = false;
                 uint64_t now = haomo::hios::time::timestamp(); 
                 auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd1_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd1Bus *p_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                     if(!p_fd1_bus || p_fd1_bus->header().stamp() + 1000000 < now ) {
                         continue;
                     }
                     auto modsts = p_fd1_bus->longctrl_modsts();
                     if (!(modsts == 3 || modsts == 4 || modsts == 5 || modsts == 6)) {
                         r.val_bool = true;
                         return r;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd2_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd2Bus *p_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                     if(!p_fd2_bus|| p_fd2_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto moddisp = p_fd2_bus->tja_ica_moddisp();
                     if (moddisp != 2) {
                         r.val_bool = true;
                         return r;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("vsm_hmi_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::VsmHmiBus *p_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                     if(!p_hmi_bus || p_hmi_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto noh_sts = p_hmi_bus->noh_sts();
                     if (!(noh_sts == 2 || noh_sts == 3)) {
                         r.val_bool = true;
                         return r;
                     }
                 }
                
                return r;
            }));

            _trigger_times["check_adas_opened"] = 0;
            // 检查自动驾驶是否开启
            ret |= _co->regist_condition("check_adas_opened",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            {
                 ConditionDefine::Value r;
                 r.is_valid = true;
                 r.val_bool = false;
                 uint64_t now = haomo::hios::time::timestamp(); 
                 auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd1_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd1Bus *p_fd1_bus = dynamic_cast<haomo::hios::HmiAccFd1Bus *>(data.get());
                     if(!p_fd1_bus || p_fd1_bus->header().stamp() + 1000000 < now ) {
                         continue;
                     }
                     auto modsts = p_fd1_bus->longctrl_modsts();
                     if ((modsts == 3 || modsts == 4 || modsts == 5 || modsts == 6)) {
                         r.val_bool = true;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("hmi_acc_fd2_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::HmiAccFd2Bus *p_fd2_bus = dynamic_cast<haomo::hios::HmiAccFd2Bus *>(data.get());
                     if(!p_fd2_bus|| p_fd2_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto moddisp = p_fd2_bus->tja_ica_moddisp();
                     if (moddisp == 2) {
                         r.val_bool = true;
                     }
                 }
                 fetch_data = ::haomo::hios::dao::msg::latest("vsm_hmi_data");
                 std::reverse(fetch_data.begin(), fetch_data.end());
                 for (auto &data : fetch_data)
                 {
                     haomo::hios::VsmHmiBus *p_hmi_bus = dynamic_cast<haomo::hios::VsmHmiBus *>(data.get());
                     if(!p_hmi_bus || p_hmi_bus->header().stamp() + 1000000 < now) {
                         continue;
                     }
                     auto noh_sts = p_hmi_bus->noh_sts();
                     if ((noh_sts == 2 || noh_sts == 3)) {
                         r.val_bool = true;
                     }
                 }
                return r;
            }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo

19. 上午修改8号车配置文件，采集点云原始数据
    下午编写规则

21: 上午合并代码
    下午语音打标签

22: jdc  长城数据中心
    jdc -> 网关(葛天昊) -> 下发给车端   (触发规则文件， 回传规则文件，shader文件)
    oss -> 
    ota更新

    底软版本  /etc/pos

    ImplWebSocket : public V2XBase

