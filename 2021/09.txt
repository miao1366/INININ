01. 上午会议+bvar
    下午小车出产出， 测试语音标签

02. 
    下午语音标签落盘bag开发。

03. 上午到奥北，了解和熟悉数据回传
    ssh caimiaomiao@192.168.100.66    caimiaomiao

06. 上午写ppt
    下午写ppt, ICU1.5数据回传会议
    气囊信号没有给出，需求无法实现
    Aeblf 来在vsomeip服务
    AEB
    FCTB    MCU
    关系都是或的关系
    ModDisp
    行驶域
    泊车域
    ACC
    HWA
    TJA
    NOH
    9.30 气囊解决。 

07. 检查现有rule
    新增rule
    cond_float bug排查。
    sudo echo -n dycar004 > /etc/.carid
    sudo echo -n 5U74iC6UnfSHUl6zV7wIsaCI2k1zZzQkClq133biwiXFGeXzY9tn8DjXeOrLnYvC > /etc/.login_code
    HWA  高速公路辅助驾驶
    ACC  的英文全称是“Adaptive Cruise Control”，中文意思是“自适应巡航控制”
    ADAS 作为实现无人驾驶的过渡阶段，高级驾驶员辅助系统（Advanced Driver Assistance System）近年来备受关注
    AEB  是一种汽车主动安全技术，主要由3大模块构成，包括控制模块（ECU），测距模块，和制动模块。其中测距模块的核心包括微波雷达、人脸识别技术和视频系统等，它可以提供前方道路安全、准确、实时的图像和路况信息
    failfast(快速故障)
    failsafe(故障安全)
    failover(故障切换)
    failback(故障恢复)
    ELK 紧急车道保持
        如果看过这个功能的演示，你会希望所有车都能把它装上，因为马路上太多驾驶员开车时不能保持在自己的车道里，有时候甚至长期霸占双车道行驶，
        给会车和超越的车辆制造麻烦。这套ELK紧急车道保持功能也是国内首推，在60-140km/h时速下，当驾驶员无意识偏离车道时，提前为驾驶员提供方向盘转向控制；
        若纠偏失败，系统会触发报警以提醒驾驶员校正行驶方向。我们也可以把这套系统理解为“紧急纠偏”功能，那些胡乱变道的驾驶员不管是对自己还是对其他车辆都是个危险的存在，
        “紧急纠偏”功能多少可以教会他们应该如何开车

9111  0106  MA01  P1RE  3Y

    自动驾驶    人驾驶

08. 上午调试13号车。  下午看sim_ds common 代码。
    下午测试label 编写规则
    2. 事故定责，AEB功能激活触发的数据 P00 

10.
    sudo echo -n dycar005 > /etc/.carid
    sudo echo -n xALgpvJPARTUDaFlYSvfJUFNFJe2ldezcFbnWv9LTIroGUw6GQWxpcMN9bkwg5Q3 > /etc/.login_code 
    没有这个信号方向盘接管ACC功能退出（VsmIf.VSM_DATACLCT_INFO_BUS.ACCDataClct_DriverSteerHWAExit）

todo
破损道路
(LA_Prediction_Reason[0] != false && LH_Prediction_Reason[0]  != false) && (LH_ConFidence<0.3 ||  LA_Confidence<0.3
确认LA_Prediction_Reason是数组还是第一位

23 破损道路需要确认信号，车道线不能给出正确的信号。

24 破损道路， 相机出现上下颠簸信号不确认

33 新旧车道线  紫色 需求待确认

34 禁停网络线

35 一般障碍物

40 大型货车 EQ4_OBJ_ELEM_BUS:OBJ_Object_Class 待确认

41 怎么的测试方法才能满足测试场景 需要咨询振南 
   若冰 
   mobieye可能没有需要的数据。

研发debug
    9.13前 故障触发 代码完初版需求，回传内容无视频数据
AI算法
   9.10-9月15日实车测试，完成所有需求 实车测试后开始提测，回传内容无视频数据.

13. 上午到公司

18. MsgNode
qq  qq  
    qwertyuiop33   2731807785
    miao1029081208

22. https://hentaidude.com/kininaru-kimochi-episode-2/
   https://hentaidude.com/taboo-charming-mother-episode-4/

23. 
工作一:
    硬盘检查。检查寄给闪立方的硬盘是否有io error.
工作二:
    采集车采集软件产出部署;新产出时产出验证;特定采集版本输出(如场景库)。
工作三:
    采集车采集临时问题解决. 如(产出误删，显示器不显示，log上传失败，采集传感器频率异常)。
工作四:
    采集标签落盘功能开发。
工作五:
    采集数据内容合规开发。
工作六:
    数据回传配置文件编写，后期会参与开发。
工作七:
    采集软件qt ui界面开发。


hios dpub -t haomo.hios.AebIphutInfoBus -n aeb_iphut_data -f aeb.prototxt -h 5 &> /dev/null &

name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]

26.     182.92.89.135   haomo    haomo
        sudo docker run -it --privileged=true --shm-size=4g --net=host -v /home/haomo/cmm:/home  --name pcb a8d3c83513f9
        message LidarScanPb
    {   
         message packet{
        bytes packetdata=1;
    }
    haomo.hios.Header header       = 1;
    uint64 sys_time_us             = 2; 
    uint32 seq                     = 3;
    repeated packet packets        = 4;
    }

27. sudo echo -n HP-30-V71-AC-002
    sudo echo -n HP-30-V71-AC-P7C024
 

28. develop_icu1_5_branch补充自驾和人驾模式

    name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]

Me failSafe                        FS_rain
鱼骨线场景                           LH_Lanemark_Type
地面无车道线场景                      LA_Prediction_Reason
动物、家禽等特殊动物出现的场景          OBJ_Object_Class
一般障碍物                           OBJ_Object_Class

昨天工作:

今天工作行程。
09:30 - 12:00   编写数据回传规则文件
12:30 -  14:30  15号车  18号车调试，读取不了mcu数据

/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));

        // 急刹触发条件
        _trigger_times["check_emergency_braking"] = 0;
        ret |= _co->regist_condition("check_emergency_braking",
                                        std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        {
            ConditionDefine::Value r;
            r.is_valid = true;
            r.val_bool = false;
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 1 * 1000 * 1000; // 1-second-ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("vehicle_data", pre, now);
            if (fetch_data.empty())
            {
                MLOG(dtcl, INFO) << "no vehicle data fetched in check_emergency_braking";
                r.val_bool = false;
                return r;
            }
            r.val_bool = true;
            for (auto &data : fetch_data)
            {
                VehicleData *p_vehicle_data = dynamic_cast<VehicleData *>(data.get());
                if (NULL == p_vehicle_data) {
                    continue;
                }
                float axrefms2 = p_vehicle_data->axrefms2();
                if (!(axrefms2 > 0.3)) {
                    MLOG(dtcl, INFO) << "check emergency braking failed";
                    r.val_bool = false;
                    break;
                }
            }
            return r;
        }));

        // 无车道线触发条件
        _trigger_times["check_no_lane_line"] = 0;
        ret |= _co->regist_condition("check_no_lane_line",
                                        std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
        [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
        {
            ConditionDefine::Value r;
            r.is_valid = true;
            r.val_bool = false;
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 1 * 1000 * 1000; // 1-second-ago
            auto fetch_data = ::haomo::hios::dao::msg::latest("vehicle_data");
            if (fetch_data.empty())
            {
                MLOG(dtcl, INFO) << "no vehicle data fetched in check_emergency_braking";
                r.val_bool = false;
                return r;
            }
            r.val_bool = true;
            for (auto &data : fetch_data)
            {
                VehicleData *p_vehicle_data = dynamic_cast<VehicleData *>(data.get());
                if (NULL == p_vehicle_data) {
                    continue;
                }
                float axrefms2 = p_vehicle_data->axrefms2();
                if (!(axrefms2 > 0.3)) {
                    MLOG(dtcl, INFO) << "check emergency braking failed";
                    r.val_bool = false;
                    break;
                }
            }
            return r;
        }));




            return ret;
        }
    } // namespace data_collect
} // namespace haomo

name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_float"   # "cond_float"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_float"   # "cond_float"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "LaneChngCfmSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "4"
                }
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "VoiceBrdcSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "UsrManSts"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "AutoSpdSetSwt"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "LaneChngCfmSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "4"
                }
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "VoiceBrdcSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "UsrManSts"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "AutoSpdSetSwt"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]




name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
        # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]


/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));
            
            // 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (size_t i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (UNDECIDED == (int)lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->head().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       for (size_t i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (UNDECIDED == (int)lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->head().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            // 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false
                       for (size_t i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (size_t i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->head().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            // 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->().eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (FS_99 == fs_rain || FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->head().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_msg_bus->head().stamp() - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->head().stamp();
                       return r;
                   }
               }
           }
           return r;
           }));

            // 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (size_t i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->head().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (size_t i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->head().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            }
            return r;
           }));


           // 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_Lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->Lanes_objects();
                       for (size_t i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->head().stamp();
                                return r;
                            }
                       }
                   }
               }
            }
            return r;
           }));


           // 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_Lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->Lanes_objects();
                       for (size_t i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->head().stamp();
                                return r;
                            }
                       }
                   }
               }
            }
            return r;
           }));


           // 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_Lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->Lanes_objects();
                       for (size_t i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (CAR == object.object_class() && 1.2 < object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->head().stamp();
                                return r;
                            }
                       }
                   }
               }
            }
            return r;
           }));
        
            // 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->head().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_Lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->Lanes_objects();
                       for (size_t i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (TRUCK == object.object_class() && 7.0 < object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->head().stamp();
                                return r;
                            }
                       }
                   }
               }
            }
            return r;
           }));
        
        
        return ret;
        }
    } // namespace data_collect
} // namespace haomo



name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
        # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]


30.
/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));
            
            // 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            // 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            // 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (FS_99 == fs_rain || FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_msg_bus->header().stamp() - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            // 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           // 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (CAR == object.object_class() && 1.2 < object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            // 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (TRUCK == object.object_class() && 7.0 < object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo


30.
/**************************************************************************
*
* Copyright (c) 2020 HaoMo.com, Inc. All Rights Reserved
*
**************************************************************************/
/*
 * @Description: implementation of data_collect_exec.h
 * @Author: zhumingming
 * @Date: 2020-09-24 19:35:59
 * @LastEditors: zhumingming
 * @LastEditTime: 2021-04-21 15:02:22
 */
#include <malloc.h>
#include "data_collect_exec.h"

using haomo::comm_condition::CommCombinedCondition;
using haomo::comm_condition::Condition;
using haomo::comm_condition::Condition_Operator;
using ::haomo::comm_condition::ConditionDefine;
using ::haomo::hidelivery::DiagnosisData;
using ::haomo::hidelivery::VehicleSpeedData;
using ::haomo::hidelivery::fsm::FsmOutput;
using ::haomo::hidelivery::fsm::FsmState;

using ::haomo::hios::IData;


namespace haomo{
namespace data_collect{
REGISTER_EXECUTER(DataCollectExec)

DataCollectExec::DataCollectExec(const std::string& name, const std::string& type):
    ::haomo::hios::InitiativeExec(name, type), _co(std::make_shared<haomo::comm_condition::Condition_Operator>())
    {}

int DataCollectExec::init(const std::string& config_dir){
    MLOG(dtcl, INFO) << "data_collect init begin";
    haomo::hios::Module::get_instance()->regist("dtcl");  // register log to framework
    _thread_count = 1;
    _co->init();  // init condition operation
    regist_condition();  // regist condition

    // 解析规则文件
    _curr_dir = config_dir;
    std::string _config_path = config_dir + "/data_collect/config/";
    const std::string cfg_filename = _config_path + "data_collect_config.prototxt";
    bool r = ::haomo::hios::read_proto_from_text_file(cfg_filename.c_str(), &_config);
    if (!r) {
        MLOG(dtcl, ERROR) << "fail to read data_collect config file: " << cfg_filename;
        return -1;
    }
    MLOG(dtcl, DEBUG) << "cfg: " << _config.ShortDebugString();
    _update_rule_address = _config.update_rule_address();
    _max_upload_size = _config.max_upload_size() * 1000;  // convert KB to B
    _max_cache_size = _config.max_cache_size() * 1000 * 1000;  // convert MB to B
    auto size = _config.ignore_topics_size();
    for(int i = 0; i < size; ++i){
        _custom_ignore_topics.push_back(_config.ignore_topics(i));
    }
    for (auto &cfg : _config.local_rule_cfgs())  // 解析各个文件，读取rule
    {
        MLOG(dtcl, INFO) << "read rule file: " << cfg;
        DataCollectRuleConfig rule;
        #ifdef __HIDELIVRY__
        const std::string rule_file = _config_path + cfg + ".prototxt";
        #else
        const std::string rule_file = _config_path + cfg + "_icu1_5.prototxt";
        #endif

        r = ::haomo::hios::read_proto_from_text_file(rule_file.c_str(), &rule);  // 此处取出规则组中的规则
        if (!r) {
            MLOG(dtcl, ERROR) << "fail to read rule cfg file : " << rule_file;
            continue;
        }
        try {
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
            if(rule.name() == TRIGGER_RULE_NAME){
                _has_trigger_rule = true;
                MLOG(dtcl, INFO) << "add trigger rule";
            }
            ++_thread_count;
        } catch (const std::string &e) {
            MLOG(dtcl, ERROR) << "E_DATA_COLLECT_INVALID_CFG" << "|" << e;
        }
    }
    for (auto &it : _rules) {
        MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_string() << "\n----\n";
        // MLOG(dtcl, INFO) << "rule: " << it.first << ":" << it.second->to_short_string();
    }

    // sub to cloud topics
    using namespace std::placeholders;
    _v2x_control = std::make_shared<haomo::v2x::V2X>(_update_rule_address);
    _v2x_control->sub("update_rule", std::bind(&DataCollectExec::sub_update_rule, this, _1, _2));
    _v2x_collector = std::make_shared<haomo::v2x::V2X>(_collector_address);

    // thread pool
    _thread_count = _thread_count > 4 ? 4 : _thread_count;  // max thread count is 4
    _threadpool_rule = std::make_unique<threadpool>(_rule_pool_name, 2);  // !!因为monitor过于耗时，因此这里使用两个线程,过多会浪费
    _threadpool_data = std::make_unique<threadpool>(_data_pool_name, 4);
	_threadpool_oss = std::make_unique<threadpool>(_oss_pool_name, 5);
    if(_has_trigger_rule){
        MLOG(dtcl, INFO) << "create data cache thread";
        _cache_thread = std::thread(&DataCollectExec::fetch_data_to_cache, this);
    }

    MLOG(dtcl, INFO) << "data_collect init end";

    std::this_thread::sleep_for(std::chrono::milliseconds(10000));

    Json::Value sts_token_str = _v2x_collector->get_sts_information();
    //TODO 判断是否收到sts
    if(sts_token_str){
        OssOperate::GetInstance().initStsToken(sts_token_str);
    }
    else{
        MLOG(dtcl, ERROR) << "oss get sts information error";
    }

    //区分获取STS的方法
    if (!_config.oss_sts_request())
    {
        OssOperate::GetInstance().releaseOss();
        Json::Value token_str;
        token_str[haomo::v2x::key_ACCESS_KEYID] = _config.oss_key_id();
        token_str[haomo::v2x::key_ACCESS_SECRET] = _config.oss_key_secret();
        OssOperate::GetInstance().initNormalToken(token_str);
    }

    _car_id = get_carid();

    // IPC通讯相关

    _ipc_node = new haomo::hios::MsgNode();
    if (_ipc_node == nullptr) {
        MLOG(dtcl, ERROR) << "Failed to create ipc node";
        return 1;
    }
    if (0 != _ipc_node->init("lo",6855)) {
        MLOG(IPC_DS, ERROR) << "Failed to init ipc node";
        return 1;
    }
    // _ipc_node->publish("avp_rule_update","","helloworld");
    // _ipc_node->subscribe("avp_request",std::bind(&DataCollectExec::sub_avp_message,this,std::placeholders::_1,std::placeholders::_2));

    _ipc_node->subscribe("avp_request",[&](const haomo::hios::MsgHeader& header, const std::string &content) -> bool {
         MLOG(dtcl, ERROR) << "receive content message" << content;
         return true;
    });
    
    return 0;
}


std::string DataCollectExec::pack_data(const std::string &data_name, const std::string &data){
    union 
    { 
        uint32_t block_size_uint32_t; 
        char block_size_char[4]; 
    };
    union 
    { 
        uint64_t time_stamp_uint64_t; 
        char time_stamp_char[8]; 
    };
    union 
    { 
        uint16_t data_name_len_uint16_t; 
        char data_name_len_char[2]; 
    };

    time_stamp_uint64_t = haomo::hios::time::timestamp(); 
    data_name_len_uint16_t = data_name.size();
    std::ostringstream oss; 
    block_size_uint32_t = data_name_len_uint16_t + data.size() + 14;
    write_stream(oss, block_size_char, 4);
    write_stream(oss, time_stamp_char, 8);
    write_stream(oss, data_name_len_char, 2);
    oss << data_name << data;  

    return oss.str();
}

std::string DataCollectExec::get_carid(){
    std::string carid;
    ::haomo::hios::param_server::query<std::string>(FLAGS_carid, carid);
    if(carid.empty()){
        std::ifstream file("/etc/.carid");
        if(file.is_open()){
            std::getline(file, carid);
        }
        else{
            MLOG(INIT, ERROR) << "fail to open /etc/.carid";
        }
        file.close();
    }
    if(carid.empty()){
        MLOG(v2x, ERROR) << "fail to get correct carid!";
    }
    return carid;
}

std::string DataCollectExec::get_date_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(1900+ltm->tm_year) + '_';
    date_time +=  std::to_string(1 + ltm->tm_mon) + '_';
    date_time +=  std::to_string(ltm->tm_mday);
    return date_time;
}

std::string DataCollectExec::get_hour_time(){
    std::string date_time;
    // 基于当前系统的当前日期/时间
    time_t now = time(0);
    tm *ltm = localtime(&now);
    // 输出 tm 结构的各个组成部分
    date_time +=  std::to_string(ltm->tm_hour) + ':';
    date_time +=  std::to_string(ltm->tm_min) + ':';
    date_time +=  std::to_string(ltm->tm_sec);
    return date_time;
}

bool DataCollectExec::write_file(std::string directory, std::string file_path, std::string &file_content)
{
    try
    {
        std::string temp;
        size_t length = directory.length();
        size_t pos = 0;
        while (pos < length) {
            pos = directory.find("/", pos);
            if (pos == std::string::npos) {
                pos = length - 1;
            }
            temp = std::string (directory, 0, pos + 1);
            if (access(temp.c_str(), 0) != 0) {
                if (mkdir(temp.c_str(), S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH | S_IWOTH) != 0) {
                    MLOG(dtcl, ERROR) << "mkdir " << temp.c_str() << " error: " << strerror(errno);
                    return false;
                }
            }
            pos = pos + 1;
        }
        std::ofstream outfile;
        outfile.open(file_path, std::ios::out | std::ios::trunc);
        outfile << file_content;
        outfile.close();
    }
    catch (const std::exception &error)
    {
        MLOG(dtcl, ERROR) << "catch runtime error when write file: " << error.what();
        return false;
    }
    return true;
}

bool DataCollectExec::write_stream(std::ostringstream &stream, char content[], int size)
{
    for(int index = 0; index < size ; index++){
        stream<<content[index];
    }
    return true;
}

int DataCollectExec::process(const haomo::hios::IData *const input, haomo::hios::IData *const output){
// 获取protofile_des pb结构体数据
// proto_file_des  haomo.hios.ProtoFileDes
// haomo::hios::ProtoFileDes proto_des =  _v2x_collector->get_proto_file_des();
// for (int i = 0; i < proto_des.data_size(); ++i)
// {
//     MLOG(dtcl, ERROR) << "[_PROTO_DES] "<< proto_des.data(i).name() << "  " << proto_des.data(i).type();
// }

// 创建bucket，上传内存数据
            
// std::string test = "helloworld";

// 实现数据打包，，开启线程池进行数据的上传
            
// OssOperate::GetInstance().uploadMemory(false,haomo::v2x::key_BUCKET_NAME,"test_renxin",test);

// 创建bucket，上传文件
            
// OssOperate::GetInstance().uploadFile(false,haomo::v2x::key_BUCKET_NAME,"test_renxin2","/home/ubuntu/haomo/test_cpp/a.out");
            
//  直接内存上传文件
// std::string upload_str = "hellorenxin,upadload 20210720";
// _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/"+_car_id+"_trigger_"+std::to_string(curr_task->_task_id)+"_"+get_hour_time()+"_v1.0.data", upload_str, std::ref(_v2x_collector)));

/* upload file test
static int file_index = 0;
file_index++;

if( file_index%100 == 0)
{

std::string oss_upload_directory_path = "test/icu1.5/"+_car_id+"/"+get_date_time()+"/haomo/";
std::string oss_upload_file =oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(1)+"_"+std::to_string(haomo::hios::time::timestamp())+"_v1.0.data";

std::string local_upload_directory_path = "/tmp/" + oss_upload_directory_path;
std::string local_upload_file = "/tmp/" + oss_upload_file;

std::string str = "hello, world!";
//进行序列化操作
haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();

std::string proto_des_str;
std::string proto_des_ss;
proto_des.SerializeToString(&proto_des_str);
std::string upload_str = pack_data("_proto_file_des",proto_des_str);

TriggerDesData _trigger_des;
_trigger_des.set_is_lower_task(true);
_trigger_des.SerializeToString(&proto_des_str);
upload_str += pack_data("trigger_des",proto_des_str);

// std::string upload_str = pack_data("proto_file_des",proto_des_str);
            
auto cu_task = _tasks.begin();
if(write_file(local_upload_directory_path, local_upload_file, upload_str))
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME,    oss_upload_file, local_upload_file , std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
else
{
    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, upload_str, std::ref(_v2x_collector), 
                    std::ref(_tasks), std::ref(cu_task)));
}
}
*/
    uint64_t t1 = haomo::hios::time::timestamp();
    update_rules();  // 对云端下发的规则进行更新
    update_all_topic();  // 对当前的总数据topic列表做更新
    // 1. 更新最大集缓存数据, 单独线程fetch_data_to_cache
    uint64_t t2 = haomo::hios::time::timestamp();

    // 2.遍历规则,进行collector的条件触发、monitor的周期上传等工作
    _co->refresh_condition(); // 更新条件判断的依据数据,以免用旧数据做判断
    for (auto &it : _rules)
    {
        if (TRIGGER_RULE_NAME == it.first)// 触发任务不使用线程池
        {
            // MLOG(dtcl, ERROR) << " exec task address" <<std::addressof(_tasks);
            it.second->process(_curr_dir, _tasks, _collector_cache, _all_topics); // 避免多线程操作_task，不使用线程池
        }
        else
        {
            if (!(it.second->_is_process))// 周期任务与监控任务使用线程池
            {
                _threadpool_rule->commit(std::bind(&DataCollectRule::process, it.second.get(), _curr_dir, std::ref(_tasks), std::ref(_collector_cache), _all_topics));
            }
        }
    }
    uint64_t t3 = haomo::hios::time::timestamp();

    if (!_has_trigger_rule){
        MLOG(dtcl, INFO) << "no trigger rule, ignore task and erase data";
    }
    // 3. 进行触发数据的上传,从task队列中取出task并进行数据上传，同时更新task中的数据时间
    MLOG(dtcl, DEBUG) << "current task size: " << _tasks.size() << ", task size:" << &_tasks;

    OssOperate::GetInstance().judgeStsInformation(_v2x_collector);

    typedef std::map<std::string, std::vector<std::string>> map_oss;
    map_oss oss_map;
    ::haomo::hios::param_server::query<map_oss>(oss_upload_file_table, oss_map);
    if(oss_map.size()!=0){
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);
        if(_v2x_collector->pub("_proto_file_des", proto_des_str, haomo::v2x::FrameType::PROTOBUF))
        {
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  begin";  
            auto iter = oss_map.begin();
            MLOG(dtcl, ERROR) << "oss_upload_data re_upload_file: "<< iter->first;    
            vector<std::string> oss_file_parameter = iter->second;
            _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), oss_file_parameter[0],  oss_file_parameter[1],  oss_file_parameter[2],  oss_file_parameter[3], std::ref(_v2x_collector)));     
            iter = oss_map.erase(iter);
            if (!::haomo::hios::param_server::save<map_oss>("oss_upload_file", oss_map)) {
                MLOG(INIT, ERROR) << "save oss_file to param server failed ";
                return false;
            }
            MLOG(dtcl, ERROR) << "[oss_upload_data re_upload_file]  end";  
        }
    }

    int parallel_size = 0;

    // TODO: DELETE
    while ( _tasks.size() != 0 && parallel_size++ <5){
        auto curr_task = _tasks.begin();
        if(curr_task->_is_finished == false){
            return 0;
        }
        MLOG(dtcl, ERROR) << "process task: " << curr_task->_task_id << " task address " << std::addressof(*curr_task);
        uint64_t total_size = 0;
        bool is_upload_finish = false;
        auto &task_datades = curr_task->_datades;
        auto &topic_count = curr_task->_datacount;
        //进行序列化操作
        haomo::hios::ProtoFileDes proto_des = _v2x_collector->get_proto_file_des();
        std::string proto_des_str;
        proto_des.SerializeToString(&proto_des_str);

        std::string trigger_des_str;
        curr_task->_trigger_des.SerializeToString(&trigger_des_str);

        curr_task->_oss_upload_data = pack_data("_proto_file_des", proto_des_str);
        MLOG(dtcl, ERROR) << "_proto_file_des  "<< proto_des_str.size();
        curr_task->_oss_upload_data += pack_data("trigger_des", trigger_des_str);
        MLOG(dtcl, ERROR) << "trigger_des_str  "<< trigger_des_str.size();

        // 对当前task中的每一个topic，上传task描述中所需区间的数据
        for (auto iter = task_datades.begin(); iter != task_datades.end();){
            std::string topic = iter->first;
            TaskDataDes &data = iter->second;
            std::list<CacheDataItem>::iterator begin, end;
            MLOG(dtcl, ERROR) << "fetch task data: " << topic << ",begin:" << data._begin_time / 1000000 << "end: " << data._end_time / 1000000;{
                std::lock_guard<std::mutex> lock(_cache_mutex); // lock process with _collector_cache
                CacheData &cache = _collector_cache[topic];     // 获取当前topic的缓存
                // 获取当前缓存中，所需区间数据的起止位置
                int res = cache.find_iterator_with_range(data._begin_time, data._end_time, begin, end);
                if (res != RANGE_SUCCESS){
                    MLOG(dtcl, ERROR) << topic << " do no exist in cache of " << data._begin_time << "-" << data._end_time;
                    if (data._end_time != MAX_TIMESTAMP && res == RANGE_DISCARD)
                    { // 对于MAX_TIMESTAMP，不可以删除当前的采集topic
                        MLOG(dtcl, WARNING) << topic << " has no data and will be discarded from task: " << curr_task->_task_id;
                        iter = task_datades.erase(iter);
                        cache.erase_time_piece(data._begin_time, data._end_time);
                    }
                    else{
                        ++iter;
                    }
                    continue;
                }

                // 遍历begin和end之间的cache数据并且上传
                MLOG(dtcl, ERROR) << "fetch cache range: " << topic << " begin:" << begin->_time / 1000000 << "end: " << end->_time / 1000000;
                MLOG(dtcl, ERROR) << "before pub data: " << topic << ",task begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
                        
                std::list<CacheDataItem>::iterator curr = begin; // 保存begin位置，用于删除数据

                //  TODO 添加trigger_des的PB数据内容
                for (; curr->_time <= end->_time && curr != cache._datas.end();){
                    // if pub fail, iter will not increase but total_size will increase to keep loop go on
                    // 区分触发回传，如果是触发回传，那么数据需要保留下来

                    //判断任务优先级小于6.那么使用OSS进行上传
                    if(curr_task->_priority < 6){
                        // TODO 此处需要进行打包操作
                        curr_task->_oss_upload_data +=  pack_data(topic, curr->_data); 
                        MLOG(dtcl, ERROR) << topic << "  "<< curr->_data.size(); 
                        ++curr;                          
                    }
                    else{
                        bool res = _v2x_collector->pub(topic, curr->_data, haomo::v2x::FrameType::PROTOBUF);
                        if (!res){
                            MLOG(dtcl, ERROR) << "pub data: " << topic << " fail";
                        }
                        else{
                            MLOG(dtcl, DEBUG) << "pub data: " << topic << " success: " << curr->_time;
                        }
                    }

                    total_size += curr->_data.size();
                    if (total_size >= _max_upload_size){
                        is_upload_finish = true;
                        if (res){
                            ++curr; // increase iter only if pub success
                            ++topic_count[topic];
                        }
                        break;
                    }
                    if (res){
                        ++curr; // increase iter only if pub success
                        ++topic_count[topic];
                    }
                }
                cache.erase_data(begin, curr); // erase pubed data [begin, curr), already ++curr after pub success
                if (curr == cache._datas.end()){
                    MLOG(dtcl, INFO) << "pub data: " << topic << " reach cache end";
                }
                if (curr != begin){
                    --curr; // 自减操作，确保curr指向最后的取用位置, 并且不能是begin，否则--之后无指向
                }
                data._begin_time = curr->_time;
                cache.erase_time_piece(begin->_time, curr->_time); // 清除time_piece中已经发送的时间范围
                MLOG(dtcl, INFO) << "after pub data: " << topic << ",begin: " << data._begin_time / 1000000
                                 << ",task end: " << data._end_time / 1000000 << ", cache size: " << cache._datas.size();
            }

            // 如果task中data已经取完并上传，从task中删除这个数据条目
            if (data._end_time != MAX_TIMESTAMP && data._begin_time >= data._end_time){
                MLOG(dtcl, WARNING) << "task of topic: " << topic << " finished";
                iter = task_datades.erase(iter);
            }
            else{
                ++iter;
            }

            if (is_upload_finish){
                MLOG(dtcl, INFO) << topic << " upload reach max_upload_size: " << _max_upload_size << " < " << total_size;
                break;
            }
        }

       // 低优先级任务在此处释放，高优先级在线程池里释放
        std::string oss_upload_directory_path = update_oss_address +_car_id+"/"+get_date_time()+"/haomo/";
        std::string oss_upload_file = oss_upload_directory_path +_car_id+"_trigger_"+std::to_string(curr_task->_task_id) + "_" + std::to_string(curr_task->_task_begin_time)+"_v1.0.data";

        std::string local_upload_directory_path = local_oss_address + oss_upload_directory_path;
        std::string local_upload_file = local_oss_address + oss_upload_file;

        // 高优先级在线程池里上传，删除文件，并进行释放task
        // 低优先级在此处释放 
        if(curr_task->_priority < 6){
                if(write_file(local_upload_directory_path, local_upload_file, curr_task->_oss_upload_data)){
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadFile, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, local_upload_file , std::ref(_v2x_collector)));
                    MLOG(dtcl, ERROR) << "oss_upload_data total size is: "<< curr_task->_oss_upload_data.size();    
                }
                else{
                    _threadpool_oss->commit(std::bind(&OssOperate::uploadMemory, &(OssOperate::GetInstance()), "sts", haomo::v2x::key_BUCKET_NAME, oss_upload_file, curr_task->_oss_upload_data, std::ref(_v2x_collector)));
                }
                MLOG(dtcl, ERROR) << " task " << curr_task->_task_id << " has been finished ";
                MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
                // curr_task->statistic_task();
        }
        else{
            MLOG(dtcl, WARNING) << "finish task process: " << curr_task->_task_id;
            curr_task->_is_finished = true;
            MLOG(dtcl, WARNING) << "malloc_trim after task " << curr_task->_task_id << " finish";
            MLOG(dtcl, WARNING) << "destroy current task: "<< curr_task->_task_id;
            // curr_task->statistic_task();
            #ifdef __LINUX__
            malloc_trim(0); // 释放当前的heap内存
            #endif
        }
        try{
            _tasks.erase(curr_task);
        }
        catch (const std::exception& e) {
            MLOG(guard, ERROR) << "exception: " << e.what() ;
        }
    }

    uint64_t t4 = haomo::hios::time::timestamp();
    // 4. 删除20s前的数据未被标注的数据
    uint64_t now = haomo::hios::time::timestamp();
    uint64_t history = now - _history_data_time;
    {
        std::lock_guard<std::mutex> lock(_cache_mutex);
        for (auto &cache : _collector_cache){
            std::list<CacheDataItem> &datas = cache.second._datas;
            const std::string &topic = cache.first;
            MLOG(dtcl, INFO) << "before erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
            if (datas.empty()){
                continue;
            }
            std::list<CacheDataItem>::iterator pos = datas.begin();
            for (; pos->_time < history && pos != datas.end();){ // 数据位于10s前
                MLOG(dtcl, DEBUG) << "erase: " << topic << "data_time: " << pos->_time << ",history:" << history;
                if (!cache.second.is_in_time_piece(pos->_time)){
                    // datas.erase(pos++);
                    cache.second.erase_data(pos++);
                    cache.second._times.erase(pos->_time);
                    continue;
                }
                ++pos;
            }
            MLOG(dtcl, INFO) << "after erase data: " << topic << ",contains " << datas.size() << ",begin:" << datas.front()._time / 1000000 << ",end:" << datas.back()._time / 1000000;
        }
    }

    uint64_t t5 = haomo::hios::time::timestamp();
    MLOG(dtcl, DEBUG) << "process time statistic: "
                      << "fetch: " << (t2 - t1) / 1000 << "ms,"
                      << "trigger: " << (t3 - t2) / 1000 << "ms,"
                      << "task: " << (t4 - t3) / 1000 << "ms,"
                      << "erase: " << (t5 - t4) / 1000 << "ms,"
                      << "total: " << (t5 - t1) / 1000 << "ms";
    return 0;
}

int DataCollectExec::release(){
    MLOG(dtcl, ERROR) << "data_collect_exec release";
    _rules.clear();
    _is_end = true;
    if (_cache_thread.joinable()){
        _cache_thread.join();
    }
    _threadpool_rule.reset();
    _threadpool_data.reset();
    _threadpool_oss.reset();
    OssOperate::GetInstance().releaseOss();
    delete _ipc_node;
    MLOG(dtcl, ERROR) << "data_collect_exec release end";
    return 0;
}

void DataCollectExec::solve_json_rule(Json::Value &task, DataCollectRuleConfig &rule_config_data){
    MLOG(dtcl, ERROR) << "solve_json_rule data_collect HAOMO update rule: "<< task;
    auto rule_config_item_data = rule_config_data.add_rules();
    rule_config_data.set_name(task["triggerGroup"].asString());
    std::string str_data = task["trigger_type"].asString();
    // rule_config_item_data->set_trigger_type(str_data);
    str_data = task["trigger_subtype"].asString();
    // rule_config_item_data->set_trigger_subtype(str_data);
    int priority = task["trigger_priority"].asInt();
    rule_config_item_data->set_trigger_priority(priority);
    str_data = task["sha256"].asString();
    rule_config_item_data->set_sha256(str_data);
    if(task["collectMode"].asInt() == 3){
        //shadow规则
    }
    else if(task["collectMode"].asInt() == 2){
        // end_condition条件的
        //feedback规则
        //condition与end_condition条件的排期
        //condition条件转换pb数据
        Json::Value feedback_json = task["feedbackJson"];
        CommCombinedCondition *condition = new  CommCombinedCondition();
        condition->set_is_and(feedback_json["condition"][0]["is_and"].asBool());
        int condition_size = feedback_json["condition"][0]["conditions"].size();
        for(int k = 0; k<condition_size; k++){
            auto conditions = condition->add_conditions();
            conditions->set_type(feedback_json["condition"][0]["conditions"][k]["type"].asString());
            conditions->set_topic(feedback_json["condition"][0]["conditions"][k]["topic"].asString());
            conditions->set_op(feedback_json["condition"][0]["conditions"][k]["op"].asString());
            conditions->set_value(feedback_json["condition"][0]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++)
            {
                conditions->add_fields(feedback_json["condition"][0]["conditions"][k]["fields"][m].asString());
            }
        }
        int combined_condition_size = feedback_json["condition"][0]["combined_conditions"]["conditions"].size();
        for(int k = 0; k<combined_condition_size; k++){
            auto combined_conditions = condition->add_combined_conditions();
            combined_conditions->set_is_and(feedback_json["condition"][0]["combined_conditions"]["is_and"].asBool());
            auto combined_conditions_conditions = combined_conditions->add_conditions();
            combined_conditions_conditions->set_type(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["type"].asString());
            combined_conditions_conditions->set_topic(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["topic"].asString());
            combined_conditions_conditions->set_op(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["op"].asString());
            combined_conditions_conditions->set_value(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["value"].asString());
            int fields_size = feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"].size();
            for(int m = 0; m<fields_size; m++){
                combined_conditions_conditions->add_fields(feedback_json["condition"][0]["combined_conditions"]["conditions"][k]["fields"][m].asString());
            }
        }
        rule_config_item_data->set_allocated_condition(condition);
        auto data_json = feedback_json["data"][0];
        auto datas = rule_config_item_data->add_datas();
        datas->set_begin_time(data_json["begin_time"].asInt());
        datas->set_duration_time(data_json["duration_time"].asInt());
        for(int l = 0;data_json["data_items"].size();l++){
            auto data_items = datas->add_data_items();
            data_items->set_topic(data_json["data_items"][l]["topic"].asString());
        }
    }
}

void DataCollectExec::sub_update_rule(const void *para, const std::string &buf){
    MLOG(dtcl, ERROR) << "receive data_collect update rule: "<< buf;
    Json::Reader reader;
    Json::Value data_collect_rule_json;
    reader.parse(buf, data_collect_rule_json);            
    if(data_collect_rule_json["code"].asInt() == 0){
        int task_table_size = data_collect_rule_json["data"].size();
        MLOG(dtcl, ERROR) << "receive task_table_size: "<< task_table_size;
        for(int i = 0; i <task_table_size;i++){
            int data_collect_cmd_size = data_collect_rule_json["data"][i]["schedule"].size();
             MLOG(dtcl, ERROR) << "receive data_collect_cmd_size: "<< data_collect_cmd_size;
            for(int j = 0; j < data_collect_cmd_size;j++){
                Json::Value task = data_collect_rule_json["data"][i]["schedule"][j];
                MLOG(dtcl, ERROR) << "task: "<< task;
                int task_destination = task["task_destination"].asInt();
                if( task_destination == 2){
                    MLOG(dtcl, ERROR) << "receive data_collect AVP update rule: "<< task;
                    // 通过ZMQ JSON转给百度
                    Json::FastWriter fast_writer;
                    bool send_flag = _ipc_node->publish("avp_rule_update","",fast_writer.write(data_collect_rule_json));
                    if(send_flag)
                    {
                        MLOG(dtcl, ERROR) << "send avp_upate_rule failed";
                    }
                }
                else if ( task_destination == 1){
                    MLOG(dtcl, ERROR) << "receive data_collect HAOMO update rule: "<< task;
                    // 传给HAOMO
                    // JSON转给百度
                    // JSON转pb数据，然后记得保存到本地配置文件里面
                    DataCollectCmdConfig rule_config;
                    if(task["operation_type"].asString() == "ADD")
                        rule_config.set_cmd_type(DataCollectCmdConfig::ADD_RULE); 
                    else if(task["operation_type"].asString()  == "DELETE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::DEL_RULE); 
                    else if(task["operation_type"].asString()  == "UPDATE")
                        rule_config.set_cmd_type(DataCollectCmdConfig::EDIT_RULE); 
                    // rule_config.ParseFromString(buf);
                    auto cmd_type = rule_config.cmd_type();
                    if (cmd_type == DataCollectCmdConfig::ADD_RULE){
                        DataCollectRuleConfig rule_config_data;
                        solve_json_rule(task, rule_config_data);
                        _new_rules.push_back(rule_config_data);
                        _is_new_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::DEL_RULE){
                        _del_rules.push_back(task["triggerName"].asString());
                        _is_del_rule = true;
                    }
                    else if (cmd_type == DataCollectCmdConfig::EDIT_RULE){
                        //modify
                        std::string group_name = task["triggerGroup"].asString();
                        std::vector<std::string> new_topics;
                        int size = task["triggerGroup"]["new_topics"].size();
                        for (int i = 0; i < size; ++i){
                            new_topics.push_back(task["triggerGroup"]["new_topics"][i]["topic"].asString());
                        }
                        std::vector<std::string> del_topicss;
                        size = task["triggerGroup"]["del_topics"].size();
                        for (int i = 0; i < size; ++i){
                            del_topicss.push_back(task["triggerGroup"]["del_topics"][i]["topic"].asString());
                        }
                        // todo:frequency_items
                        if (_rules.find(group_name) == _rules.end()){
                            MLOG(dtcl, WARNING) << "no rule named " << group_name;
                            return;
                        }
                        // add to edited_rules for later update
                        _edited_rules[group_name] = EditableRuleElements(group_name, new_topics, del_topicss, true);
                    }
                    else{
                        MLOG(dtcl, ERROR) << "unkown rule cmd";
                    }
                }
                else
                {
                    MLOG(dtcl, ERROR) << "no destination " << task_destination;
                }
            }
        }
    }
}

void DataCollectExec::sub_avp_message(const haomo::hios::MsgNode& header, const std::string& content){
     MLOG(dtcl, ERROR) << "receive avp data: " << content;
}

void DataCollectExec::update_rules(){
    bool update_file = false;
    // update rule according to edited_rules
    for (auto iter = _edited_rules.begin(); iter != _edited_rules.end(); ++iter){
        if (iter->second.is_update){ // update rules
            std::shared_ptr<DataCollectRule> rule = _rules[iter->first];
            rule->add_data_rule(iter->second.new_topics, _co);
            rule->remove_data(iter->second.del_topicss);
            // todo: set frequency
            iter->second.is_update = false;
            //更新落盘
            update_file = true;
        }
    }

    // add new rules, if existing rule, replace the old rule
    if (_is_new_rule){
        for (auto &rule : _new_rules){
            _rules[rule.name()] = std::make_shared<DataCollectRule>(rule, _config.max_duration_time(), _co, _config_path);
        }
        _new_rules.clear();
        _is_new_rule = false;
        //更新落盘
        update_file = true;
    }

    // erase current rules
    if (_is_del_rule){
        for (auto &rule_name : _del_rules){
            _rules.erase(rule_name);
        }
        _del_rules.clear();
        _is_del_rule = false;
        //更新落盘
        update_file = true;
    }

    if(update_file == true){
        MLOG(dtcl, ERROR) << "update data_collect rule file";
        //更新主要配置文件
        std::string cfg_filename = _config_path + "data_collect_config.prototxt";
        //更新周期回传数据
        //更新触发回传数据
    }
}

void DataCollectExec::update_all_topic(){
    // 获取数据的最大集，这里默认先用全量数据，之后应该支持从配置中解析出数据并集
    ::haomo::hios::ProtoFileDes proto_file_des;
    ::haomo::hios::param_server::query<::haomo::hios::ProtoFileDes>(FLAGS_proto_file, proto_file_des);
    auto size = proto_file_des.data_size(); // topic count
    if (size != _all_topic_size){
        for (int i = 0; i < size; ++i){
            std::string topic = proto_file_des.data(i).name();
            // some ignore topics and original image topics
            if (std::find(Ignore_Topics.begin(), Ignore_Topics.end(), topic) == Ignore_Topics.end() &&                         // should not be built-in ignore topics
                std::find(_custom_ignore_topics.begin(), _custom_ignore_topics.end(), topic) == _custom_ignore_topics.end() && // should not be custom ignore topic
                std::find(Origin_Camera_Topics.begin(), Origin_Camera_Topics.end(), topic) == Origin_Camera_Topics.end() &&    // raw image is not uploaded
                std::find(Video_Topics.begin(), Video_Topics.end(), topic) == Video_Topics.end() &&                            // vp9 video is not uploaded
                topic.find("_bundle") == std::string::npos){                                                   // should not be bundle topic
                std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
                _all_topics.insert(topic);                      // add topic to all_topics
                _all_topic_size = _all_topics.size();
            }
        }
    }
}

inline bool DataCollectExec::is_cache_full(){
    uint64_t size = 0;
    for (auto &cache_item : _collector_cache){
        size += cache_item.second.size();
    }
    MLOG(dtcl, DEBUG) << "cache max:" << _max_cache_size / (1000 * 1000) << "MB"
                      << ",cache current: " << size / (1000 * 1000) << "MB";
    return size > _max_cache_size;
}

void DataCollectExec::fetch_data_to_cache(){
    while (!_is_end){
        MLOG(dtcl, INFO) << "begin fetch data loop";
        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // sleep 50ms
        std::set<std::string> all_topics;
        {
            std::lock_guard<std::mutex> lock(_topic_mutex); // lock to protect _all_topics
            all_topics = _all_topics;
        }
        for (auto &topic : all_topics){
            _threadpool_data->commit(std::bind(&DataCollectExec::fetch_data, this, topic));
        }
        MLOG(dtcl, INFO) << "end fetch data loop";
    }
    MLOG(dtcl, WARNING) << "finish fetch data thread!";
}

        void DataCollectExec::fetch_data(const std::string &topic){
            SetThreadName("dtcl_data");
            uint64_t t1 = haomo::hios::time::timestamp();
            uint64_t last_time;
            {
                // add lock because unorder_map is not thread safe
                std::lock_guard<std::mutex> lock(_cache_mutex);
                last_time = _collector_cache[topic]._last_fetch_time;
            }
            uint64_t now = haomo::hios::time::timestamp();
            auto fetch_data = ::haomo::hios::dao::msg::history_between(topic, last_time, now); // !! fetch_data无序
            MLOG(dtcl, DEBUG) << "fetch " << topic << " from " << last_time / 1000000 << " to " << now / 1000000 << " size " << fetch_data.size();
            if (fetch_data.empty()){
                MLOG(dtcl, DEBUG) << topic << " not fetched";
                return;
            }
            uint64_t t2 = haomo::hios::time::timestamp();
            {
                // ??目前使用最简单的cache管理方式，如果cache满了，不再新增数据，等旧数据发送完毕
                std::lock_guard<std::mutex> lock(_cache_mutex);
                if (is_cache_full()){
                    MLOG(dtcl, ERROR) << "cache is full :" << _max_cache_size / (1000 * 1000) << "MB"
                                      << ", discard data";
                    return;
                }
            }
            uint64_t t3 = haomo::hios::time::timestamp();
            // extract time in data and add to cache
            {
                typedef std::map<uint64_t, std::string> Ordered_Cache;
                Ordered_Cache order_cache; // container to make cache data ordered by timestamp
                for (auto &data : fetch_data){
                    last_time = DataCollector::get_msg_stamp(data.get(), "stamp"); // last_time保存取出的最后一帧时间
                    if (order_cache.find(last_time) != order_cache.end()){
                        MLOG(dtcl, DEBUG) << topic << " data time duplicated: " << last_time;
                        continue;
                    }
                    else{
                        MLOG(dtcl, DEBUG) << topic << " add data time: " << last_time;
                        uint64_t t3_1 = haomo::hios::time::timestamp();
                        std::string serial_data;
                        data->SerializeToString(&serial_data);
                        uint64_t t3_2 = haomo::hios::time::timestamp();
                        order_cache[last_time] = serial_data;
                        uint64_t t3_3 = haomo::hios::time::timestamp();
                        MLOG(dtcl, DEBUG) << topic << " serial time" << (t3_2 - t3_1) / 1000 << "ms: "
                                          << "insert time: " << (t3_3 - t3_2) / 1000 << "ms";
                    }
                }
                // this ensure datas in cache_data is ordered by timestamp
                std::lock_guard<std::mutex> lock(_cache_mutex);
                CacheData &cache_data = _collector_cache[topic];
                cache_data._topic = topic;
                for (auto &data : order_cache){
                    cache_data._times.insert(data.first);
                    cache_data.add_data(data.first, data.second);
                }
                cache_data._last_fetch_time = *(cache_data._times.rbegin()) + 1; // update last timestamp, biggest time is at end

                MLOG(dtcl, INFO) << "after fetch " << fetch_data.size() << ", " << topic << " from " << cache_data._datas.begin()->_time / 1000000
                                 << " to " << cache_data._last_fetch_time / 1000000 << " contains " << cache_data._datas.size() << " items";
            }
            uint64_t t4 = haomo::hios::time::timestamp();
            MLOG(dtcl, DEBUG) << "fetch " << topic << ",count: " << fetch_data.size() << "fetch time: " << (t2 - t1) / 1000 << "ms"
                              << ",size time:" << (t3 - t2) / 1000 << "ms"
                              << ",serial time " << (t4 - t3) / 1000 << "ms";
        }

        bool is_hardware_diagnosis(const std::string &diag_str){
            auto str = diag_str.substr(0, 2);
            return "h:" == str;
        }
        bool is_network_diagnosis(const std::string &diag_str){
            // return diag_str == GUARD_NET_DIAG_STR;
            return diag_str.find("E_V2X_") != std::string::npos;
        }
        bool is_accident(const std::string &diag_str){
            return diag_str == GUARD_ACCIDENT_STR;
        }
        bool is_software_diagnosis(const std::string &diag_str){
            return !(diag_str.empty() || is_hardware_diagnosis(diag_str) || is_network_diagnosis(diag_str) || is_accident(diag_str));
        }
        bool is_ads_active(){
            auto now = haomo::hios::time::timestamp();
            auto pre = now - 2 * 1000 * 1000; // 2 second ago
            auto fetch_data = ::haomo::hios::dao::msg::history_between("fsm_data", pre, now);
            for (auto &data : fetch_data){
                FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                auto state = p_fsmdata->fsm_state();
                if (state == FsmState::ADS_ACTIVE){
                    MLOG(dtcl, INFO) << "in 2 seconds there is ads_active status";
                    return true;
                }
            }
            return false;
        }
        int DataCollectExec::regist_condition(){
            int ret = 0;
            _trigger_times["check_accident"] = 0;
            // 事故触发，如果静止条件下触发了事故，会立即上传，并且在事故消失之后才会再次触发
            ret |= _co->regist_condition("check_accident",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;

                    // TODO: fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_accident"])/1000000 > 30)
                    //         _trigger_times["check_accident"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_accident is in 30 seconds";
                    //         return r;
                    //    }       

                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data){
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           bool is_diag_outdated = true;
                           int i = 0;
                           for (; i < size; ++i){
                               std::string error = p_diagdata->error_info(i).error();
                               auto time = p_diagdata->header().stamp();
                               auto now = haomo::hios::time::timestamp();
                               if (now - time < 1000 * 1000){
                                   is_diag_outdated = false;
                               }
                               if (is_accident(error)){
                                   // 如果当前有accident并且处于静止状态，那么下次触发出现在accident消失并再次出现
                                   if (_is_keep_accident){
                                       break;
                                   }
                                   r.val_bool = true;
                                   auto speed_data = ::haomo::hios::dao::msg::latest("vehiclespeed_rx");
                                   bool is_static = true;
                                   for (auto &speed : speed_data){
                                       VehicleSpeedData *vs_ptr = dynamic_cast<VehicleSpeedData *>(speed.get());
                                       if (vs_ptr->vehicle_speed() != 0){
                                           is_static = false;
                                       }
                                   }
                                   if (is_static){
                                       _is_keep_accident = true;
                                   }
                                   break;
                               }
                           }
                           if (is_diag_outdated || i == size){
                               // no accident detected
                               _is_keep_accident = false;
                           }
                       }
                       return r; }));            
			_trigger_times["check_diagnosis_hardware"] = 0;
			// 硬件故障触发
            ret |= _co->regist_condition("check_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
                   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
                   {
                       ConditionDefine::Value r;
                       r.is_valid = true;
                       r.val_bool = false;
                                                                              
                    //    TODO：fix
                    //    uint64_t now_time = haomo::hios::time::timestamp(); 
                    //    if((now_time - _trigger_times["check_diagnosis_hardware"])/1000000 > 30)
                    //         _trigger_times["check_diagnosis_hardware"] = now_time;
                    //    else{
                    //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_hardware is in 30 seconds";
                    //         return r;
                    //    }      
                                                                            
                       if (!is_ads_active())
                       { // only judge hardware diagnosis when ads_active
                           return r;
                       }
                       // 1. get latest diagnosis_data
                       // 2. check error_info repeated data
                       // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
                       auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
                       for (auto &data : fetch_data)
                       {
                           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                           auto size = p_diagdata->error_info_size();
                           for (int i = 0; i < size; ++i)
                           {
                               // 获取error info
                               std::string error = p_diagdata->error_info(i).error();
                               r.val_bool = is_hardware_diagnosis(error);
                               if (r.val_bool)
                               {
                                   MLOG(dtcl, INFO) << "find hardware diagnosis: " << error << " in check_diagnosis_hardware";
                                   break;
                               }
                           }
                       }
                       return r;
                   }));
            _trigger_times["check_end_diagnosis_hardware"] = 0;
            // 硬件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_hardware",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

             //    TODO：fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_end_diagnosis_hardware"])/1000000 > 30)
            //         _trigger_times["check_end_diagnosis_hardware"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_hardware is in 30 seconds";
            //         return r;
            //    }     

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto now = haomo::hios::time::timestamp();
               auto pre = now - 1 * 1000 * 1000; // 1-second-ago
               auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
               // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               if (fetch_data.empty())
               {
                   MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_hardware";
                   r.val_bool = true;
               }
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_hardware_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_diagnosis_software"] = 0;
            // 软件故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
	       [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
	       {
	           ConditionDefine::Value r;
	           r.is_valid = true;
	           r.val_bool = false;

	        //      TODO：fix
	        //    uint64_t now_time = haomo::hios::time::timestamp(); 
	        //    if((now_time - _trigger_times["check_diagnosis_software"])/1000000 > 30)
	        //         _trigger_times["check_diagnosis_software"] = now_time;
	        //    else{
	        //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_software is in 30 seconds";
	        //         return r;
	        //    }  

	           if (!is_ads_active())
	           { // only judge hardware diagnosis when ads_active
	               return r;
	           }
	           // 1. get latest diagnosis_data
	           // 2. check error_info repeated data
	           // 3. find hardware or software diagnosis_data，同时保存本次触发的errorinfo
	           auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
	           for (auto &data : fetch_data)
	           {
	               DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
	               auto size = p_diagdata->error_info_size();
	               for (int i = 0; i < size; ++i)
	               {
	                   // 获取error info
	                   std::string error = p_diagdata->error_info(i).error();
	                   r.val_bool = is_software_diagnosis(error);
	                   if (r.val_bool)
	                   {
	                       MLOG(dtcl, INFO) << "find software diagnosis: " << error << " in check_diagnosis_software";
	                       break;
	                   }
	               }
	           }
	           return r;
	       }));
            _trigger_times["check_end_diagnosis_software"] = 0;
            // 软件故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_software",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
		   [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
		   {
		       ConditionDefine::Value r;
		       r.is_valid = true;
		       r.val_bool = false;

		    // TODO：fix
		    //    uint64_t now_time = haomo::hios::time::timestamp(); 
		    //    if((now_time - _trigger_times["check_end_diagnosis_software"])/1000000 > 30)
		    //         _trigger_times["check_end_diagnosis_software"] = now_time;
		    //    else{
		    //         MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_software is in 30 seconds";
		    //         return r;
		    //    }  

		       // 1. get latest diagnosis_data
		       // 2. check error_info repeated data
		       // 3. find if pre error still exists
		       auto now = haomo::hios::time::timestamp();
		       auto pre = now - 1 * 1000 * 1000; // 1-second-ago
		       auto fetch_data = ::haomo::hios::dao::msg::history_between("diagnosis_data", pre, now);
		       // auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
		       if (fetch_data.empty())
		       {
		           MLOG(dtcl, INFO) << "no diagnosis data fetched in check_end_diagnosis_software";
		           r.val_bool = true;
		           return r;
		       }
		       for (auto &data : fetch_data)
		       {
		           DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
		           auto size = p_diagdata->error_info_size();
		           int i = 0;
		           for (; i < size; ++i)
		           {
		               // 获取error info
		               std::string error = p_diagdata->error_info(i).error();
		               if (is_software_diagnosis(error))
		               {
		                   break;
		               }
		           }
		           if (i == size)
		           {
		               MLOG(dtcl, INFO) << "no software diagnosis found in check_end_diagnosis_software";
		               r.val_bool = true; // 没有检测到硬件故障，条件成立
		           }
		       }
		       MLOG(dtcl, INFO) << "start check_end_diagnosis_software: " << fetch_data.size() << ",result :" << r.val_bool;
		       return r;
		   }));
            _trigger_times["check_diagnosis_network"] = 0;
            // 网络故障触发开始条件
            ret |= _co->regist_condition("check_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_diagnosis_network"])/1000000 > 30)
            //         _trigger_times["check_diagnosis_network"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_diagnosis_network is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find hardware or software diagnosis_data
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   for (int i = 0; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       r.val_bool = is_network_diagnosis(error);
                       if (r.val_bool)
                       {
                           MLOG(dtcl, INFO) << "find network diagnosis: " << error << " in check_diagnosis_network";
                           break;
                       }
                   }
               }
               return r;
           }));
            _trigger_times["check_end_diagnosis_network"] = 0;
            // 网络故障触发结束条件
            ret |= _co->regist_condition("check_end_diagnosis_network",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_end_diagnosis_network"])/1000000 > 30)
                    _trigger_times["check_end_diagnosis_network"] = now_time;
               else{
                    MLOG(dtcl,ERROR) << "_trigger_time of check_end_diagnosis_network is in 30 seconds";
                    return r;
               }  

               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("diagnosis_data");
               for (auto &data : fetch_data)
               {
                   DiagnosisData *p_diagdata = dynamic_cast<DiagnosisData *>(data.get());
                   auto size = p_diagdata->error_info_size();
                   int i = 0;
                   for (; i < size; ++i)
                   {
                       // 获取error info
                       std::string error = p_diagdata->error_info(i).error();
                       if (is_network_diagnosis(error))
                       {
                           break;
                       }
                   }
                   if (i == size)
                   {
                       r.val_bool = true; // 没有检测到硬件故障，条件成立
                   }
               }
               return r;
           }));
            _trigger_times["check_remote_control"] = 0;
            // 接管触发开始条件
            ret |= _co->regist_condition("check_remote_control",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;

            // TODO: fix bug
            //    uint64_t now_time = haomo::hios::time::timestamp(); 
            //    if((now_time - _trigger_times["check_remote_control"])/1000000 > 30)
            //         _trigger_times["check_remote_control"] = now_time;
            //    else{
            //         MLOG(dtcl,ERROR) << "_trigger_time of check_remote_control is in 30 seconds";
            //         return r;
            //    }  

               if (!is_ads_active())
               { // only judge hardware diagnosis when ads_active
                   return r;
               }
               // 1. get latest diagnosis_data
               // 2. check error_info repeated data
               // 3. find if pre error still exists
               auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
               for (auto &data : fetch_data)
               {
                   FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
                   auto state = p_fsmdata->fsm_state();
                   if (state == FsmState::REMOTE && _pre_fsm != FsmState::REMOTE)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " << _pre_fsm << ", curr fsm state: " << state;
                       r.val_bool = true;
                       _pre_fsm = state;
                       break;
                   }
                   _pre_fsm = state;
               }
               return r;
           }));

             _trigger_times["check_maintain_times"] = 0;
             _pre_esserrsts_data_value = 100;
            // 数值跳转
            ret |= _co->regist_condition("check_esserrsts_value_jump",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
                                                                               
               uint64_t now_time = haomo::hios::time::timestamp(); 
               if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
                {

                }
               else{
                    MLOG(dtcl,INFO) << "_trigger_time of check_maintain_times is in 30 seconds";
                    return r;
               }  

               // update topic message
               auto fetch_data = ::haomo::hios::dao::msg::latest("hmi_ifc_fd2_data");
               // 数值的跳转可以这样进行实现
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanIfcFd2OutBus *p_fsmdata = dynamic_cast<haomo::hios::VcanIfcFd2OutBus *>(data.get());

                   if (p_fsmdata && p_fsmdata->phy_sigs().ess_err_sts() == 1 && _pre_esserrsts_data_value == 0)
                   {
                       MLOG(dtcl, INFO) << "pre fsm state: " <<_pre_esserrsts_data_value << ", curr fsm state: " << p_fsmdata->phy_sigs().ess_err_sts();
                       r.val_bool = true;
                       _trigger_times["check_maintain_times"] = now_time;
                       _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
                       break;
                   }
                   if(p_fsmdata)
                    _pre_esserrsts_data_value = p_fsmdata->phy_sigs().ess_err_sts();
               }
               return r;
           }));

            //  _trigger_times["check_maintain_times"] = 0;
            //  _pre_data = FsmState::REMOTE;
            //  // 数值维持几分钟
            // ret |= _co->regist_condition("check_maintain_times",
            //                              std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
            //                                                                [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
            //                                                                {
            //                                                                    ConditionDefine::Value r;
            //                                                                    r.is_valid = true;
            //                                                                    r.val_bool = false;

            //                                                                    uint64_t now_time = haomo::hios::time::timestamp(); 
            //                                                                    if((now_time - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                     {

            //                                                                     }
            //                                                                    else{
            //                                                                         MLOG(dtcl,ERROR) << "_trigger_time of check_maintain_times is in 30 seconds";
            //                                                                         return r;
            //                                                                    }  

            //                                                                    // update topic message
            //                                                                    auto fetch_data = ::haomo::hios::dao::msg::latest("fsm_data");
                                                                               
            //                                                                    // 数值的跳转可以这样进行实现
            //                                                                    for (auto &data : fetch_data)
            //                                                                    {
            //                                                                        FsmOutput *p_fsmdata = dynamic_cast<FsmOutput *>(data.get());
            //                                                                        auto state = p_fsmdata->fsm_state();
            //                                                                        if (state == FsmState::REMOTE && first_check == false)
            //                                                                        {
            //                                                                            MLOG(dtcl, INFO) << "pre fsm state: " << _pre_data << ", curr fsm state: " << state;
            //                                                                            _trigger_times["check_maintain_times"] = now_time;
            //                                                                            _pre_data = state;
            //                                                                            first_check = true;
            //                                                                        }
            //                                                                        else if (state != FsmState::REMOTE && first_check == true)
            //                                                                         {
            //                                                                              uint64_t now_time_trigger = haomo::hios::time::timestamp(); 
            //                                                                              if((now_time_trigger - _trigger_times["check_maintain_times"])/1000000 > 30)
            //                                                                              {
            //                                                                                   MLOG(dtcl, ERROR) << "fsm state maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   r.val_bool = true;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
                                                                                                
            //                                                                              }
            //                                                                              else
            //                                                                              {
            //                                                                                  MLOG(dtcl, ERROR) << "fsm state maintain do not maintain 30 seconds: " << _pre_data << ", curr fsm state: " << state;
            //                                                                                   _trigger_times["check_maintain_times"] = now_time_trigger;
            //                                                                              }
            //                                                                              first_check = false;
            //                                                                              break;
            //                                                                         }
            //                                                                        _pre_data = state;
            //                                                                    }
            //                                                                    return r;
            //                                                                }));
            
            // 鱼骨线场景
            _trigger_times["check_fishbone_line"] = 0;
            ret |= _co->regist_condition("check_fishbone_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if ( p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (::haomo::hios::HostLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data ->lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                            auto lane_marker = lanes_adjacement.lane_marker(i);
                            if (::haomo::hios::AdjacementLaneMarker::UNDECIDED == lane_marker.type()) {
                                _trigger_times["check_fishbone_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                            }
                       }
                   }
               }
               return r;
           }));

            // 地面无车道线场景
            _trigger_times["check_no_lane_line"] = 0;
            ret |= _co->regist_condition("check_no_lane_line",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_no_lane_line"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host() && p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       bool lh_prediction_reason = false;
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                lh_prediction_reason = true;
                                break;
                            }
                       }
                       if (!lh_prediction_reason) {
                           continue;
                       }
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_host.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x01)) {
                                _trigger_times["check_no_lane_line"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
               return r;
           }));

            // 特殊天气场景
            _trigger_times["check_special_weather_scene"] = 0;
            ret |= _co->regist_condition("check_special_weather_scene",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_eq4_fs() && p_mobile_eye_data->eq4_fs().has_eq4_fs_hdr())
                   {
                       auto fs_rain = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_rain();
                       auto fs_fog = p_mobile_eye_data->eq4_fs().eq4_fs_hdr().fs_fog();
                       if (::haomo::hios::FS_99 == fs_rain || ::haomo::hios::FS_99 == fs_fog) {
                           r.val_bool = true;
                           MLOG(dtcl, INFO) << "successful trigger";
                           _trigger_times["check_special_weather_scene"] = p_mobile_eye_data->header().stamp();
                           return r;
                       }
                   }
                }

               fetch_data = ::haomo::hios::dao::msg::latest("vcan_csa_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::VcanCsaMsgBus *p_msg_bus = dynamic_cast<haomo::hios::VcanCsaMsgBus *>(data.get());
                   if (!p_msg_bus) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_msg_bus->header().stamp() - _trigger_times["check_special_weather_scene"] < 1000000 ) {
                       continue;
                   }
                   auto frnt_wipr_swt_sts = p_msg_bus->frnt_wipr_swt_sts();
                   bool frnt_fog_lmp_swt_sts = p_msg_bus->frnt_fog_lmp_swt_sts();
                   if (frnt_wipr_swt_sts == 1 || frnt_wipr_swt_sts == 2 || frnt_wipr_swt_sts == 3 || frnt_fog_lmp_swt_sts) 
                   {
                       r.val_bool = true;
                       MLOG(dtcl, INFO) << "successful trigger";
                       _trigger_times["check_special_weather_scene"] = p_msg_bus->header().stamp();
                       return r;
                   }
               }
           return r;
           }));

            // 车道线被遮挡场景
            _trigger_times["check_lane_line_covered"] = 0;
            ret |= _co->regist_condition("check_lane_line_covered",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_lane_line_covered"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_host())
                   {
                       auto lanes_host = p_mobile_eye_data ->lanes_host();
                       for (int i = 0; i < lanes_host.lane_marker_size(); i++) {
                            auto lane_marker = lanes_host.lane_marker(i);
                            if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
                   if (p_mobile_eye_data->has_lanes_adjacement())
                   {
                       auto lanes_adjacement = p_mobile_eye_data -> lanes_adjacement();
                       for (int i = 0; i < lanes_adjacement.lane_marker_size(); i++) {
                           auto lane_marker = lanes_adjacement.lane_marker(i);
                           if (lane_marker.has_general_info() && ((lane_marker.general_info().predicted_reason()) & 0x10)) {
                                _trigger_times["check_lane_line_covered"] = p_mobile_eye_data->header().stamp();
                                MLOG(dtcl, INFO) << "successful trigger";
                                r.val_bool = true;
                                return r;
                           }
                       }
                   }
               }
            return r;
           }));


           // 动物、家禽等特殊动物出现的场景
            _trigger_times["check_animal"] = 0;
            ret |= _co->regist_condition("check_animal",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_animal"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::ANIMAL == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_animal"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 一般障碍物场景
            _trigger_times["check_general_obstacle"] = 0;
            ret |= _co->regist_condition("check_general_obstacle",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_general_obstacle"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::GENERAL_OBJECT == object.object_class()) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_general_obstacle"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));


           // 微型汽车场景，例如知豆，欧拉等
            _trigger_times["check_mini_car"] = 0;
            ret |= _co->regist_condition("check_mini_car",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_mini_car"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::CAR == object.object_class() && 1.2 < object.length()  && object.length() < 4.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_mini_car"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));
        
            // 大型货车（车辆长度>=7m）场景
            _trigger_times["check_large_truck"] = 0;
            ret |= _co->regist_condition("check_large_truck",
                                         std::make_shared<ConditionDefine>(ConditionDefine::Type::BOOL,
           [this](const std::string &topic, const std::vector<std::string> &params) -> ConditionDefine::Value
           {
               ConditionDefine::Value r;
               r.is_valid = true;
               r.val_bool = false;
               auto fetch_data = ::haomo::hios::dao::msg::latest("camera_eq4_data");
               for (auto &data : fetch_data)
               {
                   haomo::hios::MobileEyeInfoPb *p_mobile_eye_data = dynamic_cast<haomo::hios::MobileEyeInfoPb *>(data.get());
                   if (!p_mobile_eye_data) {
                       continue;
                   }
                   // 触发间隔要大于1s
                   if (p_mobile_eye_data->header().stamp() - _trigger_times["check_large_truck"] < 1000000 ) {
                       continue;
                   }
                   if (p_mobile_eye_data->has_lanes_objects())
                   {
                       auto Lanes_objects = p_mobile_eye_data ->lanes_objects();
                       for (int i = 0; i < Lanes_objects.objects_size(); i++) {
                            auto object = Lanes_objects.objects(i);
                            if (::haomo::hios::Object::TRUCK == object.object_class() && 7.0 < object.length() && object.length() < 21.0) {
                                r.val_bool = true;
                                MLOG(dtcl, INFO) << "successful trigger";
                                _trigger_times["check_large_truck"] = p_mobile_eye_data->header().stamp();
                                return r;
                            }
                       }
                   }
               }
            return r;
           }));

        return ret;
        }
    } // namespace data_collect
} // namespace haomo

name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_float"   # "cond_float"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_float"   # "cond_float"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 23. 用户数据分析，HMI操作触发的数据 P0
    {
        trigger_type: TRI_HMI
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_hut_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "LaneChngCfmSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "4"
                }
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "VoiceBrdcSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "UsrManSts"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "AutoSpdSetSwt"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，特殊天气场景
    {
        trigger_type: TRI_SPECIAL_WEATHER_SCENE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "eq4_fs"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "hwa_swtreq"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "alc_swtreq"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "LaneChngCfmSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_swt_req"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "noh_act_req"
                        op: "eq"
                        value: "4"
                }
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "VoiceBrdcSwt"
                        op: "eq"
                        value: "4"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "UsrManSts"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "vcan_hut_data"
                        fields: "AutoSpdSetSwt"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]


name : "trigger"
upload_address : "collector_v2x_config.prototxt"
rules : [
   # 2. 事故定责，AEB功能激活触发的数据 P00
    {
        trigger_type: TRI_AEB
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: false
                combined_conditions: [
                    {
                        is_and: true
                        conditions: [
                           {
                                type: "cond_elapse_time"
                                topic: "aeb_iphut_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            },
                            {
                                type: "cond_uint32"
                                topic: "aeb_iphut_data"
                                fields: "fcw_warn"
                                op: "eq"
                                value: "2"
                            }
                        ]
                    },
                    {
                        is_and: true
                        conditions: [
                            {
                                type: "cond_elapse_time"
                                topic: "aeb_brk_data"
                                fields: "header"
                                fields: "stamp"
                                op: "lt"
                                value: "1000000"  # 数据要求在1s内
                            }
                        ]
                        combined_conditions: [
                            {
                                is_and: false
                                conditions: [ 
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_awb_req"
                                        op: "eq"
                                        value: "true"
                                    },
                                    {
                                        type: "cond_bool"
                                        topic: "aeb_brk_data"
                                        fields: "aeb_tgtdecel_req"
                                        op: "eq"
                                        value: "true"
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        datas : [
            {
                begin_time : -10   # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  #全量数据
                    }
                ]
            }
        ]
    },
    # 3. 事故定则，safestop触发的数据 P00
    {
        trigger_type: TRI_SAFESTOP
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "vsm_lon_ctrl_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_uint32"
                        topic: "vsm_lon_ctrl_data"
                        fields: "h_w_a_acc_control_sts"
                        op: "eq"
                        value: "3"
                }
                ]
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 4. 事故定责，接管触发的数据 P00 
    {
        trigger_type: TRI_REMOTE
        trigger_priority : 1
        duration_time : 10 
        condition: {
                is_and: true
                conditions: [
                    {
                        type: "cond_elapse_time"
                        topic: "vsm_dataclct_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 卫兵数据要求在1s内
                    }
                ]
                combined_conditions {
                        is_and: false
                        conditions: [
                                {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_overridehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driverbrakehwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "hwadataclct_driversteerhwaexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_overrideaccexit"
                                op: "eq"
                                value: "true"
                        },
                        {
                                type: "cond_bool"
                                topic: "vsm_dataclct_data"
                                fields: "accdataclct_driverbrakeaccexit"
                                op: "eq"
                                value: "true"
                        }
                        ] 
                } 
        }
        datas : [
            {
                begin_time : -10  # 10s前数据
                duration_time : 0  # 当满足end_condition的时候，才结束采集。或者最多60s
                data_items : [
                    {
                        topic : "all_topics"  # data_items目前是全量数据，可以不用单独配置了
                    }
                ]
            }
        ]
    },
    # 5. 事故定则，智能躲闪功能激活触发 P00
    {
        trigger_type: TRI_SMART_DODGE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "intelligent_eva_act_sts"
                        op: "eq"
                        value: "2"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 6. 事故定则，ELK功能激活触发 P00
    {
        trigger_type: TRI_ELK
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions:[
                    {
                        type: "cond_elapse_time"
                        topic: "hmi_ifc_fd2_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                    }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "3"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "4"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "elk_main_state"
                        op: "eq"
                        value: "5"
                    }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 20  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 7. 事故定则，ESS功能激活触发 P00
    {
        trigger_type: TRI_ESS
        trigger_priority : 1
        duration_time : 10
        condition: {
            is_and: true
            conditions:[
                {
                    type: "cond_elapse_time"
                    topic: "hmi_ifc_fd2_data"
                    fields: "header"
                    fields: "stamp"
                    op: "lt"
                    value: "1000000"  # 数据要求在1s内
                }
            ]
            combined_conditions {
                is_and: false
                conditions: [
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "1"
                    },
                    {
                        type: "cond_uint32"
                        topic: "hmi_ifc_fd2_data"
                        fields: "e_s_sintervention"
                        op: "eq"
                        value: "2"
                    }
                ]
            }
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 9. 事故定则，急转弯触发的数据 P0
    {
        trigger_type: TRI_SHARP_TURN
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "vcan_esp_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_esp_data"
                        fields: "veh_spd"
                        op: "gt"
                        value: "40.0"
                },
                {
                        type: "cond_elapse_time"
                        topic: "vcan_csa_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "cond_double"   # "cond_double"
                        topic: "vcan_csa_data"
                        fields: "steer_wheel_ang"
                        op: "gt"
                        value: "30.0"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 11. 事故定则，换道触发的数据 P0
    {
        trigger_type: TRI_CHANG_LANE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "plan_alc_decs_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                }
                ]
                combined_conditions {
                is_and: false
                conditions: [
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "1"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "2"
                },
                {
                        type: "cond_uint32"
                        topic: "plan_alc_decs_data"
                        fields: "plan_alc_lcreason"
                        op: "eq"
                        value: "4"
                }
                ]
                }
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    },
    # 28. AI场景积累，鱼骨线场景 P0
    {
        trigger_type: TRI_FISHBONE_LINE
        trigger_priority : 1
        duration_time : 10
        condition: {
                is_and: true
                conditions: [
                {
                        type: "cond_elapse_time"
                        topic: "camera_eq4_data"
                        fields: "header"
                        fields: "stamp"
                        op: "lt"
                        value: "1000000"  # 数据要求在1s内
                },
                {
                        type: "check_fishbone_line"
                        op: "eq"
                        value: "true"
                }
                ]
                
        }
        datas : [
            {
                begin_time : -10    # 10s前数据
                duration_time : 0  # 持续时间
                data_items : [
                    {
                        topic : "all_topics"  # 全量数据
                    }
                ]
            }
        ]
    }
]


                   center_128_lidar_data    6.15     128线雷达
                        front_lidar_data    9.30     前雷达
                       front_long_camera   13.76     前长焦
                front_long_camera_record    2.55
                     front_middle_camera    8.39      前中距
              front_middle_camera_record    2.93
                      front_short_camera   14.10      前短距
               front_short_camera_record    3.20
                      left_bp_lidar_data   10.54      左bp
                         left_lidar_data   10.11      左雷达
                          lf_wide_camera   16.10      左前广角相机
                   lf_wide_camera_record    4.69      左前广角相机落盘
                          lr_wide_camera   21.54      左后广角相机
                   lr_wide_camera_record    4.88      左后广角相机落盘
                         rear_lidar_data   11.47      后雷达
                      rear_middle_camera   14.38      后中距相机
               rear_middle_camera_record    3.25      后中距相机落盘
                          rf_wide_camera   23.48      右前广角相机
                   rf_wide_camera_record    4.96
                     right_bp_lidar_data   10.00
                        right_lidar_data   10.50
                          rr_wide_camera   20.12      右后广角
                   rr_wide_camera_record    4.86      右后广角落盘
                                rtk_data   49.94      rtk