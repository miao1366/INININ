1. databuffer.h
    struct databuffer {} 应该是一个存储字符的链表
       offset是读取了的字符位置    size是还剩多少字符未读取

2.  一些好的源码解析blog
    https://blog.csdn.net/zxm342698145/category_9273485.html
    https://github.com/cloudwu/skynet/wiki/ThirdPartyDocument
    https://www.cnblogs.com/RainRill/p/9019614.html

    https://www.jianshu.com/u/a0a85735b129  简书

3.  LPEG是一个供lua使用的基于 Parsing Expression Grammars 的模式匹配库
    https://blog.csdn.net/suzuiyue/article/details/52905372
    https://blog.csdn.net/akof1314/article/details/8049649

4. skynet_mq.c    先进先出队列

5. struct message_queue {
    int in_global;
};

6. skynet_mq.c    消息文件

7. skynet.h    模组对外头文件

8.  Skynet 仅解决一个问题： 
    把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。
    模块被称为服务（Service），服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。
    每个服务都是被一个个消息包驱动，当没有包到来的时候，它们就会处于挂起状态，对 CPU 资源零消耗。
    如果需要自主逻辑，则可以利用 Skynet 系统提供的 timeout 消息，定期触发

9.  for (i=0; i<n; ++i) {
        if (s->name[i].handle == handle) {
            skynet_free(s->name[i].name);
            continue;
        } else if (i!=j) {
            s->name[j] = s->name[i];
        }
        ++j;
    }
    s->name_count = j;

10  
    while (begin<=end) {
        int mid = (begin+end)/2;
        struct handle_name *n = &s->name[mid];
        int c = strcmp(n->name, name);     //按照从小到大排序
        if (c==0) {
            return NULL;
        }
        if (c<0) {
            begin = mid + 1;
        } else {
            end = mid - 1;
        }
    }

11 skynet是单进程多线程的，线程的种类有monitor/timer/socket/worker，monitor在第4篇中讲过了，就是监控服务是不是陷入死循环了。
   timer是skynet自己实现的定时器。socket是负责网络的，这个应该是最容易被理解的。worker就是工作线程了，monitor/timer/socket都只有一个线程，
   唯独worker有多个线程，是可配的，不配的话是8个线程。每个工作线程有个叫worker_parm的参数

12  TIME_NEAR_SHIFT    8
    TIME_NEAR          2^8   256
    TIME_NEAR_MASK     255
    TIME_LEVEL_SHIFT   6
    TIME_LEVEL         2^6   64
    TIME_LEVEL_MASK    63
    TIME_NEAR << TIME_LEVEL_SHIFT  2^14  16384
    2^8    2^14    2^20    2^26    2^32

13  struct link_list t[4][TIME_LEVEL]     [0][2]比[2][2]更接近触发的定时器, [0][0]比[0][2]更接近触发的定时器

14
        uint32_t time = ct >> TIME_NEAR_SHIFT;
        int i=0;
        while ((ct & (mask-1))==0) {
            int idx=time & TIME_LEVEL_MASK;
            if (idx!=0) {
                move_list(T, i, idx);
                break;				
            }
            mask <<= TIME_LEVEL_SHIFT;
            time >>= TIME_LEVEL_SHIFT;
            ++i;
        }

15
        if (ct == 0) {
            move_list(T, 3, 0);
        }

16  skynet中的时间精度是10ms级别

17
    struct timer {
        struct link_list near[TIME_NEAR];
        struct link_list t[4][TIME_LEVEL];
        struct spinlock lock;
        uint32_t time;
        uint32_t starttime;         //1970-01-01到现在的秒数
        uint64_t current;           //1970-01-01到现在的纳秒数/1000000   (10毫秒数)
        uint64_t current_point;     //系统启动时间毫秒数/10
    };

18  skynet_timer.c 
    1. timer_shift()
    2. node->expire=time+T->time;

19  下面列出来的都是消息类型，用一个字符来表示，很不直接，很不好记
        The first byte is TYPE
        S    Start socket
        B    Bind socket
        L    Listen socket
        K    Close socket
        O    Connect to (Open)
        X    Exit
        D    Send package (high)
        P    Send package (low)
        A    Send UDP package
        T    Set opt
        U    Create UDP socket
        C    set udp address
        Q    query info

20  MAX_SOCKET (1<<MAX_SOCKET_P)     65536

21  SOCKET_TYPE_HALFCLOSE_READ

22  socket_server.c  ctrl_cmd() return -1成功;

23  
    首先是lua调c，lua到C层的参数是按顺序来的，也就是说第一个参数就是1，第二个就是2....第n个就是n。从C层传递到lua层也是一样，但是会多一个参数个数
    这是一个lua调C以后，C返回的例子
    static int foo (lua_State *L) {
      int n = lua_gettop(L);    /* number of arguments */  参数个数
      lua_Number sum = 0.0;
      int i;
      for (i = 1; i <= n; i++) {
        if (!lua_isnumber(L, i)) { //参数是不是数字
          lua_pushliteral(L, "incorrect argument"); //不是数字报错
          lua_error(L);
        }
        sum += lua_tonumber(L, i); //取第i个参数
      }
      lua_pushnumber(L, sum/n);        /* first result */ 第一个返回值
      lua_pushnumber(L, sum);         /* second result */ 第二个返回值
      return 2;                   /* number of results */ 一共两个返回值
    }

24  struct skynet_node {
	ATOM_INT total;
	int init;
	uint32_t monitor_exit;
	pthread_key_t handle_key;
	bool profile;	// default is off
};

25  luaL_initcodecache()  //  云风自己定义的函数，修改lua的源码了。
    #ifdef LUA_CACHELIB
    // init the lock of code cache
    luaL_initcodecache();
    #endif

26  luaL_openlibs() 在给定的Lua状态机中打开所有的标准Lua库

27  thread:8, module_path:./cservice/?.so, harbor:1, bootstrap:snlua bootstrap, logservice:logger, profile:1