安装: https://zazalu.space/2019/06/14/ubuntu18-04%E5%AE%89%E8%A3%85mysql8-0-16-Community/

用户: root 密码: miao

1. 索引 B+TREE 索引  BTREE索引
2. 回表查询
3. 覆盖索引

1. E-R图、  数据库模型图
2. 数据库设计      

3. 	三大范式
    1. 第一范式的目标是确保每列的原子性
	2. 第二范式要求一张表只描述一件事
	3. 
    
4.  mysql -u root -p 
    mysql -u root -proot 
	
5.  show create database  数据库名  //查看创建库信息

6.  show create table 表名   //查看创建表信息 

6.1  show databases;   //显示所有的数据库
     show  tables;     //显示某个数据库中所有的表
     use   数据库名     //选择某个数据库

7.  char   
    定长字符串 char(n)     即使没存数据，也要占用n个字符  查询效率较高
    char列的长度在你建表的时候，就是你定义的固定长度。值的范围是0~255。char值存储的时候，
	右部以空格来填充到指定的长度。当检索char的时候，会自动去掉尾部的空格
    
	varchar
	变长字符串 varchar(n)   n决定最多存储的字符
    在MySQL5.0.3之前，值被保存到varchar列的时候，尾部空格会被剔除.

8.  timestamp  只要一行中的数据有变动，timestamp的值都会更新。
     
9.  一个表中只有一个主键

10.  复合主键   主键不能有空值
    create table test(id int, userid char(20), name char(10), 
		primary key (id, userid));  
    id userid 各种可以有相同值，但是不能有相同的组合值。

11  唯一约束  unique
    create table test (
        id int primary key,
        userid char(18) unique
    );
    对于null ,不同的数据库处理方式不同，有些可以重复，有些不能重复(unique)

12  外键约束
    主表(父表):提供数据所在的表  要有主键
    从表(子表):外键所在的表
       外键字段要么来自于主表中的对应字段，要么为null.
    
    create table classes (
       class_no int primary key,
       class_name char(20)
    );
    create table student (
        stu_no int primary key,
        stu_name char (20) not null,
        class_no  int ,
        foreign key(class_no) references classes(class_no) 
    );
    1. 创建表时, 先创建主表，在创建从表
    2. 被引用的字段必须是主表的主键字段

13 为约束命名
   constraint 约束名  约束规则
   constraint 

    create table test (
        t_no int primary key,
        t_name char(20),
        constraint test_name_uk unique(t_name)
    );
    # 外键
    constraint 约束名 foreign key (字段名) references 主表名(主表字段名) 

14 自增型字段  auto_increment  自增型字段必须是主键
   create table test(
       t_no int primary key auto_increment
   );

15 查看字符集信息
   show variables like 'CHAR%'
   
   

--------------学生选课系统数据库--------------
create database choose;

1. 创建数据库
    create database choose character set=utf8  ;
    show create database choose;

2. 创建班级表
   表名:classes
   字段: class_no 整型 自增长 主键         -- 班级编号
         class_name char(20) 非空  唯一   -- 班级名称
         department_name char(20) 非空    -- 院系名称
         create table classes (
             class_no int auto_increment primary key,
             class_name char(10) unique not null,
             department_name char(20) not null
         )

    创建教师表
    表名: teacher
    字段: teacher_no      char(10) 主键          --教师工号
          teacher_name    char(10) 非空         --教师姓名
          teacher_contact char(20) 非空         --联系方式
    创建学生表
    表名: student

1. create database choose character set=utf8; //创建choose 数据库

创建班级表
表名: classes
字段: class_no          整型          自增长              主键         //班级编号
     class_name        char(20)     非空                唯一         //班级名称
     department_name   char(20)     非空                非空         //院系名称
    
 create table classes(class_no int auto_increment primary key, 
            class_name char(10) unique not null, 
            department_name char(20) not null );


创建教师表
表名: teacher
字段: teacher_no          char(10)                        主键         //教师编号
     teacher_name        char(20)     非空                非空         //教师姓名
     teacher_contact     char(20)     非空                非空         //联系方式

create table teacher(teacher_no char(10) primary key, 
            teacher_name char(20) not null, 
            teacher_contact char(20) not null);

创建学生表
表名: student;
字段: student_no          char(11)                        主键         //教师编号
     student_name        char(20)     非空                非空         //教师姓名
     student_contact     char(20)     非空                非空         //联系方式
     class_no            int          外键

create table student(student_no char(11) primary key,
    student_name char(20) not null,
    student_contact char(20) not null,
    class_no  int, 
    constraint student_class_fk foreign key
    (class_no) references classes(class_no));;

创建课程表
表名: course;
字段: course_no          int           自增长             主键         
     course_name        char(20)     非空                非空         
     up_limit           int          默认                60
     description        varchar(100)                     非空
     status             char(6)      默认                未审核         
     teacher_no         char(10)     非空     唯一       外键

    create table course(
        course_no int auto_increment primary key,
        course_name char(16) not null,
        up_limit int default 60,
        description varchar(100) not null,
        status char(6) default '未审核',
        teacher_no char(10) unique not null,
        constraint course_teacher_fk foreign key (teacher_no) references teacher(teacher_no));

创建选课表
表名:choose
字段:
    choose_no          int                 自增长         主键
    student_no         char(10)
    score                     
    choose_time
    course_no

    create table choose( 
        choose_no int auto_increment primary key, 
        student_no char(11) not null, 
        course_no int not null, 
        choose_time datetime not null, 
        score tinyint unsigned, 
        constraint choose_student_fk foreign key (student_no) references student(student_no), 
        constraint choose_course_fk foreign key (course_no) references course(course_no) 
        );
    
    引用的外键需要是其他表的主键，外键要和引用的主键类型一致，名字可以不同。

    DECIMAL数据类型用于要求非常高的精确度的计算中，这些类型允许指定数值的
    精确度和计数方法作为选择参数。精确度在这里是指为这个值保存的有效数字的总个数，
    而计数方法表示小数点后数字的个数。例如，语句DECIMAL(5,2)规定了存储的值将不会超过5位数字，
    并且小数点后面有2位数字。

    复制表结构 (但是这样外键并没有复制)
    1. create table 表名 like 源表
    2. create table 表名  select * (也可以是部分数据) from 源表 (复制源表结构和数据)
    
    修改表结构
        可修改表的字段名、类型、约束条件、表名...
        也可以删除表的字段、约束条件...
    
    删除一个主表时，如果一个表的外键是主表的索引时，先要删除子表，或者把字表的外键删除掉。
    
    dmi     删除 修改 增加
    curd    代表创建（Create） 、 更新（Update） 、 读取（Read） 和 删除（Delete） 操作 应该是查询语句相关。

    desc  table teacher;
    desc  teacher;
    
    显示创建表语句 show create table  表名
    
    达内 Mysql pdf文档[]代表 可选项

    对于自增长时，insert失败、delete数据都会造成自增长的值不连续。
    insert 可以同时插入多条数据。 

    不可否认主键时唯一的，但是当一个表有两个主键时，此时是两个主键一起做为主键，即联合主键，
    两个主键只要有一个不同，就算作不同的。但当两个主键完全一样时，才会报错，说主键不能重复

    insert into course values(null, 'c语言', 230, '暂无', '已审核', '003');
    insert into course values(null, 'mysql', 150, '暂无', '已审核', '002');
    insert into course values(null, 'java语言', default, '暂无', '已审核', '001');
 

    create table stu like student;
    insert into stu select * from student;  //student表中所有数据插入 stu中。
    update stu set student_name = '张三丰' ,class_no=2  where student_name= '张三';

    select distinct class_no  from student;  //获取不重复数据，排重

    delete表数据，下次插入数据时，自增字段数据也会中断，不会有连续
    turncate删除数据，自增数据也会删除。

    增删改支持事务的回滚， turncate不支持回滚

char() varchar() 区别
    char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，
    所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节
1、char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节。
2、同时char和varchar最大的区别就在于char不管实际value都会占用n个字符的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1<=n。
3、超过char和varchar的n设置后，字符串会被截断。
4、char的上限为255字节，varchar的上限65535字节，text的上限为65535。
5、char在存储的时候会截断尾部的空格，varchar和text不会。
6、varchar会使用1-3个字节来存储长度，text不会
7、 char在存储的时候会将右侧空格进行剔除，保留左侧空格。
    varchar在存储的时候保留所有空格，不进行任何删除
    varchar和char在查询的时候都只会根据where条件中的左侧空格进行判断，右侧末尾的空格会忽略

    子表有引用主表主键时，如果删除有子表引用的主表主键，会删除失败。

   select  department_name 院系 from classes;  // department_name 取别名院系
   select distinct department_name 院系 from classes;  // department_name 去重
   select distinct class_no,department_name 院系 from classes;  //class_no department_name 都相同时才会去重
   
   select count(*) from information_schema.tables; // information_schema.tables 系统库里的保存所有表信息的
select table_schema, table_name ,table_rows from information_schema.tables limit 10;  //获取前十行
select table_schema, table_name ,table_rows from information_schema.tables where table_rows = 0  limit 3；

// 从第三行开始取三行数据
select table_schema, table_name ,table_rows from information_schema.tables where table_rows = 0  limit 3, 3;

select student.student_no 学号, student.student_name 姓名,
classes.class_name 班级, classes.department_name 学院 from classes inner join student
on student.class_no = classes.class_no;



select s.student_no 学号, s.student_name 姓名,
c.class_name 班级, c.department_name 学院 from classes c inner join student s
on s.class_no = c.class_no;  // 给表取别名



select student_no 学号, student_name 姓名,
class_name 班级, department_name 学院 from classes c inner join student s
on s.class_no = c.class_no;  // 不重复的字段名可以不加表的名字。建议加表名


select  course_name , teacher_name from  course inner join teacher on course.teacher_no = teacher.teacher_no;

drop table  表名  //删除表

SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，
攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，
在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，
从而进一步得到相应的数据信息

查询语句中，表定义了别名后就要用别名了，不能用原名。 字段可以

表连接
    内连接 ()
    select 列名1 别名1，列名2 别名2...
    from 表名1 别名1 inner join 表名2 别名2 on 多表间的关联关系
    where 条件
    order by 排序1 asc|desc，排列2 asc|desc....；


on 语句先执行 select , from语句最新执行。

左外连接(根据左表数据匹配右表， 左表为主)
左外连接的结果集=内连接的结果集+左表匹配不上的记录
语法:
from 表1 left join 表2 on 表1和表2之间的连接条件
    左外连接 left outer join....on，也称为左连接 left join...on
    以左边的表作为主表，无论右边的表是否可以匹配到都显示主表中的数据
    语法:
        select 列名1 别名1，列名2 别名2...
        from 表名1别名1 left join 表名2 别名2 on 多表的关联关系
        where 条件
        order by 排序列1 asc|desc，排序列2 asc|desc...；　

右外连接(根据右表数据匹配左表，右表为主)
– 右外连接的结果集=内连接的结果集+右表匹配不上的记录
– 语法
    右外连接 right outer join...on 也称为 right join...on
    以右边的表为主表，无论如何都会显示主表中的所有数据

全连接  full 
    mysql不支持全连接。oracle支持
    
mysql> select * from teacher1;
+------------+--------------+
| teacher_no | teacher_name |
+------------+--------------+
|          1 | 张老师       |
|          2 | 王老师       |
+------------+--------------+

mysql> select * from course1;
+-----------+-------------+------------+
| course_no | course_name | teacher_no |
+-----------+-------------+------------+
|         1 | 数学        |          1 |
|         2 | 语文        |          1 |
+-----------+-------------+------------+

右连接
mysql> select teacher1.teacher_no, teacher_name ,course_name  from teacher1 inner join course1 on teacher1.teacher_no = course1.teacher_no;
+------------+--------------+-------------+
| teacher_no | teacher_name | course_name |
+------------+--------------+-------------+
|          1 | 张老师       | 语文        |
|          1 | 张老师       | 数学        |
+------------+--------------+-------------+

左外连接
select teacher1.teacher_no, teacher_name ,course_name  from teacher1  left join course1 on teacher1.teacher_no = course1.teacher_no;
+------------+--------------+-------------+
| teacher_no | teacher_name | course_name |
+------------+--------------+-------------+
|          1 | 张老师       | 语文        |
|          1 | 张老师       | 数学        |
|          2 | 王老师       | NULL        |
+------------+--------------+-------------+

多表联查
使用三表内连接，列出学生的学号、姓名、所在班级名称、成绩。
mysql> select * from student;
+------------+--------------+-----------------+----------+
| student_no | student_name | student_contact | class_no |
+------------+--------------+-----------------+----------+
| 2017001    | 张三         | 13012222000     |        1 |
| 2017002    | 李四         | 13012222000     |        1 |
| 2017003    | 王五         | 14312222000     |        3 |
| 2017004    | 赵六         | 14312222000     |        2 |
| 2017005    | 田七         | 14312222000     |        2 |
| 2017006    | 小刘         | 20000000000     |     NULL |
+------------+--------------+-----------------+----------+

mysql> select * from classes;
+----------+-------------------+-----------------+
| class_no | class_name        | department_name |
+----------+-------------------+-----------------+
|        1 | 2017自动化1班      | 机电工程        |
|        2 | 2017自动化2班      | 机电工程        |
|        3 | 2017自动化3班      | 机电工程        |
|        4 | 计算机1班          | 信息学院        |
+----------+-------------------+-----------------+

mysql> select * from choose;
+-----------+------------+-----------+---------------------+-------+
| choose_no | student_no | course_no | choose_time         | score |
+-----------+------------+-----------+---------------------+-------+
|         1 | 2017001    |         1 | 2020-11-20 19:58:43 |    40 |
|         2 | 2017002    |         1 | 2020-11-20 19:58:58 |    50 |
|         3 | 2017001    |         2 | 2020-11-20 19:59:19 |    60 |
|         4 | 2017003    |         3 | 2020-11-20 19:59:36 |    70 |
|         5 | 2017004    |         2 | 2020-11-20 19:59:51 |    80 |
|         6 | 2017005    |         1 | 2020-11-20 20:00:07 |    90 |
|         7 | 2017003    |         1 | 2020-11-20 20:00:18 |  NULL |
+-----------+------------+-----------+---------------------+-------+

select student.student_no ,student.student_name ,classes.class_name ,
choose.score from student inner join  classes on student.class_no = 
classes.class_no inner join choose on student.student_no = choose.student_no;
+------------+--------------+-------------------+-------+
| student_no | student_name | class_name        | score |
+------------+--------------+-------------------+-------+
| 2017001    | 张三         | 2017自动化1班     |    40 |
| 2017001    | 张三         | 2017自动化1班     |    60 |
| 2017002    | 李四         | 2017自动化1班     |    50 |
| 2017004    | 赵六         | 2017自动化2班     |    80 |
| 2017005    | 田七         | 2017自动化2班     |    90 |
| 2017003    | 王五         | 2017自动化3班     |    70 |
| 2017003    | 王五         | 2017自动化3班     |  NULL |
+------------+--------------+-------------------+-------+

修改表结构 alter;
alter table student drop class_no //表student删除class_no字段

//表student添加 userid字段,默认添加到最后，可用 first 、after修饰
alter table student add userid char(18) first  

//表student userid数据类型修改为int, 如果表中userid不是全数字字符，会修改失败。
alter table student modify userid userid int  

//表student student_name 添加唯一约束
alter table student add constraint s_name_uk unique(student_name) 

//表student 删除主键  一个表中只有一个主键，可以有组合主键
alter table student drop constraint primary key

//表student 删除 s_name_uk 索引
alter table student drop index s_name_uk


//表student 改名为stu;  rename table student to stu  这样也可以。
alter table student rename stu;

turncate 可清除数据库,但不支持回滚。

mysql> select * from classes;
+----------+-------------------+-----------------+
| class_no | class_name        | department_name |
+----------+-------------------+-----------------+
|        1 | 2017自动化1班     | 机电工程        |
|        2 | 2017自动化2班     | 机电工程        |
|        3 | 2017自动化3班     | 机电工程        |
|        4 | 计算机1班         | 信息学院        |
+----------+-------------------+-----------------+
4 rows in set (0.00 sec)

mysql> select * from student;
+------------+--------------+-----------------+----------+
| student_no | student_name | student_contact | class_no |
+------------+--------------+-----------------+----------+
| 2017001    | 张三         | 13012222000     |        1 |
| 2017002    | 李四         | 13012222000     |        1 |
| 2017003    | 王五         | 14312222000     |        3 |
| 2017004    | 赵六         | 14312222000     |        2 |
| 2017005    | 田七         | 14312222000     |        2 |
| 2017006    | 小刘         | 20000000000     |     NULL |
+------------+--------------+-----------------+----------+

// 列出 ‘2017自动化2班’的所有学生的信息，列出学号、姓名和班级名称

mysql> select student_no, student_name, 
class_name from student inner join classes on student.class_no = 
classes.class_no where classes.class_no = 2;

// where语句实现内连接
select student_no, student_name, class_name from student ,
classes classes where student.class_no= classes.class_no 
and classes.class_no =2;

+------------+--------------+-------------------+
| student_no | student_name | class_name        |
+------------+--------------+-------------------+
| 2017004    | 赵六         | 2017自动化2班     |
| 2017005    | 田七         | 2017自动化2班     |
+------------+--------------+-------------------+

// 查找没有学生的班级
select classes.class_no, class_name from classes  left join student on 
classes.class_no = student.class_no 
where student_no is null;
+----------+---------------+
| class_no | class_name    |
+----------+---------------+
|        4 | 计算机1班     |
+----------+---------------+



delimiter  一般情况下，mysql默认遇到分号';'就会执行命令,
delimiter可以修改这一属性；
now()函数

concat() 函数用于将多个字符串连接成一个字符串
select  concat(student_no ,'的名字是', student_name) 信息  from student;

substring() 字符裁剪

// between .. and
select student_no,course_no ,score from choose where score between 50 and 60

// in 
select student_no, student_name from student where class_no in(1,3);
使用 not in ()时， ()中不能包含null 
class_no in (1,2,null) ===> class_no=1 or class_no=2 or class_no=null.

class_no not in (1,null) ===> not （class_no=1  or class_no=null）
                         ===> class_no !=1 and  class_no!=null ===>条件永远为假

null  表示空值，不能用于比较符。

通配符
_  : 一个任意字符
%  : 任意长度的任意字符

// 查找所有田姓学生
select student_no, student_name from student where student_name like '田%'

// 学生姓名最少两个字
select student_no, student_name from student where student_name like '田_%'

like; not like ; null ; not null;

escape  //自定义转义字符， 默认\
select student_no, student_name from student where student_name like '小|_%' escape '|';

order by // 排序，默认按升许，null是最小值， 
select * from choose order by score
select * from choose order by course_no, student_no;  // 排序后再按照学号排序

聚合函数  //(对待null值采用忽略处理)
count():统计一组数据的行数、参数可以是任何类型、也可以是*(* 号包含null) 
max():统计一组数据的最大值, 参数可以是任何数值、字符串、日期类型
min():统计一组数据的最小值，参数要是数值类型
sum():统计一组数据的累加值，参数要是数值类型，null值忽略
avg():统计一组数据的平均值，参数要是数值类型，null值忽略

聚合函数的参数可以排重(distinct)
mysql> select * from student;
+------------+--------------+-----------------+----------+
| student_no | student_name | student_contact | class_no |
+------------+--------------+-----------------+----------+
| 2017001    | 张三         | 13012222000     |        1 |
| 2017002    | 李四         | 13012222000     |        1 |
| 2017003    | 王五         | 14312222000     |        3 |
| 2017004    | 赵六         | 14312222000     |        2 |
| 2017005    | 田七         | 14312222000     |        2 |
| 2017006    | 小刘         | 20000000000     |     NULL |
+------------+--------------+-----------------+----------+
6 rows in set (0.00 sec)

mysql> select * from choose;
+-----------+------------+-----------+---------------------+-------+
| choose_no | student_no | course_no | choose_time         | score |
+-----------+------------+-----------+---------------------+-------+
|         1 | 2017001    |         1 | 2020-11-20 19:58:43 |    40 |
|         2 | 2017002    |         1 | 2020-11-20 19:58:58 |    50 |
|         3 | 2017001    |         2 | 2020-11-20 19:59:19 |    60 |
|         4 | 2017003    |         3 | 2020-11-20 19:59:36 |    70 |
|         5 | 2017004    |         2 | 2020-11-20 19:59:51 |    80 |
|         6 | 2017005    |         1 | 2020-11-20 20:00:07 |    90 |
|         7 | 2017003    |         1 | 2020-11-20 20:00:18 |  NULL |
+-----------+------------+-----------+---------------------+-------+
7 rows in set (0.00 sec)

// 列出张三的平均分
select avg(score) from choose join student on student.student_no = choose.student_no and student_name = '张三';
+------------+
| avg(score) |
+------------+
|    50.0000 |
+------------+

// 统计每个班级的人数，
select class_no, count(student_no) from student group by class_no;


// 统计每个学生的最高分，最低分 ，平均分
mysql> select * from choose;
+-----------+------------+-----------+---------------------+-------+
| choose_no | student_no | course_no | choose_time         | score |
+-----------+------------+-----------+---------------------+-------+
|         1 | 2017001    |         1 | 2020-11-20 19:58:43 |    40 |
|         2 | 2017002    |         1 | 2020-11-20 19:58:58 |    50 |
|         3 | 2017001    |         2 | 2020-11-20 19:59:19 |    60 |
|         4 | 2017003    |         3 | 2020-11-20 19:59:36 |    70 |
|         5 | 2017004    |         2 | 2020-11-20 19:59:51 |    80 |
|         6 | 2017005    |         1 | 2020-11-20 20:00:07 |    90 |
|         7 | 2017003    |         1 | 2020-11-20 20:00:18 |  NULL |
+-----------+------------+-----------+---------------------+-------+
7 rows in set (0.00 sec)

mysql> select student_no, max(score),min(score),avg(score) from choose group by student_no;
+------------+------------+------------+------------+
| student_no | max(score) | min(score) | avg(score) |
+------------+------------+------------+------------+
| 2017001    |         60 |         40 |    50.0000 |
| 2017002    |         50 |         50 |    50.0000 |
| 2017003    |         70 |         70 |    70.0000 |
| 2017004    |         80 |         80 |    80.0000 |
| 2017005    |         90 |         90 |    90.0000 |
+------------+------------+------------+------------+

// select 后面 添加内容最好只有order by 后面的字段
select student_no, max(score),min(score),avg(score) from choose group by student_no;

//筛选出选修课程数大于1的学生，列出学号和选修课程数
select * from choose;
+-----------+------------+-----------+---------------------+-------+
| choose_no | student_no | course_no | choose_time         | score |
+-----------+------------+-----------+---------------------+-------+
|         1 | 2017001    |         1 | 2020-11-20 19:58:43 |    40 |
|         2 | 2017002    |         1 | 2020-11-20 19:58:58 |    50 |
|         3 | 2017001    |         2 | 2020-11-20 19:59:19 |    60 |
|         4 | 2017003    |         3 | 2020-11-20 19:59:36 |    70 |
|         5 | 2017004    |         2 | 2020-11-20 19:59:51 |    80 |
|         6 | 2017005    |         1 | 2020-11-20 20:00:07 |    90 |
|         7 | 2017003    |         1 | 2020-11-20 20:00:18 |  NULL |
+-----------+------------+-----------+---------------------+-------+
7 rows in set (0.00 sec)

mysql> select student_no ,count(student_no) cnt from  choose   group by  student_no having cnt >1;
+------------+-----+
| student_no | cnt |
+------------+-----+
| 2017001    |   2 |
| 2017003    |   2 |
+------------+-----+

select student_name, student.student_no ,count(student.student_no)cn from student join choos
e on student.student_no= choose.student_no group by  student.student_no having cn>1;
+--------------+------------+----+
| student_name | student_no | cn |
+--------------+------------+----+
| 张三         | 2017001    |  2 |
| 王五         | 2017003    |  2 |
+--------------+------------+----+


语法:
    1.where子句中不能使用字段或者表达式的别名
    2.where子句中不能使用聚合函数(组函数)

having子句
    功能：在分组语句中，根据条件筛选符合条件的组(可以使用字段或者表达式的别名)

sql语法输入顺序
   select
      from
        where
          group by
            having
              order by

sql执行顺序
    from
      where
        select
          group by
            having
              order by

group_concat()函数
mysql> select * from  student;
+------------+--------------+-----------------+----------+
| student_no | student_name | student_contact | class_no |
+------------+--------------+-----------------+----------+
| 2017001    | 张三         | 13012222000     |        1 |
| 2017002    | 李四         | 13012222000     |        1 |
| 2017003    | 王五         | 14312222000     |        3 |
| 2017004    | 赵六         | 14312222000     |        2 |
| 2017005    | 田七         | 14312222000     |        2 |
| 2017006    | 小刘         | 20000000000     |     NULL |
+------------+--------------+-----------------+----------+
6 rows in set (0.00 sec)

mysql> select group_concat(student_name) 学生名单 ,count(*) 人数 from student group by class_no;
+---------------+--------+
| 学生名单      | 人数   |
+---------------+--------+
| 小刘          |      1 |
| 张三,李四     |      2 |
| 赵六,田七     |      2 |
| 王五          |      1 |
+---------------+--------+



with rollup选项 (对数据进行统计)
mysql> select * from  student;
+------------+--------------+-----------------+----------+
| student_no | student_name | student_contact | class_no |
+------------+--------------+-----------------+----------+
| 2017001    | 张三         | 13012222000     |        1 |
| 2017002    | 李四         | 13012222000     |        1 |
| 2017003    | 王五         | 14312222000     |        3 |
| 2017004    | 赵六         | 14312222000     |        2 |
| 2017005    | 田七         | 14312222000     |        2 |
| 2017006    | 小刘         | 20000000000     |     NULL |
+------------+--------------+-----------------+----------+
6 rows in set (0.00 sec)

mysql> select class_no 班级 ,count(*) 人数 from student group by class_no with rollup;
+--------+--------+
| 班级   | 人数   |
+--------+--------+
|   NULL |      1 |
|      1 |      2 |
|      2 |      2 |
|      3 |      1 |
|   NULL |      6 |
+--------+--------+

union 合并结果集
mysql> select student_no ,student_name from student;
+------------+--------------+
| student_no | student_name |
+------------+--------------+
| 2017001    | 张三         |
| 2017002    | 李四         |
| 2017003    | 王五         |
| 2017004    | 赵六         |
| 2017005    | 田七         |
| 2017006    | 小刘         |
+------------+--------------+
6 rows in set (0.00 sec)

mysql> select teacher_no,teacher_name from teacher;
+------------+--------------+
| teacher_no | teacher_name |
+------------+--------------+
| 001        | 王老师       |
| 002        | 李老师       |
| 003        | 张老师       |
+------------+--------------+

mysql> select teacher_no,teacher_name from teacher union select student_no ,student_name from student;
+------------+--------------+
| teacher_no | teacher_name |
+------------+--------------+
| 001        | 王老师       |
| 002        | 李老师       |
| 003        | 张老师       |
| 2017001    | 张三         |
| 2017002    | 李四         |
| 2017003    | 王五         |
| 2017004    | 赵六         |
| 2017005    | 田七         |
| 2017006    | 小刘         |
+------------+--------------+

SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL

子查询返回单列：
列出比‘张三’平均分高的成绩
 1.列出'2017001'的平均分
   select avg(score) from choose where student_no='2017001'; //50
 2. 列出成绩高于50的信息
   select student_no,course_no,score from choose where score > 50;
 3. 合并上面两条语句
 select student_no,course_no,score from choose where score > 
 (select avg(score) from choose where student_no='2017001');
   
 select * from choose;
+-----------+------------+-----------+---------------------+-------+
| choose_no | student_no | course_no | choose_time         | score |
+-----------+------------+-----------+---------------------+-------+
|         1 | 2017001    |         1 | 2020-11-20 19:58:43 |    40 |
|         2 | 2017002    |         1 | 2020-11-20 19:58:58 |    50 |
|         3 | 2017001    |         2 | 2020-11-20 19:59:19 |    60 |
|         4 | 2017003    |         3 | 2020-11-20 19:59:36 |    70 |
|         5 | 2017004    |         2 | 2020-11-20 19:59:51 |    80 |
|         6 | 2017005    |         1 | 2020-11-20 20:00:07 |    90 |
|         7 | 2017003    |         1 | 2020-11-20 20:00:18 |  NULL |
+-----------+------------+-----------+---------------------+-------+
7 rows in set (0.00 sec)

mysql> select student_no,course_no,score from choose where score > 
    ->  (select avg(score) from choose where student_no='2017001');
+------------+-----------+-------+
| student_no | course_no | score |
+------------+-----------+-------+
| 2017001    |         2 |    60 |
| 2017003    |         3 |    70 |
| 2017004    |         2 |    80 |
| 2017005    |         1 |    90 |
+------------+-----------+-------+
4 rows in set (0.02 sec)


//没有选课的老师

mysql> select * from course;
+-----------+-------------+----------+-------------+-----------+------------+
| course_no | course_name | up_limit | description | status    | teacher_no |
+-----------+-------------+----------+-------------+-----------+------------+
|         1 | java语言    |       60 | 暂无        | 已审核    | 001        |
|         2 | mysql       |      150 | 暂无        | 已审核    | 002        |
|         3 | c语言       |      230 | 暂无        | 已审核    | 003        |
+-----------+-------------+----------+-------------+-----------+------------+
3 rows in set (0.00 sec)

mysql> select * from choose;
+-----------+------------+-----------+---------------------+-------+
| choose_no | student_no | course_no | choose_time         | score |
+-----------+------------+-----------+---------------------+-------+
|         1 | 2017001    |         1 | 2020-11-20 19:58:43 |    40 |
|         2 | 2017002    |         1 | 2020-11-20 19:58:58 |    50 |
|         3 | 2017001    |         2 | 2020-11-20 19:59:19 |    60 |
|         4 | 2017003    |         3 | 2020-11-20 19:59:36 |    70 |
|         5 | 2017004    |         2 | 2020-11-20 19:59:51 |    80 |
|         6 | 2017005    |         1 | 2020-11-20 20:00:07 |    90 |
|         7 | 2017003    |         1 | 2020-11-20 20:00:18 |  NULL |
+-----------+------------+-----------+---------------------+-------+
7 rows in set (0.00 sec)

mysql> select * from teacher;
+------------+--------------+-----------------+
| teacher_no | teacher_name | teacher_contact |
+------------+--------------+-----------------+
| 001        | 王老师       | 11000000000000  |
| 002        | 李老师       | 1120000000000   |
| 003        | 张老师       | 1320000000000   |
| 004        | 杨老师       | 155544444       |
+------------+--------------+-----------------+
4 rows in set (0.00 sec)

mysql> select teacher.teacher_no,teacher.teacher_name from teacher 
    -> where teacher.teacher_no not in(select distinct course.teacher_no 
    -> from choose join course on course.teacher_no=choose.course_no);
+------------+--------------+
| teacher_no | teacher_name |
+------------+--------------+
| 004        | 杨老师       |
+------------+--------------+

where子句， 内连接， 外连接


1. 索引 index
    1.1 作用
    提高查询效率，降低增加 、删除、改的料率
    创建索引需要大量的时间和空间。

 经常用来筛选，排序，查找的字段可以考虑用来添加索引
 数据量较少(10万)时，不适合添加索引。

mysql> create table test_index(id int auto_increment primary key, 
userid int, name char(10), unique index ix_test_uid (userid));

查看一个表的索引
show index from test_index \G    // \G 垂直打印内容
show keys from test_index \G

删除索引
    drop index 索引名 on 表名

视图 view
作用: 
    1.简化复杂查询
    2.数据安全 

with check option (后面操作要满足view的选项)
视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的
https://blog.csdn.net/qq_38712932/article/details/83050768

注意mysql类型的隐式转换

会话变量
set @User_name='张三';
mysql> select @User_name;
+------------+
| @User_name |
+------------+
| 张三       |
+------------+

mysql> set @User_name=100;                // 没有给定类型，类型可变
Query OK, 0 rows affected (0.00 sec)

mysql> select @User_name;
+------------+
| @User_name |
+------------+
|        100 |
+------------+

局部变量
delcare     变量名    数据类型

begin .... end // 类似于{}
函数
    无参的函数
    delimiter    //重置命令结束标志
create function row_no_fn() returns int
begin
    set @r_no = @r_no + 1;
    return @r_no;
end;

正确地创建合适的索引是数据库性能优化的基础
数据库索引是一种为了加速数据表中行记录检索的数据结构
数据库中的索引存储于磁盘中
索引->磁盘数据

哈希索引:
hashmap 高低16位的异或， 等同于取模
hashmap 查找复杂度 O(1)
1. 等值匹配是非常高效的
2. 不支持范围查找

二叉树索引:
1. io次数过多
2. io效率过低


操作系统页      4kb
数据库页        16kb
空间局部性原理  预加载

操作系统与磁盘
B树  B变种树




搜索引擎
innodb    Myisam

mysql官方建议主键采用自增序列
经常变动的列不建议创建索引
mysql 左闭合

B+树的优势 (b+树只有叶子节点保存了数据，叶子节点)
1. B+树是B-树的加强版
2. IO能力
3. 基于索引的表扫描性能
4. 排序能力
5. 查询稳定

插拔式的存储引擎

//查看mysql数据存储路径
show variables like 'datadir';
innodb  聚集索引
聚集索引：指数据库表行中数据的物理顺序与键值的逻辑(索引)顺序相同。
在innodb引擎中，只有主键才是聚集索引，其他索引都是非聚集索引

innodb 有三种方式创建索引，用户没有显示的创建索引的话，innodb会用rowid创建索引
主键索引    辅助索引    回表
辅助索引存储的是主键索引的值

列的离散性， 
离散度过低的话，查询会不走索引

count(distinct col): count(col)    //比值越高离散性越好
1. 若列的离散性越好，列的选择性越好
2. 选择性好的列作为索引更合适
3. 离散性很差的列作为索引可能适得其反

数据隐式转换
utf8mb4

1. 联合索引是一个索引
2.联合索引的使用遵循最左前置原则
    最左前置原则(最常用列 > 离散度高 > 最少空间)
3. 单列索引是一种特殊的联合索引
索引重复

覆盖索引
通过索引项的信息可直接返回所需的查询列，则该索引称之为查询SQL的覆盖索引
只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快
https://zhuanlan.zhihu.com/p/107125866

select * 要禁止使用
https://blog.csdn.net/qq_38836118/article/details/88708933?biz_id=102&utm_term=%E5%B0%B1%E4%BC%9A%E5%8D%81%E5%88%86%E7%BC%93%E6%85%A2%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BC%9A%E9%80%A0%E6%88%90%E9%A2%9D%E5%A4%96%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BC%80%E9%94%80&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-88708933&spm=1018.2118.3001.4449
为什么还是不推荐select * ?
1. 网络IO问题
    select * 会查询出不需要的、额外的数据，那么这些额外的数据在网络上进行传输，
    必定会造成性能延迟。假设你的table中，有一个列的类型为binary。此时，你的select *操作，
    就会十分缓慢，并且会造成额外的网络开销
2. 索引问题

3. 扩展性问题

innodb中一条sql语句只会用到一个索引

聚簇(聚集)索引
* 如果表设置了主键，则主键就是聚簇索引
* 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引
* 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引

数据库中的每张表只能有一个主键，不可能有多个主键

联合索引、联合主键

SQL常用优化规则
1. SQL的查询一定要基于索引完成SQL的结果集扫描
2. 避免索引列上使用函数或者运算，这样会导致索引失效
3. 避免列的隐式转换
4. where 子句中like 模糊匹配%, %放置在查询条件右边
5. 使用索引扫描，联合索引中的列从左往右，命中越多越好
6. 尽可能使用SQL语句用到的索引完成排序，避免使用文件排序的方式
7. 查询有效的列信息即可。少用*代替列信息

MVCC
NIO
DML DDL  Lexical
DBA
show engines\G;  //列出mysql引擎

存储引擎
1. 存储引擎用于修饰表
2. 默认存储引擎是innodb
3. 存储引擎是插拔式的，可随时加载和卸载

csv存储引擎
1. 不能定义索引、列定义必须为not null, 不能设置自增列
2. csv表的数据的存储格式用‘,’隔开，可直接编辑文件进行数据的编排
3. 数据安全性低

archive存储引擎
1. 压缩协议(ARZ文件格式)进行数据的存储，磁盘占用少
2. 只支持insert和select两种操作
3. 只允许自增ID列建立索引

应用场景:
    1.数据备份系统(如:日志系统，文档归档等)
    2.大量设备高频的数据采集

memory存储引擎
特点:
    1. 数据都是存储在内存中，处理效率高，表大小限定默认16M
    2. 不支持大数据存储类型的字段如 blog text varchar(n)->char(n)
    3. 支持hash索引，等值查询效率高
    4. 数据的可高性低，重启或系统崩溃数据丢失
应用场景:
    1. 热点数据快速加载(功能类似缓存中间件)
    2. MySQL临时表存储(查询结果于内存中计算的数据)

Myisam存储引擎
    1.较快的数据插入和读取性能
    2.数据存储具有较小的磁盘空间占用
    3.支持表级别的锁，不支持事务
    4.数据文件与索引文件分库存储。主键索引与辅助索引同级
    5.针对数据统计有额外的常数存储。故而count(*)的查询效率很高
  应用场景:
    只读应用或者以读为主的业务

Innodb存储引擎
   1. 支持事务
   2. 行级锁
   3. 聚集索引
   4. 外键支持，保证数据的完整性
  
  应用场景
     无脑选择

DQL  数据查询语言     select 
DML  数据操纵语言     update insert delete
DDL  数据定义语言     create table/view/index ...
DCL  数据控制语言     grant

通讯方式:
    长连接    半双工

单工： 类似于电视的遥控器
全双工: 类似于两个人打电话
半双工： 类似于对讲机

mysql> show variables like 'max_allowe%';
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| max_allowed_packet | 67108864 |
+--------------------+----------+

max_allowed_packet //客户端向服务端发送sql语句的最大大小


// 查看所有连接
mysql> show full processlist;
+----+-----------------+-----------+--------+---------+---------+------------------------+-----------------------+
| Id | User            | Host      | db     | Command | Time    | State                  | Info                  |
+----+-----------------+-----------+--------+---------+---------+------------------------+-----------------------+
|  5 | event_scheduler | localhost | NULL   | Daemon  | 1474276 | Waiting on empty queue | NULL                  |
| 33 | root            | localhost | choose | Query   |       0 | starting               | show full processlist |
+----+-----------------+-----------+--------+---------+---------+------------------------+-----------------------+


// 查看所有线程
mysql> show status like 'Thread%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_cached    | 0     |
| Threads_connected | 1     |
| Threads_created   | 1     |
| Threads_running   | 2     |
+-------------------+-------+

kill id    // 杀掉连接  id为上上图列举的Id

mysql> show variables like 'max_connections';    //查看最大连接数
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)

查询缓存(鸡肋)
    缓存失效与表数据是一致的.即表数据发生任何改动都将让缓存失效
    需要手工开启。在MySQL5.6以后默认关闭了查询缓存功能
    判断条件苛刻.SQL语句必须完全一致
    带来额外的性能消耗。数据的返回过程中若开启了缓存需先缓存SQL和结果

optimizer(优化器)
  找到执行SQL最优的执行计划
  基于此计划通过执行引擎调用各存储引擎执行数据操作

物理优化
    1. 等价变化规则
    2. 基于联合索引调整查询条件位置
    ....

逻辑优化
    1. 针对不同引擎优化count min max等相关函数
    2. 针对覆盖索引扫描优化
    3. 针对冗余子查询的优化
    4. 执行SQL提前终止查询
    5. WHERE字句中in的条件优化  全盘扫描的方式
    6. ...


mysql> desc select count(*) from choose\G;  // 查看sql执行计划 explain也可以
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: choose
   partitions: NULL
         type: index
possible_keys: NULL
          key: choose_course_fk
      key_len: 4
          ref: NULL
         rows: 7
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
mysql> 

执行计划-id
SQL执行的序号，一组数字表示查询中执行select字句或操作的顺序
id相同:执行顺序由上至下

SQL执行类型，包含(普通查询、联合查询、子查询等)
Simple          简单查询
PRIMARY         最外层查询
SUBQUERY        子查询
UNION           连接查询
UNION RESULT    连接查询的结果集

执行计划-table
    查询涉及到的表或者表的别名
    <unionM, N>  查询id为M和N两个结果的并集结果
    <derivedN>   查询id为N的派生表结果集
    <subqueryN>  查询id为N的子查询结果集

执行计划-type
SQL执行数据获取的方式
SQL执行优化中一个很重要的指标，评测SQL最直观的参数
取值:
    system
    const    唯一性索引(主键和唯一索引 unique key)常量比较
    eq_ref   唯一性索引扫描
    ref      普通索引扫描
    range    基于索引的范围查找
    index    full index scan    基于index扫描
    all      full table scan    全表扫描

    system > const > eq_ref > ref > range > index > all    性能排序












primary      主要的；
distinct     截然不同的；
unique       独特的
    










    