1 .Lua 在游戏领域被广泛运用只是 Lua 被所有领域广泛应用的显现。比如说 Adobe Photoshop Lightroom 的 40% - 60% 由 Lua 写成.
2 .lua是一个简单，高效所以在游戏逻辑开发和服务器开发中（ngx_lua）得到广泛的应用

优势
1）lua是一个免费、小巧、简单、强大、高效、轻量级的嵌入式的脚本语言,lua当前的发行版本5.3.1只有276k。
2）它是用C语言开发的项目，所以可以在大部分的操作系统上运行
3）lua是目前速度最快的脚本语言，既可以提升语言的灵活性还可以最大限度的保留速度
4）其语法非常简单，没有特例
5）lua还可以作为C的API来使用

不足和不同
1）lua没有强大的库，所以很多功能实现起来没有python、perl、ruby等脚本语言简洁
2）lua的异常处理功能饱受争议，虽然其提供了pcall和xpcall的异常处理函数
3）lua原生语言中没有提供对unicode编码的支持，虽然可以通过一些折中的办法实现 http://www.cppblog.com/darkdestiny/archive/2009/04/25/81055.html
4）没有提供在C++中应用很广泛的a?b:c的三元运算符操作
5）没有switch...case...语法，只能通过if..elseif..elseif..else..end的方式折中实现
6)在循环时没有提供continue语法
7）没有C++中应用广泛的a++和a+=1等操作
8）lua的索引是从1开始的，而不是我们熟悉的0（string，table）
9）当你给一个元素赋值为nil时相当于这个元素不存在
10）lua的数值类型只有number是没有int，float，double等之分的
11）lua中没有类的概念，其类是通过table的形式来实现的
12）lua中只有nil和false是表示假的，零在lua中是为真的
13）很多程序需要（）标示才能运行，比如a={["b"]=5},print(a.b)是可运行的，但是 {["b"]=5}.b就会报错，需要（{["b"]=5}）.b才可以


3 int lua_gettop (lua_State *L)  返回栈顶元素的索引。 因为索引是从1开始编号的， 所以这个结果等于堆栈上的元素个数（因此返回 0 表示堆栈为空）。
4 void lua_settop (lua_State *L, int index);  
  解释：参数允许传入任何可接受的索引以及 0 。 它将把堆栈的栈顶设为这个索引。 
  如果新的栈顶比原来的大，超出部分的新元素将被填为 nil 。 如果 index 为 0 ，把栈上所有元素移除
  
5 int luaL_loadfile (lua_State *L, const char *filename); 加载某个文件  
  //仅加载lua代码块，但是并不运行。如果成功，会加载一个编译好的代码块作为一个匿名函数放置在栈顶。
  //只有首先执行这个代码块，lua的vm才能最终知道各函数、变量等信息 (lua_pcall)

6 int luaL_dofile (lua_State *L, const char *filename);  加载并运行某个文件

7 int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
  nargs 参数个数
  nresults 返回值个数
  errFunc 错误处理函数，0表示无，表示错误处理函数在栈中的索引

8 void lua_pushcfunction (lua_State *L, lua_CFunction f);
　　将C函数压栈；
　　接收一个C函数的指针参数，然后将一个Lua.function类型的对象压栈
   typedef int (*lua_CFunction) (lua_State *L);  返回的int值表示C函数返回值的个数

9  lua文档  
   https://www.codingnow.com/2000/download/lua_manual.html
   https://itbook.xuxinkai.cn/read/lua-5.3/spilt.32.spilt.1.5.md
   
   https://www.cnblogs.com/chenny7/p/3993456.html     ×××
   https://www.wenjiangs.com/doc/lual_loadbuffer

10 Lua判断OS并添加cpath

Lua初始化时需要根据OS来设置package.cpath,
如果是Windows系统则添加 ?.dll, 否则添加 ?.so.
不然加载错误后缀名的动态库会报错。

local function add_package_cpath(subDir)
    if is_windows then
        package.cpath = package.cpath..";"..G_LUA_ROOTPATH.."/"..subDir.."/?.dll"
    else
       package.cpath = package.cpath..";"..G_LUA_ROOTPATH.."/"..subDir.."/?.so"
    end
end
Lua没有提供OS判断功能，所以利用 package.config 中的目录分隔符来判断。
-- return true if os is windows
local function get_is_windows()
    return "\\" == package.config:sub(1,1)
end
local is_windows = get_is_windows()

11 lua_pcall(lua_State *L,int nargs,int nresults,int errfunc)
   nargs 参数个数  nresults 返回值个数  errFunc 错误处理函数，0表示无，表示错误处理函数在栈中的索引
   
--test.lua
function test(x,y)
    return x + y
end
---调用
lua_loadfile(L,"test.lua");
lua_pushnumber(L,10);   --x 值入栈
lua_pushnumber(L,20);   --y 值入栈
lua_pcall(L,2,1,0);    如果没有错误此时栈顶的值为30 
如果运行出错，lua_pcall会返回一个非零的结果,如果指定了错误处理函数会先调用错误处理函数，然后再将错误信息入栈，在将返回结果和错误信息入栈之前会先将函数和参数从栈中移除。
错误处理函数必须在被调用函数和其他参数之前入栈

12  在C和LUA之间交互的关键在于一个虚拟栈(virtual stack)，数据交互通过栈进行。操作数据时，首先将数据拷贝到栈上，然后获取数据，
    栈中的每个数据通过索引值进行定位，索引值为正时表示相对于栈底的偏移索引，索引值为负时表示相对于栈顶的偏移索引。
	索引值以1或 -1起始值，因此栈顶索引值永远为-1, 栈底索引值永远为1 。
	
13 正则表达式  

.        任意字符
%a        字母
%c        控制字符
%d        数字
%l        小写字母
%p        标点字符
%s        空白符
%u        大写字母
%w        字母和数字
%x        十六进制数字
%z        代表0的字符 
上面字符类的大写形式表示小写所代表的集合的补集。例如, '%A'非字母的字符   ^

% 用作特殊字符的转义字符  '%%'匹配字符 %


Lua中的模式修饰符有四个
+        匹配前一字符1次或多次
*        匹配前一字符0次或多次
-        匹配前一字符0次或多次  进行的是最短匹配
?        匹配前一字符0次或1次
[ ]      集合

^	匹配字符串开头
$	匹配字符串结尾

()	表达式中用小括号包围的子字符串为一个分组，分组从左到右（以左括号的位置），组序号从1开始递增。

你可能更喜欢使用'[0-7]'而不是'[01234567]'。你可以在字符集(char-set)的开始处使用 `^′ 表示其补集: '[^0-7]' 匹配任何不是八进制数字的字符
%b'用来匹配对称的字符.常写为 '%bxy',x和y是任意两个不同的字符；x作为匹配的开始,y作为匹配的结束。比如， '%b()'匹配以`(′开始， 以 `)′结束的字符串:
常用的这种模式有： '%b()', '%b[]', '%b%{%}',和 '%b<>'。你也可以使用任何字符作为分隔符

------------------------------------------------------------
------------------------------------------------------------
在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：
( ) . % + - * ? [ ^ $
'%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。

模式条目可以是：

单个字符类匹配该类别中任意单个字符；
单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；
单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；
单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；
单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；
%n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。
%bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 
最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。
%f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\0' 一样。
模式：
模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。
捕获：
模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 "(a*(.)%w(%s*))" ， 
字符串中匹配到 "a*(.)%w(%s*)" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 "." 匹配到的字符是 2 号捕获物， 匹配到 "%s*" 的那部分是 3 号。
作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 "()aa()" 作用到字符串 "flaaap" 上，将产生两个捕获物： 3 和 5 。


14  文件io  从当前位置读取整个文件。例：file.read("*a")

15  os.getenv(variable)  返回环境变量的值，如果不存在，返回nil  区分大小写

16 assert(v [, message])
   当参数v的值是false或者nil的时候展示一个错误，否者返回所有的参数值。
   其中参数message表示一个错误信息，这个参数的默认值是assertion failed！
   local ret, ret2 = assert(100 > 99, "I can't believe")

17 string.gsub 替换函数 
   		local str = "我是一只小菜鸡\n说的很有道理"
   		local temp = string.gsub(str,"\n",",")
   		print(temp)   ---我是一只小菜鸡,说的很有道理
		
  string.gsub(code, [[%$([%w_%d]+)]], getenv) 
  function getenv(name) return assert(os.getenv(name), [[os.getenv() failed: ]] .. name) end
 
18 load函数 load的本质就是在Lua代码中运行一段存储在字符串中的代码
   load (chunk [, chunkname [, mode [, env]]])
   加载一个代码块。

	如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。
	每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。
	如果没有语法错误， 则以函数形式返回编译好的代码块； 否则，返回 nil 加上错误消息。
	如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。 所有其它上值初始化为 nil。 
	（当你加载主代码块时候，结果函数一定有且仅有一个上值 _ENV （参见 §2.2））。 
	然而，如果你加载一个用函数（参见string.dump， 结果函数可以有任意数量的上值） 创建出来的二进制代码块时，所有的上值都是新创建出来的。 也就是说它们不会和别的任何函数共享。
	chunkname 在错误消息和调试消息中（参见 §4.9），用于代码块的名字。 如果不提供此参数，它默认为字符串chunk 。 chunk 不是字符串时，则为 "=(load)" 。
	字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 "b" （只能是二进制代码块）， "t" （只能是文本代码块）， 或 "bt" （可以是二进制也可以是文本）。 
	默认值为 "bt"。Lua 不会对二进制代码块做健壮性检查。 恶意构造一个二进制块有可能把解释器弄崩溃
	
19 
number 实数 ,可以是整数，浮点数
string 字符串，一旦赋值不能被修改，可以通过方法string.gsub()来修改
nil 全局变量没被赋值默认为nil，删除变量就赋值为 nil
boolean(bool) false 和nil为假 ，其它都为真
function 函数
table 数组、容器
userdata （类，其它语言转换过来就变成userdata类型）
thread 线程
  
20 lua_settop(L, 0); 重新设置栈底

21 local  局部变量   

22 lua 变量默认为局部变量     不存在的变量值是nil

23  循环 repeat     until

24 求幂  ^

25 数学运算符  ==    ~=   >   <   >=   <=

26 逻辑运算符  and  or  not  

27 多行字符串  [[ ]]

28 转义字符

29  pairs可以遍历表中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil;
      但是ipairs则不能返回nil,只能返回数字0，如果遇到nil则退出。
      它只能遍历到表中出现的第一个不是整数的key

30 元表扩充了普通表的行为

31 __newindex  给表添加新的数据的时候

32 rawset( )

33 coroutine.create

34 携程函数只能执行一次？

35    package.path = '/usr/local/share/lua/5.1/?.lua;/home/resty/?.lua;'    --搜索lua模块
        package.cpath = '/usr/local/lib/lua/5.1/?.so;'        --搜索so模块

36  Lua设置搜索路径package.path和package.cpath
     
--方法1 只加载想要的目录
package.path = "../myLuaTest/myLuaCode/?.lua;"
--方法2 增加目录
package.path = "../myLuaTest/myLuaCode/?.lua;"..package.path


37  协议中有2个关键字可以控制方法是否要实现(默认是@required，在大多数情况下，用途在于程序员之间的交流) 
    @required：这个方法必须要实现（若不实现，编译器会发出警告）
    @optional：这个方法不一定要实现
    @repeated 代表可重复，我们可以理解为数组

38 compat  n. 兼容

39 luaL_newstate()  lua_newstate(arg1, arg2)  //创建新的虚拟机

40 二 require加载模块文件的策略
如果模块文件曾经被加载过，我们不会傻傻的再加载一次模块。所以加载模块要遵循一定的规则，也就是策略。这个策略是：
1 首先查找package.loaded表，检测是否被加载过。如果被加载过，require返回保存的值，这个值在哪里被保存后面会讲到。否则进行下面的为模块寻找加载器。
2 加载器在package的searchers表中，共有四个加载器。require也按照顺序来执行加载器。找到了就成功返回，没有就继续查找。
a   预加载器，执行package.preload[modname]，一些特殊模块会有预加载器。
b  lua加载器查找前面介绍的package.path
c  加载器查找package.cpath
d  一体化加载器，这个在后面会有详细解释。

三 加载器如何加载
由于路径是一个包含有一系列以；分隔的模版构成的字符串，所以在加载器加载文件时，首先将每个路径模版用模块名字替换其中的？,然后尝试打开这个文件名。例如，如果路径字符串是
"./?.lua;./?.lc;/usr/local/?/init.lua"
require('foo')，将会依次尝试打开文件./foo.lua,./foo.lc,以及/usr/local/foo/init.lua。如果模块名包含.，例如require('foo.a')那么将会依次尝试打开文件
./foo/a.lua,./foo/a.lc,以及/usr/local/foo/a/init.lua。
同理，如果这一步没有找到，则以同样的方式查找cpath。例如cpath是这个字符串
 
"./?.so;./?.dll;/usr/local/?/init.so"
查找器查找模块 foo 会依次尝试打开文件 ./foo.so，./foo.dll， 以及 /usr/local/foo/init.so。 一旦它找到一个 C 库， 查找器首先使用动态链接机制连接该库。
然后尝试在该库中找到可以用作加载器的 C 函数。 这个 C 函数的名字必须是 "luaopen_" 紧接模块名的字符串，其中字符串中所有的下划线都会被替换成点。
此外，如果模块名中有横线， 横线后面的部分（包括横线）都被去掉。 例如，如果模块名为 a.b.c-v2.1， 函数名就是 luaopen_a_b_c。
也就是不仅提供的c模块名字要和require的模块名字一致，而且c模块导出的函数也要符合规范才行。如果有该模块而函数名对不上则会出现如下错误
lua loader error : error loading module 'xxx' from file './luaclib/xxx.so'。
最后一个搜索器是一体化加载器。本质上他是cpath加载器的延伸。他允许多个导出函数绑定在一个c库里。例如require('foo.a')，上述加载器都没有加载到，
那么试图加载foo模块(过程和上面一样)，然后再在foo里寻找luaopen_foo_a导出函数。
lua为我们提供了在指定path中搜索模块的函数，package.searchpath(),过程上述已讲。

如果require('mod')成功，则在package.loaded['mod']中记录该模块。如果该模块没有返回值则package.loaded['mod']==true,有返回值则记录的是其返回值。
值得注意的是，在同一个lua虚拟机中，多次require同一个模块，该模块返回一个table，那么任何地方修改该table的值都会引起其他地方table值的改变

https://blog.csdn.net/zxm342698145/article/details/80607072

41  https://www.jishuchi.com/read/lua-5.3/1984

42  void luaL_newlib (lua_State *L, const luaL_Reg l[]); 
    创建一张新的表，并把列表 l 中的函数注册进去。
43  void *lua_newuserdata(lua_State*L,size_t size) 
    在C中调用函数lua_newuserdata会根据指定的大小分配一块内存，并将相应的userdata压入栈中，最后返回这个内存块的地址：。

44  创建闭包 关键函数是int lua_pushcclosure(lua_State *L,lua_CFunction func,int n )，
    其中n是堆栈顶端值得个数，这些值将复制到closure中，func是使用closure的函数，这个函数调用后会清除栈中n个值，会压入一个closure到栈中
    
    2，访问upvalue
        当一个closure被调用，这个closure指定的函数就能通过upvalueindex索引访问所有upvalue。
        比如:
            int num=lua_tointeger(L,lua_upvalueindex(1));//获得第一个upvalue的值
            int table_len=lua_objlen(L,upvalueindex(2));//获得第二个upvalue的长度
            puts(lua_tostring(L,lua_upvalueindex(3)));//输出第三个upvalue

45  LPEG是一个供lua使用的基于 Parsing Expression Grammars 的模式匹配库.

46  void lua_setfield(lua_State *L, int index, const char *k);

47  堆栈
           -----
      4   |     |  -1
           -----
      3   |     |  -2
           -----
      2   |     |  -3
           -----
      1   |     |  -4
           -----
             
48  (1)原型 void lua_setfield (lua_State *L, int index, const char *k);
    (2)作用
        在lua脚本中表达的操作是：t[k] = v.  index指明了t在栈中的位置（说明：栈中首先要有表t），k代表了t的下标，v代表了赋予的值（即：放置在栈顶的元素） 
    (注：调用这个函数之前，栈中应该有：表t 和 栈顶元素v)
    (3)对栈的操作
       调用完成后，会将栈顶元素v弹出

49  void luaL_checkversion (lua_State *L);
    检查调用它的内核是否是创建这个 Lua 状态机的内核。以及调用它的代码是否使用了相同的 Lua 版本。
    同时也检查调用它的内核与创建该 Lua 状态机的内核是否使用了同一片地址空间。

    https://blog.codingnow.com/2012/01/lua_link_bug.html
    何在出现这个问题时立刻检查出问题呢?
    可以在每个为 lua 写的 C 扩展库的第一行调用一下 luaL_checkversion , 它可以检查有没有多次链接 lua 库, 以及其它一些版本问题.

50  
..	连接两个字符串	a..b ，其中 a 为 "Hello " ， b 为 "World", 输出结果为 "Hello World"。
#	一元运算符，返回字符串或表的长度。	#"Hello" 返回 5

and	逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。	(A and B) 为 false。
or	逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。	(A or B) 为 true。
not	逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。	not(A and B) 为 true。


local type = [[
    .Person {
        name 0 : string
        id 1 : integer
        email 2 : string
    
        .PhoneNumber {
            number 0 : string
            type 1 : integer
        }
    
        phone 3 : *PhoneNumber
    }
    
    .AddressBook {
        person 0 : *Person(id)
        others 1 : *Person
    }
    
    ]]
    
local pro = [[
    testprot 1 {
        request {
            p       0 : Person
            addr    1 : AddressBook
        }
        response {
            ret      0 : integer
        }
    }
]]

51  可变参数
    Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 ... 表示函数有可变的参数。

    function add(...)  
    local s = 0  
      for i, v in ipairs{...} do   --> {...} 表示一个由所有变长参数构成的数组  
        s = s + v  
      end  
      return s  
    end  
    print(add(3,4,5,6,7))  --->25

52 .. 链接两个字符串

53  int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name);
Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz.
This function returns the same results as lua_load(). name is the chunk name, used for debug information and error messages.

54  int luaL_loadbufferx (lua_State *L, const char *buff, size_t size, const char *name, const char *mode)
    类似于luaL_loadbuffer()

55  Lua 字符串
    字符串或串(String)是由数字、字母、下划线组成的一串字符。
    Lua 语言中字符串可以使用以下三种方式来表示：
    单引号间的一串字符。
    双引号间的一串字符。
    [[ 与 ]] 间的一串字符

56  include    作用应该是把某个文件所有的内容包含进来。

57   lua load()
local function loadconfig(tmp)
if tmp == nil then
    tmp = {}
    if config_name then
        local f = assert(io.open(config_name))
        local source = f:read "*a"
        f:close()
        assert(load(source, "@"..config_name, "t", tmp))()
    end
end
for name,address in pairs(tmp) do
    assert(type(address) == "string")
    if node_address[name] ~= address then
        -- address changed
        if rawget(node_channel, name) then
            node_channel[name] = nil    -- reset connection
        end
        node_address[name] = address
    end
end
end

58  string.gsub
函数原型 string.gsub(s, pat, repl [, n])
就是 global 全局替换子字符串的意思
s: 源字符串
pat: 即 pattern， 匹配模式
repl: replacement， 将 pat 匹配到的字串替换为 repl
[, n]: 可选， 表示只看源字符串的前 n 个字符

59 metatable
__index 元方法, 这是 metatable 最常用的键。
当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）
中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键

60 lua_getglobal()

int main(int argc, char *argv[])
{
    const char* buf = "background = {r=30, g=10, b=0} ";
    lua_State* L = luaL_newstate();
    luaL_dostring(L, buf);
    lua_getglobal(L, "background");//获取全局变量的background的值,并将其放入栈顶
    if (!lua_istable(L, -1))//判断是否是table
    {
        
    }
    int red = getfield("r", L);
    int green = getfield("g", L);
    int black = getfield("b", L);

    getchar();

    return 0;
}

61lua_pop(L,num)函数从栈顶开始移除。

当num>0时从栈顶移除指定个数 。
 当num=0时栈不受影响
当num=-1时栈中元素全部移除 
其他负数逻辑就有点乱了，建议不要使用其他(<-1)负值。最终的解释权还得看lua_settop.

61  lua_setglobal
(1)原型
    void lua_setglobal (lua_State *L, const char *name);
(2)作用
    将栈顶元素赋值给name变量。(name参数的值，是lua脚本中全部变量的名字。)
    (注：调用完函数，我们调用luaL_dofile,然后我们就可以在lua脚本中打印出_G表中内容，会发现name名字的变量正在其中，所以可以在lua脚本中操作该name名变量)
(3)对栈的操作
    调用完成后，会将栈顶元素弹出

62  lua_getglobal
(1)原型
    void lua_getglobal (lua_State *L, const char *name);
(2)作用
    从lua脚本中获取一个name参数描述的变量，放到栈顶
(3)对栈的操作
  将获得的变量，放置到栈顶 

63  lua_setfield
(1)原型
    void lua_setfield (lua_State *L, int index, const char *k);
(2)作用
    在lua脚本中表达的操作是：t[k] = v.  index指明了t在栈中的位置（说明：栈中首先要有表t），k代表了t的下标，v代表了赋予的值（即：放置在栈顶的元素） 
(注：调用这个函数之前，栈中应该有：表t 和 栈顶元素v)
(3)对栈的操作
    调用完成后，会将栈顶元素v弹出。

64  lua_getfield
(1)原型
    void lua_getfield (lua_State *L, int index, const char *k);
(2)作用
    取t[k]的值放到栈顶，index指出栈中t表的位置， k为t的key值
(3)对栈的操作
    放置t[k] 的值到栈顶
65  lua_push*
(1)原型 
    lua_pushnil(lua_State *L, xxx)
    lua_pushstring(lua_State *L, xxx)
    lua_pushnumber(lua_State *L, xxx)
    lua_pushinteger(lua_State *L, xxx)
(2)作用
    放置xxx元素到栈顶
(3)对栈的操作
    放置一个元素到栈顶

66  lua_to*
(1)原型
(2)作用
    将index指明位置上的元素转换为对应类型返回
(3)对栈的操作
    不会改变栈的大小，内容.
67  lua_is*
(1)原型
    int  lua_isstring(lua_State *L, int index)
    ...
(2)作用
    判断index指明位置上的元素是为对应的*类型，这里是string.  如果是则返回1，否则返回0
(3)对栈的操作
    不会改变栈的大小，内容
68  lua_pcall
(1)原型
    lua_pcall(lua_State *L, int nargs, int nresults, int errfunc);
(2)作用
    调用函数.nargs指明了参数的个数，nresults指明了返回结果的个数，errfunc指明了发生错误的处理函数
(注：调用lua_pcall之前，我们应该先：放置一个函数到栈中（可用：lua_getglobal）,然后压入要传递的参数（可用：lua_push*）)
(3)对栈的操作
    调用lua_pcall之后，它会首先将栈中的：函数，参数全部弹出 ； 然后：将结果一次压入栈中。
69.lua_gettop
(1)原型
    int lua_gettop (lua_State *L);
(2)作用
    获取栈中的元素个数
(3)对栈的操作
    不会修改栈的内容和大小
70.lua_settop
(1)原型
    void lua_settop (lua_State *L, int index);
(2)作用
    如果新传入的index比原来的栈顶大，那么超出的元素被填入nil. 可以传入0，那么栈将会被清空
(3)对栈的操作
    会修改栈的大小
71  lua_pop
(1)原型
    void lua_pop (lua_State *L, int n);
(2)作用
    从栈中弹出n个元素
(3)对栈的操作
    从战中弹出n个元素

72  lua_settable
(1)原型
    void lua_settable (lua_State *L, int index);
(2)作用
    t[k] = v的作用， index指明了栈中t表的位置，v是栈顶的值，k是栈顶之下的那个值
(3)对栈的操作
    调用这个函数之后，会将v和k的值从栈中弹出。
73  lua_gettable
(1)原型
    void lua_gettable (lua_State *L, int index);
(2)作用
    将t[k]的值放到栈顶， index指明栈中t表的位置， k从何而来呢？调用这个函数时，k代表了在栈顶元素。
(3)对栈的操作
    调用这个函数后，会将k从栈顶弹出，然后再把t[k]值放到栈顶
74  lua_next() 这个函数的工作过程是：
1) 先从栈顶弹出一个 key
2) 从栈指定位置的 table 里取下一对 key-value，先将 key 入栈再将 value 入栈
3) 如果第 2 步成功则返回非 0 值，否则返回 0，并且不向栈中压入任何值
第 2 步中从 table 里取出所谓“下一对 key-value”是相对于第 1 步中弹出的 key 的。table 里第一对 key-value 的前面没有数据，所以先用 lua_pushnil() 压入一个 nil 充当初始 key。
注意开始的时候先用 lua_gettop() 取了一下 table 在栈中的正索引（前面说过了，在进行这个 lua_next() 过程之前先将 table 入栈，所以栈大小就是 table 的正索引），后面的 lua_next() 
过程中不断的有元素出入栈，所以使用正索引来定位 table 比较方便。
到了 table 中已经没有 key-value 对时，lua_next() 先弹出最后一个 key，然后发现已经没有数据了会返回 0，while 循环结束。所以这个 lua_next() 过程结束以后 table 就又位于栈顶了

75  lua_close
代码：LUA_API void lua_close (lua_State *L) {
销毁指定虚拟机的所有对像（如果有垃圾回收相关的无方法则会调用该方法）并收回所有由该虚拟机动态分配产生的内存，在有些平台下我们不需要调用此函数，因为当主程序退出时，
资源会被自然的释放掉，但是但一个长时间运行的程序，比如后台运行的web服务器，需要立即回收虚拟机资源以避免内存过高占用