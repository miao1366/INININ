1. hash碰撞解决方法
   a. 开放地址法 (线性探测  、二次探测)
      开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k<=m-1)
      基本思想：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止
   b. rehash (再hash法)
      使用第二个或第三个...计算地址，直到无冲突。比如：按首字母进行hash冲突了，则按照首字母第二位，进行hash寻址
   c. 链地址法（拉链法）   
      创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
      java hashmap使用的就是拉链法解决hash碰撞

      双重散列和多重散列就是第一个哈希公式冲突后再用第二个或者更多的哈希公式去算地址

2. 数组地址
   记住二维数组中元素a[i][j]的地址为：  a[i]+j=*(a+i)+j=&a[i][j]      //  *(a+i*4+j)                *(*(a+i)+j)  a = &a[0]

   对于a[row]，a是一维数组的首地址，*(a+1) = a[1];
   对于a[row][col],将其视为(a[row])[col],那么a[row]就是(a[row])[col]的首地址，*(a[0] + 1) = a[0][1];
   那么对于(a[row]) [col]，a代表什么呢？让我们变换一下：
   (a[row]) [col] = (*(a+row) )[col] =*(*(a+row) + col) 
   这样看，a[row]是不是很像一个指针数组，它的内部元素全部是指针，a[0]即指向第0行的指针，a[1]即指向第一行的指针。
   这样理解a也就比较容易了，可以把它当做数组a[row]的首地址，即 a = &a[0]，于是乎 *(a+row) = a[row]

3. 一棵完全二叉树第六层有9个叶结点（根为第一层），则结点个数最多有（）  //109 
   方法一:
       根据二叉树的性质,第i层上的结点数最多为2^i(i >= 0,所以第一层为i=0)个,所以第六层的结点数最多为2^5=32个,根据题意第六层有9个叶子结点,
       推测出还有第七层,所以第六层结点数减去9个叶子结点,剩下的23个结点都有左右子树,故第七层有23*2=46个结点,总的结点数=2^0+2^1+2^2+2^3+2^4+2^5+46=109个
   方法二:
       总结点数=七层总结点数-第六层叶子结点数*2=(2^7-1)-9*2=109个
4. 在 TCP/IP 参考模型中 TCP 协议工作在（） // 传输层 
   TCP(传输控制协议)和 UDP(用户数据报协议)。其中，TCP是一个可靠的面向连接的协议，udp是不可靠的或者说无连接的协议
   OSI参考模型：（高到低）应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

5  假设二叉排序树的定义是：1、若它的左子树不为空，则左子树所有节点均小于它的根节点的值；2、若右子树不为空，则右子树所有节点的值均大于根节点的值；
   3、它的左右子树也分别为二叉排序树。下列哪种遍历之后得到一个递增有序数列（）  //中序遍历

6  假设用于通信的电文由 5 个字母组成，字母在电文中出现的频率分别为 2,4,5,7,8 根为第一层，用这 5 个字母设计哈弗曼树带权路径长度为（） //58
     构成赫夫曼树的步骤：
     1)从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
     2)取出根节点权值最小的两颗二叉树
     3)组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
     4)再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

7.  查找表结构用以下哪一项   //  desc tabl_name
8.  java system.gc可以提醒垃圾回收执行，不能强制 , 没有方法可以强行回收垃圾，只能提高优先级

9.  ARP（Address Resolution Protocol）地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议；
    RARP（Reverse Address Resolution Protocol）反向地址转换协议
   
10.   集线器：物理层
     交换机：数据链路层
     路由器：网络层
     从通信协议的角度来看，路由器是在哪个层次上实现网络互连的？  //网络层

     ICMP：控制报文协议，用于在IP主机和路由之间传递控制信息  在TCP/IP体系结构中，直接为ICMP提供服务的协议是___    //ip
     
11    栈：后进先出
    队列：先进先出
    元素 a，b，c，d，e 依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素 d 开头的序列个数是  // 4

12.  地址是否固定要看系统配置和编译选项，如果开启了地址随机化，那地址是每次都变的，如果没开启，那么地址每次都一样

13.  四次挥手
     client 发送 FIN 给 server 进入 FIN_Wait1
     server 接受client的FIN,发送ACK给client 进入close_wait，client接收到进入FIN_wait2
     server 发送FIN给client 进入last_ack状态,client接收到进入time_wait状态
     client 发送ACK给server,有2MSL的等待时间，保证连接的关闭，client进入close状态，server接收到进入close状态
   
14. TCP建立连接要进行3次握手,而断开连接要进行4次
1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
3 由B 端再提出反方向的关闭请求,将FIN置1
4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端
和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础
名词解释
ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段
都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
SYN  同步序列号,TCP建立连接时将这个位置1
FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

15. 只有执行主动关闭端才会出现TIME_WAIT

16. 给定一个整型数组L，数组长度为n，数组元素取值范围[1,n],（n>2000)，
    请问最快速找出一个缺失值的时间复杂度是多少？    //  O(n)

17.  已知一个线性表（38，25，74，63，52，48），假定采用散列函数h（key) = key%7计算散列地址，并散列存储在散列表A【0....6】中，
     若采用线性探测方法解决冲突，则在该散列表上进行等概率成功查找的平均查找长度为
     
     平均查找长度=总的查找次数/元素数
     总的查找次数： 38%7=3 （第1次出现3，无冲突，放在位置3，查找次数为1）
     25%7=4（第1次出现4，无冲突，放在位置4，查找次数为1）
     74%7=4（第2次出现4，有冲突，放在位置5，查找次数为2）
     63%7=0（第1次出现0，无冲突，放在位置0，查找次数为1）
     52%7=3（第2次出现3，有冲突，发现冲突3,4,5，故只能放到6，查找次数为4）
     48%7=6 （第1次出现6，有冲突，发现冲突6,0，故只能放到1，查找次数为3）
     1+1+2+1+4+3=12
     元素数=6
     所以：平均查找长度=12/6=2
    
18. 实现底层为红黑树的set、multiset、map、multimap    // multimap  multiset key值可以重复

     multimap<string,int> multimapSTRint;
     multimapSTRint.insert(make_pair("strtrest",125));
     multimapSTRint.insert(make_pair("strtrest",126))
     typedef multimap<string,int>::iterator iterTest;
     iterTest beg = multimapSTRint.lower_bound("strtrest");
     iterTest end = multimapSTRint.upper_bound("strtrest");
     while(beg != end)
     {
      int Nstr = beg->second;
      ++beg;
     }

19. 二叉搜索树中序遍历得到升序

20. 首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法

21. 20. DNS欺骗攻击: 冒充域名，把原来查询的ip改为其他IP
DDoS攻击：Dos攻击叫拒绝服务攻击，如向一台服务器发送大量的IP数据报，使服务器要花很多时间处理所接收到的数据报，导致合法用户被拒绝服务
SYN Flooding: SYN Flooding攻击和TCP的三次握手过程有关。三次握手过程大概是：一、客户端发送SYN给服务器，此时服务器内部会建立请求控制块；
    二、服务器响应SYN/ACK给客户端；三、客户端收到SYN-ACK之后向服务器发送ACK，服务器收到最后一个握手ACK报文后，控制块会转换成为正式的连接控制块。
    如果迟迟未收到最后的那个ACK报文，服务器会通过定时器重发SYN-ACK，直至超时，销毁请求控制块；SYN Flooding攻击是通过伪造的IP地址，大量的向服务器发送SYN报文，
    服务器不断的申请资源建立控制块，从而大量占用资源直至资源耗尽，使正常请求服务变慢，或者完全停止服务
重放攻击：重复的会话请求就是重放攻击，可能是因为用户重复发起请求，也可能是因为请求被攻击者获取，然后重新发给服务器

21. RST包用来强制关闭TCP链接。 什么时候发送RST包      
1.  建立连接的SYN到达某端口，但是该端口上没有正在 监听的服务。       
2. TCP收到了一个根本不存在的连接上的分节。       
3. 请求超时。 使用setsockopt的SO_RCVTIMEO选项设置recv的超时时间。接收数据超时时，会发送RST包

22. 堆排序的额外空间复杂度是（）???

23. 根据哈弗曼树的定义，一棵二叉树要使其WPL值最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点
父节点数值大于子节点; 左节点小于右节点;

24.  无向图G有20条边，有4个度为4的顶点，6个度为3的顶点，其余顶点度小于3，则G最多有多少个顶点???

25.  3的方幂及不相等的3的方幂的和排列成递增序列{1,3,4,9,10,12,13…}，则数列第100项是???

26.  最长递增子序列（LIS）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。
 比如{2,1,4,2,3,7,4,7,19} 的LIS是 {1,2,3,4,7,19}，长度是6。
 考虑大小为N的数组，获取其LIS的最小时间和空间复杂度分别为：    ???

27.  F(x)=1 (x<=1), F(n)=25*F(n/5)+n^2 求F(n)的时间复杂度:  ??? 

28.  文法G：S->abSba|c所识别的语言是

29.  PostgreSQL是关系型数据库。    Hbase、Cassandra是按列存储，MongoDB是文档存储，都是NoSql

30.  给定一个字符串集合，集合大小为n，n=6000000, 请问从集合中查询字符串，以下算法中最快速的是哪一个？??   C   数组查，链表改（增删），这是这两个各自的长处  哈希表查询时间复杂度为O(1)
 A:skiplist（跳表）    B: 树    C:哈希表    D:红黑树

31. vector删除元素
　　针对于非array容器有多种删除方式，以erase为例，比如：
　　c.erase(p);　　　　　　   // 删除迭代器p所指定的元素，返回一个指向被删除元素之后的迭代器。
　　c.erase(begin,end);　   // 删除b,e所指定范围内的元素，返回一个指向被删除元素之后的迭代器。
　　c.clear();　　　  　　   // 删除所有元素

32. 栈空间内存是从高地址向低地址值分配的 

33. B-树 是一种多路搜索树（并不是二叉的）：

34. 结构体的对齐原则
 1. 在结构体中，所有的成员的偏移量（结构体成员的地址-结构体的首地址 = 偏移量）必须是该成员大小的整数倍
 2. 结构体的总大小必须可以整除最宽基本成员
 3. 如果结构体中，内嵌了构造类型（枚举，数组，结构体，共同体），那么这个结构体是按照其成员来对齐的。
 4. 数组和字符串都不属于最宽基本成员
 5. 结构体嵌套的情况下，最宽基本成员不局限于当前的结构体，会把被嵌套的结构体成员也算上
 6. 32位下有一个限制，最大对齐的字节数不超过4字节

==================64位下=================
 struct my
 {    
      int num1;
      char num2;          //偏移量是4，可以整除1，  
      double num3;       // 偏移量是13，要想整除8，需要在char后边填充三个字节
      char num4;         //加上这个就是17个字节了，要想让它能够整除最宽的基本成员，需要在char后边填充7个字节
 };
 // 总字节是24字节

 struct Mystruct
{
      char str[13];
      double a;  
};  　　//该结构体占用24个字节
 
struct Mystructx
{
       struct Mystrct test;
       char b;　　//结构体嵌套的情况下，最宽基本成员不局限于当前的结构体，会把被嵌套的结构体成员也算上。。
};　　//这个结构体占用32个字节

typedef struct _m {
    int a;    //4Byte
    char b;   //1Byte
    char c;   //1Byte
    short n;  //2Byte
}m;            //共占据8Byte
 
typedef struct _t {
    int aa;    //4Byte
    short bb;  //2Byte
    m mm;      //8Byt
}t;          //共16Byte

==================32位下=================
struct foo{
    int a;
    char b;
    char c;
    }; //8字节

struct foo{
    char a;
    int b;
    char c;
};//12字节

35. 结构体位域
struct 位域结构名 {
    类型说明符  位域名：位域长度
}

例如：
struct  bit_struct {
    int  bit1:3;
    int  bit2:5;
    int  bit3:7;
} data;
其中bit_struct表示位域结构体，bit1、bit2、bit3表示对应的位域，data表示位域结构体定义的变量。整个位域结构体占用2个字节，
bit1占3位，bit2占5位，bit1和bit2共用一个字节，bit3占7位，独占一个字节
1、位域必须存储在同一个类型中，不能跨类型，同时也说明位域的长度不会超过所定义类型的长度。如果一个定义类型单元里所剩空间无法存放下一个域，
   则下一个域应该从下一单元开始存放。例如：所定义的类型是int类型，一共32为，目前用掉了25位还剩下7位，这时要存储一个8位的位域元素，
   那么这个元素就只能从下一个int类型的单元开始而不会在前面一个int类型中占7为后面的int类型中占1位。
2、如果位域的位域长度为0表示是个空域，同时下一个域应当从下一个字节单元开始存放。
3、使用无名的位域来作为填充和调整位置，切记该位域是不能被使用的。
4、位域的本质上就是一种结构体类型，不同的是其成员是按二进制位来分配的

35. 异或运算符（^） *的优先级大于^   12345^0x12345^0x12345的值为 12345
    取反运算符:~
    ~: 代表位的取反，对于整形变量，对每一个二进制位进行取反，0变1，1变0。
    !: 代表值得取反，对于整形变量，只要不为0，使用 ! 取反都是0，0取反就是1。就像 bool 只有真假一样。

36. 自旋锁（spin lock）：类似于互斥锁，但调用者的线程不会被挂起，而是一直处于忙等待的状态，因此效率远高于互斥锁。

37. 编译过程中，语法分析器的任务是？ 
    a. 分析单词串是如何构成语言和说明的
    b. 分析语句和说明是如何构成程序的
    c. 分析程序的结构

38. 列选项中是操作系统死锁的必要条件的有哪些？
   a. 互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
   b. 不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。 
   c. 请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
   d. 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，
     环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源

39. 友元函数或者友元类 可以访问私有成员

40. delete和delete[ ]的区别
    1.简单的基本数据类型
        int *a = new int[10];
        delete a;    // 方式1
        delete [ ] a;    //方式2
        简单的基本数据类型，方式1和方式2均可正常工作，因为：基本的数据类型对象没有析构函数，
        并且new 在分配内存时会记录分配的空间大小，则delete时能正确释放内存，无需调用析构函数释放其余指针。因此两种方式均可
    2.自定义数据类型
        对于内存空间的清理，由于申请时记录了其大小，因此无论使用delete还是delete[ ]都能将这片空间完整释放，而问题就出在析构函数的调用上，
        当使用delete时，仅仅调用了对象数组中第一个对象的析构函数，而使用delete [ ]的话，将会逐个调用析构函数

41  时间轮定时器

42  
C++03：__cplusplus = 199711L
C++11：__cplusplus = 201103L
C++14：__cplusplus = 201402L

43  NSS 是开源软件，和 OpenSSL 一样，是一个底层密码学库，包括 TLS 实现。

44  大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中
    小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中
