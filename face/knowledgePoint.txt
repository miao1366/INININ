1. hash碰撞解决方法
   a. 开放地址法 (线性探测  、二次探测)
      开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k<=m-1)
      基本思想：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止
   b. rehash (再hash法)
      使用第二个或第三个...计算地址，直到无冲突。比如：按首字母进行hash冲突了，则按照首字母第二位，进行hash寻址
   c. 链地址法（拉链法）   
      创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
      java hashmap使用的就是拉链法解决hash碰撞

      双重散列和多重散列就是第一个哈希公式冲突后再用第二个或者更多的哈希公式去算地址

2. 数组地址
   记住二维数组中元素a[i][j]的地址为：  a[i]+j=*(a+i)+j=&a[i][j]      //  *(a+i*4+j)                *(*(a+i)+j)  a = &a[0]

   对于a[row]，a是一维数组的首地址，*(a+1) = a[1];
   对于a[row][col],将其视为(a[row])[col],那么a[row]就是(a[row])[col]的首地址，*(a[0] + 1) = a[0][1];
   那么对于(a[row]) [col]，a代表什么呢？让我们变换一下：
   (a[row]) [col] = (*(a+row) )[col] =*(*(a+row) + col) 
   这样看，a[row]是不是很像一个指针数组，它的内部元素全部是指针，a[0]即指向第0行的指针，a[1]即指向第一行的指针。
   这样理解a也就比较容易了，可以把它当做数组a[row]的首地址，即 a = &a[0]，于是乎 *(a+row) = a[row]

3. 一棵完全二叉树第六层有9个叶结点（根为第一层），则结点个数最多有（）  //109 
   方法一:
       根据二叉树的性质,第i层上的结点数最多为2^i(i >= 0,所以第一层为i=0)个,所以第六层的结点数最多为2^5=32个,根据题意第六层有9个叶子结点,
       推测出还有第七层,所以第六层结点数减去9个叶子结点,剩下的23个结点都有左右子树,故第七层有23*2=46个结点,总的结点数=2^0+2^1+2^2+2^3+2^4+2^5+46=109个
   方法二:
       总结点数=七层总结点数-第六层叶子结点数*2=(2^7-1)-9*2=109个
4. 在 TCP/IP 参考模型中 TCP 协议工作在（） // 传输层 
   TCP(传输控制协议)和 UDP(用户数据报协议)。其中，TCP是一个可靠的面向连接的协议，udp是不可靠的或者说无连接的协议
   OSI参考模型：（高到低）应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

5  假设二叉排序树的定义是：1、若它的左子树不为空，则左子树所有节点均小于它的根节点的值；2、若右子树不为空，则右子树所有节点的值均大于根节点的值；
   3、它的左右子树也分别为二叉排序树。下列哪种遍历之后得到一个递增有序数列（）  //中序遍历

6  假设用于通信的电文由 5 个字母组成，字母在电文中出现的频率分别为 2,4,5,7,8 根为第一层，用这 5 个字母设计哈弗曼树带权路径长度为（） //58
     构成赫夫曼树的步骤：
     1)从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
     2)取出根节点权值最小的两颗二叉树
     3)组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
     4)再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树