1. hash碰撞解决方法
   a. 开放地址法 (线性探测  、二次探测)
      开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k<=m-1)
      基本思想：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止
   b. rehash (再hash法)
      使用第二个或第三个...计算地址，直到无冲突。比如：按首字母进行hash冲突了，则按照首字母第二位，进行hash寻址
   c. 链地址法（拉链法）   
      创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
      java hashmap使用的就是拉链法解决hash碰撞

      双重散列和多重散列就是第一个哈希公式冲突后再用第二个或者更多的哈希公式去算地址

2. 数组地址
   记住二维数组中元素a[i][j]的地址为：  a[i]+j=*(a+i)+j=&a[i][j]      //  *(a+i*4+j)                *(*(a+i)+j)  a = &a[0]

   对于a[row]，a是一维数组的首地址，*(a+1) = a[1];
   对于a[row][col],将其视为(a[row])[col],那么a[row]就是(a[row])[col]的首地址，*(a[0] + 1) = a[0][1];
   那么对于(a[row]) [col]，a代表什么呢？让我们变换一下：
   (a[row]) [col] = (*(a+row) )[col] =*(*(a+row) + col) 
   这样看，a[row]是不是很像一个指针数组，它的内部元素全部是指针，a[0]即指向第0行的指针，a[1]即指向第一行的指针。
   这样理解a也就比较容易了，可以把它当做数组a[row]的首地址，即 a = &a[0]，于是乎 *(a+row) = a[row]

3. 一棵完全二叉树第六层有9个叶结点（根为第一层），则结点个数最多有（）  //109 
   方法一:
       根据二叉树的性质,第i层上的结点数最多为2^i(i >= 0,所以第一层为i=0)个,所以第六层的结点数最多为2^5=32个,根据题意第六层有9个叶子结点,
       推测出还有第七层,所以第六层结点数减去9个叶子结点,剩下的23个结点都有左右子树,故第七层有23*2=46个结点,总的结点数=2^0+2^1+2^2+2^3+2^4+2^5+46=109个
   方法二:
       总结点数=七层总结点数-第六层叶子结点数*2=(2^7-1)-9*2=109个
4. 在 TCP/IP 参考模型中 TCP 协议工作在（） // 传输层 
   TCP(传输控制协议)和 UDP(用户数据报协议)。其中，TCP是一个可靠的面向连接的协议，udp是不可靠的或者说无连接的协议
   OSI参考模型：（高到低）应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

5  假设二叉排序树的定义是：1、若它的左子树不为空，则左子树所有节点均小于它的根节点的值；2、若右子树不为空，则右子树所有节点的值均大于根节点的值；
   3、它的左右子树也分别为二叉排序树。下列哪种遍历之后得到一个递增有序数列（）  //中序遍历

6  假设用于通信的电文由 5 个字母组成，字母在电文中出现的频率分别为 2,4,5,7,8 根为第一层，用这 5 个字母设计哈弗曼树带权路径长度为（） //58
     构成赫夫曼树的步骤：
     1)从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
     2)取出根节点权值最小的两颗二叉树
     3)组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
     4)再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

7.  查找表结构用以下哪一项   //  desc tabl_name
8.  java system.gc可以提醒垃圾回收执行，不能强制 , 没有方法可以强行回收垃圾，只能提高优先级

9.  ARP（Address Resolution Protocol）地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议；
    RARP（Reverse Address Resolution Protocol）反向地址转换协议
   
10.   集线器：物理层
     交换机：数据链路层
     路由器：网络层
     从通信协议的角度来看，路由器是在哪个层次上实现网络互连的？  //网络层

     ICMP：控制报文协议，用于在IP主机和路由之间传递控制信息  在TCP/IP体系结构中，直接为ICMP提供服务的协议是___    //ip
     
11    栈：后进先出
    队列：先进先出
    元素 a，b，c，d，e 依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素 d 开头的序列个数是  // 4

12.  地址是否固定要看系统配置和编译选项，如果开启了地址随机化，那地址是每次都变的，如果没开启，那么地址每次都一样

13.  四次挥手
     client 发送 FIN 给 server 进入 FIN_Wait1
     server 接受client的FIN,发送ACK给client 进入close_wait，client接收到进入FIN_wait2
     server 发送FIN给client 进入last_ack状态,client接收到进入time_wait状态
     client 发送ACK给server,有2MSL的等待时间，保证连接的关闭，client进入close状态，server接收到进入close状态
   
14. TCP建立连接要进行3次握手,而断开连接要进行4次
1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
3 由B 端再提出反方向的关闭请求,将FIN置1
4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端
和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础
名词解释
ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段
都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
SYN  同步序列号,TCP建立连接时将这个位置1
FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

15. 只有执行主动关闭端才会出现TIME_WAIT

16. 给定一个整型数组L，数组长度为n，数组元素取值范围[1,n],（n>2000)，
    请问最快速找出一个缺失值的时间复杂度是多少？    //  O(n)

17.  已知一个线性表（38，25，74，63，52，48），假定采用散列函数h（key) = key%7计算散列地址，并散列存储在散列表A【0....6】中，
     若采用线性探测方法解决冲突，则在该散列表上进行等概率成功查找的平均查找长度为
     
     平均查找长度=总的查找次数/元素数
     总的查找次数： 38%7=3 （第1次出现3，无冲突，放在位置3，查找次数为1）
     25%7=4（第1次出现4，无冲突，放在位置4，查找次数为1）
     74%7=4（第2次出现4，有冲突，放在位置5，查找次数为2）
     63%7=0（第1次出现0，无冲突，放在位置0，查找次数为1）
     52%7=3（第2次出现3，有冲突，发现冲突3,4,5，故只能放到6，查找次数为4）
     48%7=6 （第1次出现6，有冲突，发现冲突6,0，故只能放到1，查找次数为3）
     1+1+2+1+4+3=12
     元素数=6
     所以：平均查找长度=12/6=2
    
18. 实现底层为红黑树的set、multiset、map、multimap    // multimap  multiset key值可以重复

     multimap<string,int> multimapSTRint;
     multimapSTRint.insert(make_pair("strtrest",125));
     multimapSTRint.insert(make_pair("strtrest",126))
     typedef multimap<string,int>::iterator iterTest;
     iterTest beg = multimapSTRint.lower_bound("strtrest");
     iterTest end = multimapSTRint.upper_bound("strtrest");
     while(beg != end)
     {
      int Nstr = beg->second;
      ++beg;
     }

19. 二叉搜索树中序遍历得到升序

20. 首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法

21. 20. DNS欺骗攻击: 冒充域名，把原来查询的ip改为其他IP
DDoS攻击：Dos攻击叫拒绝服务攻击，如向一台服务器发送大量的IP数据报，使服务器要花很多时间处理所接收到的数据报，导致合法用户被拒绝服务
SYN Flooding: SYN Flooding攻击和TCP的三次握手过程有关。三次握手过程大概是：一、客户端发送SYN给服务器，此时服务器内部会建立请求控制块；
    二、服务器响应SYN/ACK给客户端；三、客户端收到SYN-ACK之后向服务器发送ACK，服务器收到最后一个握手ACK报文后，控制块会转换成为正式的连接控制块。
    如果迟迟未收到最后的那个ACK报文，服务器会通过定时器重发SYN-ACK，直至超时，销毁请求控制块；SYN Flooding攻击是通过伪造的IP地址，大量的向服务器发送SYN报文，
    服务器不断的申请资源建立控制块，从而大量占用资源直至资源耗尽，使正常请求服务变慢，或者完全停止服务
重放攻击：重复的会话请求就是重放攻击，可能是因为用户重复发起请求，也可能是因为请求被攻击者获取，然后重新发给服务器

21. RST包用来强制关闭TCP链接。 什么时候发送RST包      
1.  建立连接的SYN到达某端口，但是该端口上没有正在 监听的服务。       
2. TCP收到了一个根本不存在的连接上的分节。       
3. 请求超时。 使用setsockopt的SO_RCVTIMEO选项设置recv的超时时间。接收数据超时时，会发送RST包

22. 堆排序的额外空间复杂度是（）???

23. 根据哈弗曼树的定义，一棵二叉树要使其WPL值最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点
父节点数值大于子节点; 左节点小于右节点;

24.  无向图G有20条边，有4个度为4的顶点，6个度为3的顶点，其余顶点度小于3，则G最多有多少个顶点???

25.  3的方幂及不相等的3的方幂的和排列成递增序列{1,3,4,9,10,12,13…}，则数列第100项是???

26.  最长递增子序列（LIS）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。
 比如{2,1,4,2,3,7,4,7,19} 的LIS是 {1,2,3,4,7,19}，长度是6。
 考虑大小为N的数组，获取其LIS的最小时间和空间复杂度分别为：    ???

27.  F(x)=1 (x<=1), F(n)=25*F(n/5)+n^2 求F(n)的时间复杂度:  ??? 

28.  文法G：S->abSba|c所识别的语言是

29.  PostgreSQL是关系型数据库。    Hbase、Cassandra是按列存储，MongoDB是文档存储，都是NoSql

30.  给定一个字符串集合，集合大小为n，n=6000000, 请问从集合中查询字符串，以下算法中最快速的是哪一个？??   C   数组查，链表改（增删），这是这两个各自的长处  哈希表查询时间复杂度为O(1)
 A:skiplist（跳表）    B: 树    C:哈希表    D:红黑树

31. vector删除元素
　　针对于非array容器有多种删除方式，以erase为例，比如：
　　c.erase(p);　　　　　　   // 删除迭代器p所指定的元素，返回一个指向被删除元素之后的迭代器。
　　c.erase(begin,end);　   // 删除b,e所指定范围内的元素，返回一个指向被删除元素之后的迭代器。
　　c.clear();　　　  　　   // 删除所有元素

