/*
在父类的构造函数中调用虚函数是不能够实现多态的，这个问题涉及到vptr指针的初始化问题。
比如在构造子类对象c时，执行到父类的构造函数时，这个c.vptr指向的是父类的虚函数表，这时调用虚函数，执行的是父类的虚函数，不是多态。
当执行完父类的构造函数，执行到子类的构造函数时，这个c.vptr指针这时才指向本身自己的虚函数表。注意，每一个对象都有一个vptr指针和一个虚函数表，
这个是在编译时就提前布局了，而不是在运行时


总结：虚函数表是针对类的，一个类的所有对象的虚函数表都一样


根据继承性，首先调用父类的构造函数，虽然此时子类对象还未完全创建（必须调用完子类的构造函数时，此时对象才会创建完毕），
但是此时子类对象的父类部分已经构造完毕，所以这时候的this指针可以看成是子类对象的this指针，但是只能调用基类PARENT的数据成员

C++编译器是保证虚函数表的指针存在于对象实例中最前面的位置(是为了保证取到虚函数表的最高的性能)，这样我们就能通过已经实例化的对象的地址得到这张虚函数表，再遍历其中的函数指针，并调用相应的函数


Note：
1. 如果我们定义了一个构造函数，编译器就不会再为我们生成默认构造函数了。
2. 编译器生成的析构函数是非虚的，除非是一个子类，其父类有个虚析构，此时的函数虚特性来自父类。
3. 有虚函数的类，几乎可以确定要有个虚析构函数。
4. 如果一个类不可能是基类就不要申明析构函数为虚函数，虚函数是要耗费空间的。
5. 析构函数的异常退出会导致析构不完全，从而有内存泄露。最好是提供一个管理类，在管理类中提供一个方法来析构，调用者再根据这个方法的结果决定下一步的操作。
6. 在构造函数不要调用虚函数。在基类构造的时候，虚函数是非虚，不会走到派生类中，既是采用的静态绑定。显然的是：当我们构造一个子类的对象时，先调用基类的构造函数，
   构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的，
   所以C++中是不可以在构造父类对象部分的时候调用子类的虚函数实现。但是不是说你不可以那么写程序，你这么写，编译器也不会报错。
   只是你如果这么写的话编译器不会给你调用子类的实现，而是还是调用基类的实现。
7. 在析构函数中也不要调用虚函数。在析构的时候会首先调用子类的析构函数，析构掉对象中的子类部分，
   然后在调用基类的析构函数析构基类部分，如果在基类的析构函数里面调用虚函数，会导致其调用已经析构了的子类对象里面的函数，这是非常危险的。
8. 记得在写派生类的拷贝函数时，调用基类的拷贝函数拷贝基类的部分，不能忘记了。



*/

#include <iostream>
class A {
public:  
    A() {
        std::cout << "A is created"  << std::endl;
        std::cout << this << std::endl;
        Print();
    }
    virtual ~A() {
        Print();
        std::cout << "A is deleted"  << std::endl;
    }

    virtual void Print() {
        std::cout << "A:: Print()."  << std::endl;
    }
};

class B : public A {
public:  
    B() {
        std::cout << "B is created"  << std::endl;
        std::cout << this << std::endl;
        Print();
    }
    ~B() {
        std::cout << "B is deleted"  << std::endl;
    }
    virtual void Print() {
        std::cout << "B:: Print()."  << std::endl;
    }
};

int main(void) {
   A* a = new B();
   delete a;
   return 0;
}