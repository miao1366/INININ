#include <stdio.h>
#include <iostream>
#include <string>
using namespace std;

int main(int argc, char *argv[]) {
	
	return 0;
}


1. std::floor 和 std::ceil都是对变量进行四舍五入，只不过四舍五入的方向不同。 
1: std::floor -->向下取整数
2: std::ceil   -->向上取整数：
例如： 5.88   std::floor(5.88) = 5;
std::ceil(5.88)   = 6;


2.
thread::hardware_concurrency();//获取cpu核心个数 


3. 
1.typeid是C++的关键字之一，等同于sizeof这类的操作符
2.typeid操作符的返回结果是名为type_info的标准库类型的对象的引用（在头文件typeinfo中定义）
3.C++并没有规定typeid实现标准，各个编译器可能会不一样
4.编译器会为每一种typeid操作的类型生成一份保存在数据段的type_info数据。
5.每种类型的type_info数据长度依赖于类型名称，至少9个字节


4. 数字转成字符串

to_string(x)

5.strftime()  格式化输出时间
%D     月/天/年
%T     The time in 24-hour notation (%H:%M:%S).  (SU)

6.strptime()  函数将字符串转换成 tm 结构
7.int vsprintf(char *string, char *format, va_list param) 可变参数按照format格式输出到string
8.int vfprintf(FILE *stream, char *format, va_list param) 可变参数按照format格式输出到文件 stream
9.  int inet_aton(const char *cp, struct in_addr *inp) 将IPv4的字符串地址（xxx.xxx.xxx.xxx）转换成网络地址结构体 struct in_addr
10. char *inet_ntoa(struct in_addr in)  是将网络字节序的整形转化成字符串（“xxx.xxx.xxx.xxx"）的IPv4地址
11. int fcntl(int fd, int cmd, ...) fcntl是用来修改已经打开文件的属性的函数.
12. void *realloc(void *ptr, size_t size); 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小
    0·  当起始空间的地址为空，即*ptr = NULL,则同malloc。当*ptr非空：若nuw_size < size,即缩小*ptr所指向的内存空间，该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依然保留
    1.  我们知道，realloc是从堆上分配内存的，当扩大一块内存空间时， realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，
        自然天下太平。也就是说，如果原先的内存大小后面还有足够的空闲空间用来分配，加上原来的空间大小＝ newsize。那么就ok。得到的是一块连续的内存。
    2.  如果原先的内存大小后面没有足够的空闲空间用来分配，那么从堆中另外找一块newsize大小的内存。
        并把原来大小内存空间中的内容复制到newsize中。返回新的指针
12. void *calloc(size_t n, size_t size)；
    其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int *p = (int *)calloc(20, sizeof(int)）,
	这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，
	对空间逐一进行初始化，并设置值为0

13. void perror(const char *s);
    perror ( )用 来 将 上 一 个 函 数 发 生 错 误 的 原 因 输 出 到 标 准 设备 (stderr) 。参数 s 所指的字符串会先打印出,后面再加上错误原因字符串

14. char* strerror(int errnum);
15. int strerror_r(int errnum, char *buf, size_t n); 它的好处是可以把错误描述字符串放在用户自定义的buffer中
16. std::reverse  反转  std::reverse(myvector.begin(),myvector.end()); 
17. std::reverse_copy  myvector.resize(9) std::reverse_copy (myints, myints+9, myvector.begin());
18. std::string reserve() 改变容器大小.
19. struct tm *gmtime_r(const time_t *timep, struct tm *result)
 gmtime和localtime后要立即处理结果，否则返回的指针指向的内容可能会被覆盖，一个好的方法是使用gmtime_r和localtime_r，由于使用了用户分配的内存，这两个函数是不会出错的
 
20. time_t time(time_t *tloc);  ime() 是指返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数的函数，主要用来获取当前的系统时间，返回的结果是一个time_t类型

21  int gethostname(char *name, size_t len);   // miao-System-Product-Name
22. std::reverse  反转  std::reverse(myvector.begin(),myvector.end()); 
23. std::reverse_copy  myvector.resize(9) std::reverse_copy (myints, myints+9, myvector.begin());
24. std::string reserve() 改变容器大小.


25. int memcmp(const void *buf1, const void *buf2, unsigned int count);
    比较内存区域buf1和buf2的前count个字节。返回值当buf1<buf2时，返回值<0当buf1=buf2时，返回值=0当buf1>buf2时，返回值>0
	
26  string 构造函数
1    string s; //生成一个空字符串s 
2 b) string s(str) //拷贝构造函数 生成str的复制品 
3 c) string s(str, int stridx) //将字符串str内"始于位置stridx"的部分当作字符串的初值 
4 d) string s(str, int stridx, int strlen) //将字符串str内"始于stridx且长度顶多strlen"的部分作为字符串的初值 
5 e) string s(const char*) //将cstr字符串作为s的初值 
6 f) string s(chonst char*, int len) //将C字符串前chars_len个字符作为字符串s的初值。 
7 g) string s(int num, char c) //生成一个字符串，包含num个c字符 
8 h) string s(beg, end) //以区间beg;end(不包含end)内的字符作为字符串s的初值 


27 std::string.assign()方法可以理解为先将原字符串清空，然后赋予新的值作替换
   1.  string& assign ( const string& str );  将str替换原字串的内容
   2.  string& assign ( const string& str, size_t pos, size_t n );将str的内容从位置pos起的n个字符作为原字串的新内容赋给原字串
   3.  string& assign ( const char* s, size_t n ); 将字符数组或者字符串的首n个字符替换原字符串内容
   4.  string& assign ( const char* s ); 将字符串或者字符数组作为新内容替换原字串
   5.  string& assign ( size_t n, char c );   将原字串替换为n个字符c
   6.  template <class InputIterator>   string& assign ( InputIterator first, InputIterator last)  //从终端读取字符
   
28. string.reserve(size_t n = 0)  //改变内存大小
  将字符串的容量设置为至少size. 如果size指定的数值要小于当前字符串中版的字符数(亦即size < this→权size()), 容量将被设置为可以恰好容纳字符的数值. reserve()以线性时间(linear time)运行。
  它最大的用处是为了避免反复重新分配缓冲区内存而导致效率降低

29. string.resize(size_type size, char val = char())   //改变字符长度大小，
    val默认为空格，如果size小于原来的大小，则截取size大小的字符，反之用'0'来代替.

30. pid_t getpid(void); 获取进程id //26110

31. pid_t getppid(void); 获取父进程id //26066

32. uid_t getuid(void); 获得用户 UID 值 // 1

33. int getpwuid_r(uid_t uid, struct passwd *pwd, char *buf, size_t buflen, struct passwd **result); 得到用户id  "miao"

34. uid_t geteuid(void);用户有效 UID 值 1000

35. void std::unique_ptr::reset (nullptr_t p) noexcept;  cplusplus.com/  deletes managed object, acquires new pointe

36. FILE *fopen(const char *pathname, const char *mode); // 'a' appending
        "r"           打开文字文件只读
        "w"           创建文字文件只写
        "a"           增补, 如果文件不存在则创建一个
        "r+"          打开一个文字文件读/写
        "w+"          创建一个文字文件读/写
        "a+"          打开或创建一个文件增补
        "b"           二进制文件(可以和上面每一项合用)
        "t"           文这文件(默认项)

37. void setbuffer(FILE * stream,char * buf,size_t size);
    打开文件流后，读取内容之前，调用setbuffer()可用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址，参数size为缓冲区大小

38. int fflush(FILE *stream)
    清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入时
	
39. size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 
    size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream); fwrite_unlocked是fwrite的线程不安全版本，因为不加锁
      1) buffer是一个指针。对fwrite来说是要写入数据的地址。
      2) size是要写入内容的单字节数。
      3) count是要 进行写入size字节的数据项的个数。
      4) stream为目标文件指针
      5) 返回实际写入的数据项个数count
	
40. int ferror(FILE *stream);  ferror 函数返回为真时就表示有错误发生

41. int strerror_r(int errnum, char *buf, size_t n); 错误描述拷贝到buf中.

42. int fstat(int fildes,struct stat *buf);
    用来将参数fildes所指的文件状态，复制到参数buf所指的结构中(struct stat).
	
43. S_ISREG(mode)        是否是一个常规文件.
44. S_ISDIR(mode)              是否是一个目录

45. char *strchr(const char *s, int c);  returns a pointer to the first occurrence of the character c in the string s
    
46. char *strrchr(const char *s, int c);  returns a pointer to the last occurrence of  the character c in the string s .可以说是从右边遍历

47.  static_assert(常量表达式，"提示字符串")
    如果第一个参数常量表达式的值为false，会产生一条编译错误。错误位置就是该static_assert语句所在行，第二个参数就是错误提示字符串
	
48  digits10  返回得是float不损失精度的小数位; 
    cout << "digits10(float): " << numeric_limits<float>::digits10 << endl; 6
	
49  digits  返回的是float不损失精度的整数位:24 
    std::numeric_limits::digits函数用于查找数据类型可以表示而不损失精度的基数位数   //可以看下浮点数内存分布
    
    numeric_limits<int>::digits           //31
    numeric_limits<float>::digits         //24
    numeric_limits<double>::digits        //53
    numeric_limits<long double>::digits   //64

50. abort()和exit()
   共同点: 都是用来终止程序
   不同点:
   1)abort(): 立即结束，不做任何操作
   2)exit():   释放所有静态全局的对象、缓存，关掉所有的I/O通道，然后终止程序.如果有函数通过atexit来注册，还会调用注册的函数，如果atexit函数抛出异常就会直接调用结束。

51. int atexit(void （*func)(void));
   很多时候我们需要在程序退出的时候做一些诸如释放资源的操作，但程序退出的方式有很多种，比如main()函数运行结束、在程序的某个地方用exit()结束程序、
   用户通过Ctrl+C或Ctrl+break操作来终止程序等等，因此需要有一种与程序退出方式无关的方法来进行程序退出时的必要处理。方法就是用atexit()函数来注册程序正常终止时要被调用的函数
   在一个程序中最多可以用atexit()注册32个处理函数，这些处理函数的调用顺序与其注册的顺序相反，也即最先注册的最后调用，最后注册的最先调用

52.  pthread_t pthread_self(void);  // 11281
   返回一个 pthread_t 类型的变量，指代的是调用 pthread_self 函数的线程的 “ID”。
   怎么理解这个“ID”呢？这个“ID”是 pthread 库给每个线程定义的进程内唯一标识，是 pthread 库维持的。
   由于每个进程有自己独立的内存空间，故此“ID”的作用域是进程级而非系统级（内核不认识）
   其实 pthread 库也是通过内核提供的系统调用（例如clone）来创建线程的，而内核会为每个线程创建系统全局唯一的“ID”来唯一标识这个线程。
   这个系统全局唯一的“ID”叫做线程PID（进程ID），或叫做TID（线程ID），也有叫做LWP（轻量级进程=线程）的
   
53   pid_t syscall(SYS_gettid) 系统调用返回一个 pid_t 类型值，即线程在内核中的ID   //140429854775040

54 int isdigit(int c); 参数c表示要检测的字符或者 ASCII 码。
   返回值为非 0（真）表示 c 是数字，返回值为 0（假）表示c不是数字
   
55  ssize_t readlink(const char *pathname, char *buf, size_t bufsiz)；  readlink("/proc/self/exe", buf, sizeof(buf)) 可获取exe文件目录

56 int getrlimit(int resource, struct rlimit *rlp);
　　int setrlimit(int resource, const struct rlimit *rlp);
  我们能够通过函数getrlimit()、setrlimit()分别获得、设置每个进程能够创建的各种系统资源的限制使用量
  资源限制是一对值：一个指定了当前（软）限制，另一个则代表一个最大（硬）限制。软限制能够被一个进程改变，
  只要保证它不大于硬限制。一个进程能够（不能够撤回的）降低它的硬件限制，前提是大于等于软限制。仅当一个进程工作在一个系统超级用户权限下时能够提高它的硬件限制
  
		  名称					意义
	RLIMIT_AS			进程总共可用的内存大小的最大值
	RLIMIT_CORE			core文件的最大尺寸，如果为0说明不能创建core文件
	RLIMIT_CPU			CPU时间的最大值（单位：秒）
	RLIMIT_DATA			数据段大小的最大值
	RLIMIT_FSIZE		创建文件的大小的最大值
	RLIMIT_LOCKS		进程可建立的文件锁的数量的最大值
	RLIMIT_MEMLOCK		进程中使用mlock锁定内存的最大尺寸
	RLIMIT_NOFILE		进程中文件的打开数量的最大值
	RLIMIT_NPROC		每个real user id的子进程数量的最大值
	RLIMIT_RSS			最大常驻存储区大小
	RLIMIT_SBSIZE		socket缓冲的大小的最大值
	RLIMIT_STACK		栈的最大尺寸
	RLIMIT_VMEM			=RLIMIT_AS

57 long sysconf(int name); 获取一些系统的参数
    printf("Size of a page in bytes:%ld\n",sysconf(_SC_PAGESIZE));                        //4096                    
	printf("Max length of a  hostname:%ld\n",sysconf(_SC_HOST_NAME_MAX));                 //64
	printf(" The maximum number of files that a process can have open at any time.:%ld\n",sysconf(_SC_OPEN_MAX));         //1024
	printf("  The  number  of  clock  ticks  per  second.:%ld\n",sysconf(_SC_CLK_TCK));                      //100
	printf("The number of processors currently online .:%ld\n",sysconf(_SC_NPROCESSORS_ONLN));               //1
	printf("The number of processors configured..:%ld\n",sysconf(_SC_NPROCESSORS_CONF));                     //1
    
	
    printf("配置的处理器数量为 :%ld\n", sysconf(_SC_NPROCESSORS_CONF));                //1
    printf("当前在线(可用)的处理器数量为 :%ld\n"  ", sysconf(_SC_NPROCESSORS_ONLN));       //1
    printf ("页大小: %ld\n", sysconf(_SC_PAGESIZE));                                //4096
    printf ("页数: %ld\n", sysconf(_SC_PHYS_PAGES));                                //248933  
    printf ("可用页面的数量: %ld\n", sysconf(_SC_AVPHYS_PAGES));                      //17336
    printf ("内存大小: %lld MB\n", (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB );  
    printf ("最大打开的文件数: %ld\n", sysconf(_SC_OPEN_MAX));                        //1024
    printf("每秒的节拍数: %ld\n", sysconf(_SC_CLK_TCK));                             //100
    printf ("主机名的最大长度: %ld\n", sysconf(_SC_HOST_NAME_MAX));                   //64
    printf ("登录名的最大长度: %ld\n", sysconf(_SC_LOGIN_NAME_MAX));                  //256

    具体还是要看man page里的东西

58  std::atomic

59 int clock_gettime(clockid_t clk_id, struct timespec* tp);
    clk_id : 检索和设置的clk_id指定的时钟时间。
   CLOCK_REALTIME     				 :系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,
                       					中间时刻如果系统时间被用户改成其他,则对应的时间相应改变  // second:: 1600324428, nsec:298077879
　　CLOCK_MONOTONIC                 	:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响    // second:: 184002, nsec:195857000002,
　　CLOCK_PROCESS_CPUTIME_ID			:本进程到当前代码系统CPU花费的时间
　　CLOCK_THREAD_CPUTIME_ID			:本线程到当前代码系统CPU花费的时间
  
    struct timespec
 {
        time_t tv_sec; /* 秒*/
        long tv_nsec; /* 纳秒*/
 };
 
1秒=1000毫秒
1毫秒=1000微秒
1微秒=1000纳秒

60 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, 
                               const struct timespec *restrict abstime)
    a value of zero shall be returned; otherwise, an error number shall be returned to indicate the error

61 int pthread_cond_wait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex)

    函数返回值：返回0表示成功，其他都表示失败
    3、wait：当前线程调用wait()后将被阻塞，直到另外某个线程调用notify_*唤醒当前线程；
	当线程被阻塞时，该函数会自动调用std::mutex的unlock()释放锁，使得其它被阻塞在锁竞争上的线程得以继续执行。
	一旦当前线程获得通知(notify，通常是另外某个线程调用notify_*唤醒了当前线程)，wait()函数也是自动调用std::mutex的lock()。wait分为无条件被阻塞和带条件的被阻塞两种
		   
62  void assert( int expression );
   assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行  
   // fp = fopen( "noexitfile.txt", "r" )   assert( fp ); 出错的话，打印 Assertion  fp  failed  
   已放弃使用assert()的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。应该在debug模式下使用。
   
63 int prctl ( int option,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )
   这个系统调用指令是为进程制定而设计的，明确的选择取决于option:
   PR_GET_PDEATHSIG :返回处理器信号；
   PR_SET_NAME :把参数arg2作为调用进程的经常名字。（SinceLinux 2.6.11） 
   备注：prctl(PR_SET_NAME, childname[i], NULL, NULL, NULL); 设置进程名字；  prctl(PR_SET_NAME, "THREAD1");设置线程名字
   
64 swap()
  1. swap的函数原型：
  template <class T> void swap ( T& a, T& b )  
    {  
      T c(a); a=b; b=c;  
    }
	
  2.  vect中swap成员函数实现源码：
void swap(vector<_Tp, _Alloc>& __x) {  
    __STD::swap(_M_start, __x._M_start);  
    __STD::swap(_M_finish, __x._M_finish);  
    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);  
  } 
　　仅仅是交换了指向的首尾指针和容量指针
  
  
65. ssize_t pread(int fd, void *buf, size_t count, off_t offset);
    ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
	pread简单来说就是在指定偏移offset位置开始读取count个字节，同理可推 pwrite 。;
	pread函数相当于先后调用了lseek和read函数，但是还是有区别的，有以下两点区别：1. pread函数是原子操作，而先后调用两个函数不是原子操作;2. pread函数是不会改变当前文件偏移量的，而read和wr
	
66. char* getenv( const char* env_var );
    于宿主环境（操作系统）提供的环境列表搜索匹配 env_var 所指向的 C 字符串，并返回指向与匹配的列表成员关联的 C 字符串的指针。
	
	如果想要环境变量永久生效可以修改下面两个文件中的任何一个：
    1 /etc/profile
	2 .bash_profile
  其中，/etc/profile是全局的环境变量，对所有用户生效，而.bash_profile只对当前用户启作用。
  设置完毕，注销并重新登录，设置就生效了。
  注意：export设置只对当前的bash登录session有效。这是存在内存里面的
	
	
	
	
67    int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen);
      int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);
	  
	  sock：将要被设置或者获取选项的套接字。
	  level：选项所在的协议层。
	  optname：需要访问的选项名。
	  optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。
	  optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度

68 ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
   ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
   只需一次系统调用就可以实现在文件和进程的多个缓冲区之间传送数据，免除了多次系统调用或复制数据的开销  //https://blog.csdn.net/weixin_36750623/article/details/84579243
   
69 int close(int fd);
   内核中，打开的文件会被维护一个引用计数，每次close()会把文件的引用计数减一，引用计数减少到0的文件才会从内核中释放资源

70 int shutdown(intsockfd,inthowto)
   调用close()是关闭TCP连接的正常方式，但这种方式存在两个限制，而这正是引入shutdown()的原因：
       1）close()其实只是将socket fd的引用计数减1，只有当该socket fd的引用计数减至0时，TCP传输层才会发起4次握手从而真正关闭连接。
	      而shutdown则可以直接发起关闭连接所需的4次握手，而不用受到引用计数的限制；
       2）close()会终止TCP的双工链路。由于TCP连接的全双工特性，可能会存在这样的应用场景：local peer不会再向remote peer发送数据，
	      而remote peer可能还有数据需要发送过来，在这种情况下，如果local peer想要通知remote peer自己不会再发送数据但还会继续收数据这个事实，
		  用close()是不行的，而shutdown()可以完成这个任务
		  
   SHUT_RD   ： 关闭读这一半，此时用户不能再从这个套接字读数据，这个套接口接收到的数据都会被丢弃，对等方不知道这个过程。
                关闭连接的读端。也就是该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被丢弃。进程将不能对该套接字发出任何读操作。
			    对TCP套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。
   SHUT_WR   ： 相应地关闭写这一半，此时用户不能再向套接字中写数据，内核会把缓存中的数据发送出去，接着不会再发送数据，对等端将会知道这一点。
                当对等端试图去读的时候，可能会发生错误。
   SHUT_RDWR ： 关闭读与写两半，此时用户不能从套接字中读或写。它相当于再次调用shutdown函数，并且一次指定SHUT_RD，一次指定SHUT_WR。
   
   a.  如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。
   b.  在多进程中如果一个进程中shutdown(sfd,SHUT_RDWR)后其它的进程将无法进行通信. 如果一个进程close(sfd)将不会影响到其它进程.
   
   
71      (无符号)64字节主机转网络：htobe64(uint64_t data)
        (无符号)64字节网络转主机：be64toh(uint64_t data)
        (无符号)32字节主机转网络：htobe32(uint32_t data)
        (无符号)32字节网络转主机：be32toh(uint32_t data)
        (无符号)16字节主机转网络：htobe16(uint16_t data)
        (无符号)16字节网络转主机：be16toh(uint16_t data)

72   int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1
 
73   const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
        返回值：若成功则为指向结构的指针，若出错则为NULL
		
74 int getsockname(int sockfd, struct sockaddr *localaddr,socklen_t *addrlen); //getsockname函数用于获取与某个套接字关联的本地协议地址
   getsockname可以获得一个与socket相关的地址。
   服务器端可以通过它得到相关客户端地址。
   而客户端也可以得到当前已连接成功的socket的ip和端口。
   对于TCP连接的情况，如果不进行bind指定IP和端口，那么调用connect连接成功后，
   使用getsockname可以正确获得当前正在通信的socket的IP和端口地址。
   而对于UDP的情况，无论是在调用sendto之后还是收到服务器返回的信息之后调用，
   都无法得到正确的ip地址：使用getsockname得到ip为0，端口正确
   
75 getsockname函数用于获取与某个套接字关联的本地协议地址
   getpeername函数用于获取与某个套接字关联的外地协议地址
   int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen); // sockfd 是accept 返回的套接字 服务端可以绑定多个ip ,如多个网卡
 
   int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); // sockfd 是accept 返回的套接字

76 struct hostent *gethostbyname(const char *name); 
   这个函数的传入值是域名或者主机名，例如"www.google.com","wpc"等等。
  传出值，是一个hostent的结构（如下）。如果函数调用失败，将返回NULL。
  struct hostent {
     char *h_name;
     char **h_aliases;
     int h_addrtype;
     int h_length;
     char **h_addr_list;
};

解释一下这个结构, 其中:
char *h_name 表示的是主机的规范名。例如www.google.com的规范名其实是www.l.google.com。
char **h_aliases 表示的是主机的别名。www.google.com就是google他自己的别名。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。
int h_addrtype 表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是ipv6(AF_INET6)
int h_length 表示的是主机ip地址的长度
int **h_addr_lisst 表示的是主机的ip地址，注意，这个是以网络字节序存储的。千万不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，
需要调用inet_ntop()。


77 int gethostbyname_r(const char *name, struct hostent *ret, char *buf, size_t buflen, struct hostent **result, int *h_errnop);
   在网络开发中 经常出现需要从主机名得到ip地址的情况 这时就使用gethostbyname
   但是因为gethostbyname返回的是一个指向静态变量的指针 不可重入
   很可能刚要读时值就被其它线程修改
   所以 新的posix中增加了另一个可重入的从主机名(域名)得到DNS的孙数 gethostbyname_r


78 int gettimeofday(struct  timeval*tv,struct  timezone *tz ) //使用gettimeofday获得的值是Unix time。Unix time是以UTC 1970年1月1号00:00:00为基准时间。服务器一般都是以这个时间为基准
  
  struct  timeval{
       long  tv_sec;/*秒*/
       long  tv_usec;/*微妙*/
   }；
   
79  int eventfd(unsigned int initval, int flags); 
    eventfd是Linux 2.6提供的一种系统调用，它可以用来实现事件通知
	eventfd() 创建一个 eventfd 对象，可以由用户空间应用程序实现事件等待/通知机制，或由内核通知用户空间应用程序事件。
    该对象包含了由内核维护的无符号64位整数计数器 count 。使用参数 initval 初始化此计数器
	
	flags 可以是以下值的 OR 运算结果，用以改变 eventfd 的行为。

	EFD_CLOEXEC (since Linux 2.6.27)	文件被设置成 O_CLOEXEC，创建子进程 (fork) 时不继承父进程的文件描述符。
    EFD_NONBLOCK (since Linux 2.6.27)	文件被设置成 O_NONBLOCK，执行 read / write 操作时，不会阻塞。
	EFD_SEMAPHORE (since Linux 2.6.30)	提供类似信号量语义的 read 操作，简单说就是计数值 count 递减 1
	
	读:
	1.read函数会从eventfd对应的64位计数器中读取一个8字节的整型变量；
    2.read函数设置的接收buf的大小不能低于8个字节，否则read函数会出错，errno为EINVAL;
    3.read函数返回的值是按小端字节序的；
    4.如果eventfd设置了EFD_SEMAPHORE，那么每次read就会返回1，并且让eventfd对应的计数器减一；
	  如果eventfd没有设置EFD_SEMAPHORE，那么每次read就会直接返回计数器中的数值，read之后计数器就会置0。
	  不管是哪一种，当计数器为0时，如果继续read，那么read就会阻塞（如果eventfd没有设置EFD_NONBLOCK）或者返回EAGAIN错误（如果eventfd设置了EFD_NONBLOCK)
 
    写: 1.在没有设置EFD_SEMAPHORE的情况下，write函数会将发送buf中的数据写入到eventfd对应的计数器中，最大只能写入0xffffffffffffffff，否则返回EINVAL错误；
        2.在设置了EFD_SEMAPHORE的情况下，write函数相当于是向计数器中进行“添加”，比如说计数器中的值原本是2，如果write了一个3，那么计数器中的值就变成了5。
	  如果某一次write后，计数器中的值超过了0xfffffffffffffffe（64位最大值-1），
	  那么write就会阻塞直到另一个进程/线程从eventfd中进行了read（如果write没有设置EFD_NONBLOCK），或者返回EAGAIN错误（如果write设置了EFD_NONBLOCK）。
	  
80  int epoll_create1(int flags);
    如果flags为0，epoll_create1（）和删除了过时size参数的epoll_create（）相同。
    如果flags中包含以下值就有不同的表现：
    EPOLL_CLOEXEC
    在文件描述符上面设置执行时关闭（FD_CLOEXEC）标志描述符
	
	需要对epoll_create的create作一个说明，这里的1024并非是epoll只能监听1024个fd，而是初始分配的内存大小为1024，当要epoll实例监听的fd超过1024以后，
	会重新分配内存以容纳更多的fd。新版本的linux中，epoll已经在内核中，自己管理初始的fd列表大小，这个值已经没有意义，但是仍然必须填>0的值，
	目的是兼容老版本的操作系统内核
    默认情况下，epoll采用 LT模式工作，这时可以处理阻塞和非阻塞套接字，而上表中的 EPOLLET表示可以将一个事件改为 ET模式。ET模式的效率要比 LT模式高，它只支持非阻塞套接字
	
81 vector初始化
(1): vector<int> ilist1;
    默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。
(2): vector<int> ilist2(ilist);
vector<int> ilist2  = ilist; 
两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素
(3): vector<int> ilist = {1,2,3.0,4,5,6,7};
 vector<int> ilist {1,2,3.0,4,5,6,7};
ilist 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。
(4): vector<int> ilist3(ilist.begin()+2,ilist.end()-1);

ilist3初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容，在本例中ilist3被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，
因此迭代器来自不同的容器是可能的，例如，用一个double的list的范围来初始化ilist3是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并没有区别。
这种初始化方法特别适合于获取一个序列的子序列。
(5): vector<int> ilist4(7);
默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。
(6):vector<int> ilist5(7,3);
指定值初始化，ilist5被初始化为包含7个值为3的int


82  int epoll_ctl(int epfd, intop, int fd, struct epoll_event*event); 

   epoll的事件注册函数，
   第一个参数是epoll_create()的返回值，
   第二个参数表示动作，用三个宏来表示：
   EPOLL_CTL_ADD：       注册新的fd到epfd中；
   EPOLL_CTL_MOD：      修改已经注册的fd的监听事件；
   EPOLL_CTL_DEL：        从epfd中删除一个fd；
   第三个参数是需要监听的fd，
   第四个参数是告诉内核需要监听什么事件，structepoll_event结构如下：
   
   EPOLLOUT事件只有在连接时触发一次，表示可写，其他时候想要触发，那你要先准备好下面条件：
   1.某次write，写满了发送缓冲区，返回错误码为EAGAIN。
   2.对端读取了一些数据，又重新可写了，此时会触发EPOLLOUT
   简单地说：EPOLLOUT事件只有在不可写到可写的转变时刻，才会触发一次，所以叫边缘触发，这叫法没错的
   
   EPOLLIN事件则只有当对端有数据写入时才会触发，所以触发一次后需要不断读取所有数据直到读完EAGAIN为止。
   否则剩下的数据只有在下次对端有写入时才能一起取出来了
   
   EAGAIN，提示你的应用程序现在没有数据可读请稍后再试
   
   EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
   EPOLLOUT：表示对应的文件描述符可以写；
   EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
   EPOLLERR：表示对应的文件描述符发生错误；
   EPOLLHUP：表示对应的文件描述符被挂断； 表示读写都关闭;
   EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
   EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
   
   
   
   
 
 83 std::map 
   1.  void erase (iterator position);
   2.  size_type erase (const key_type& k);
   3.  void erase (iterator first, iterator last);

 for(ITER iter=mapTest.begin();iter!=mapTest.end();)
{
cout<<iter->first<<":"<<iter->second<<endl;
mapTest.erase(iter++);
}
 
 84 int pthread_setspecific(pthread_key_t key, const void *value);
   void *pthread_getspecific(pthread_key_t key);
   int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
   下面说一下线程中特有的线程存储， Thread Specific Data 。线程存储有什么用了？他是什么意思了？大家都知道，
   在多线程程序中，所有线程共享程序中的变量。
   现在有一全局变量，所有线程都可以使用它，改变它的值。而如果每个线程希望能单独拥有它，那么就需要使用线程存储了。
   表面上看起来这是一个全局变量，所有线程都可以使用它，而它的值在每一个线程中又是单独存储的。这就是线程存储的意义
   
   在多线程的环境下，进程内的所有线程共享进程的数据空间。因此全局变量为所有线程共享。在程序设计中有时需要保存线程自己的全局变量，这种特殊的变量仅在线程内部有效。
   如常见的errno，它返回标准的错误码。errno不应该是一个局部变量。几乎每个函数都应该可以访问他，但他又不能作为是一个全局变量。否则在一个线程里输出的很可能是另一个线程的
   出错信息，这个问题可以通过创建线程的私有数据（TSD  thread specific data）来解决。在线程内部，私有数据可以被各个函数访问。但他对其他线程是屏蔽的。
   线程私有数据采用了一键多值的技术，即一个键对应多个值。访问数据时都是通过键值来访问，好像是对一个变量进行访问，其实是在访问不同的数据。
   int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，
   如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。
   key一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名而不同值的全局变量，一键多值。
   一键多值靠的是一个关键数据结构数组即TSD池，创建一个TSD就相当于将结构数组中的某一项设置为“in_use”，并将其索引返回给*key，然后设置清理函数。
   1、创建一个键
   2、为一个键设置线程私有数据
   3、从一个键读取线程私有数据void *pthread_getspecific(pthread_key_t key);
   4、线程退出（退出时，会调用destructor释放分配的缓存，参数是key所关联的数据）
   5、删除一个键
   int pthread_setspecific(pthread_key_t key,const void *pointer));
   void *pthread_getspecific(pthread_key_t key);
   set是把一个变量的地址告诉key，一般放在变量定义之后，get会把这个地址读出来，然后你自己转义成相应的类型再去操作，注意变量的有效期。
   只不过，在不同的线程里可以操作同一个key，他们不会冲突，比如线程a,b,c set同样的key，分别get得到的地址会是之前各自传进去的值。
   这样做的意义在于，可以写一份线程代码，通过key的方式多线程操作不同的数据。
   int pthread_setspecific(pthread_key_t key, const void *value)；该函数将value的值（不是内容）与key相关联。用pthread_setspecific为一个键指定新的线程数据时，
   线程必须先释放原有的线程数据用以回收空间。
   nt pthread_key_delete(pthread_key_t key);用来删除一个键，删除后，键所占用的内存将被释放。注销一个TSD，这个函数并不检查当前是否有线程正使用该TSD，也不会调用清理函数（destr_function），
   而只是将TSD释放以供下一次调用pthread_key_create()使用。需要注意的是，键占用的内存被释放。与该键关联的线程数据所占用的内存并不被释放。因此，线程数据的释放，必须在释放键之前完成
    1    创建一个类型为pthread_key_t类型的变量。
    2    调用 pthread_key_create(pthread_key_t *key, void (*destructor)(void*))来创建该变量。
   该函数有两个参数，第一个参数就是上面声明的pthread_key_t变量，第二个参数是一个清理函数，
   用来在线程释放该线程存储的时候被调用。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。
   该函数成功返回0.其他任何返回值都表示出现了错误。
   pthread_key_create 只需要调用一次 表面上key看起来这是一个全局变量，所有线程都可以使用它，
   而它的值在每一个线程中又是单独存储的
    3  当线程中需要存储特殊值的时候，可以调用 pthread_setspecific() 。该函数有两个参数，第一个为前面声明的pthread_key_t变量，
    第二个为void*变量，这样你可以存储任何类型的值。
    4   如果需要取出所存储的值，调用pthread_getspecific()。该函数的参数为前面提到的pthread_key_t变量，该函数返回void *类型的值。下面是前面提到的函数的原型：

85 int pthread_key_delete(pthread_key_t key);用来删除一个键，删除后，键所占用的内存将被释放。注销一个TSD，这个函数并不检查当前是否有线程正使用该TSD，
   也不会调用清理函数（destr_function），而只是将TSD释放以供下一次调用pthread_key_create()使用。需要注意的是，键占用的内存被释放。与该键关联的线程数据所占用的内存并不被释放。
   因此，线程数据的释放，必须在释放键之前完成
   
86 儒略历日数
     科普小知识：天文学把24小时算作一个周期，起始和结束都是正午，这种整周期数就是儒略历日数。儒略历日的0是很久很久以前。一个方便的参考点事儒略历日244000起始于1968年5月23日。
     如果知道历书中某天正午起始的儒略历日数，那么将其加1再对7求模，就可以知道该天是星期几。结果是0对应星期天，1对应星期一，由此类推

87 gcc 原子操作 这些函数不需要头文件
  n++类 
type __sync_fetch_and_add(type *ptr, type value, ...); // m+n
type __sync_fetch_and_sub(type *ptr, type value, ...); // m-n
type __sync_fetch_and_or(type *ptr, type value, ...);  // m|n
type __sync_fetch_and_and(type *ptr, type value, ...); // m&n
type __sync_fetch_and_xor(type *ptr, type value, ...); // m^n
type __sync_fetch_and_nand(type *ptr, type value, ...); // (~m)&n
/* 对应的伪代码 */
{ tmp = *ptr; *ptr op= value; return tmp; }  //op 类似于 + - 
{ tmp = *ptr; *ptr = (~tmp) & value; return tmp; }   // nand

++n类
type __sync_add_and_fetch(type *ptr, type value, ...); // m+n
type __sync_sub_and_fetch(type *ptr, type value, ...); // m-n
type __sync_or_and_fetch(type *ptr, type value, ...); // m|n
type __sync_and_and_fetch(type *ptr, type value, ...); // m&n
type __sync_xor_and_fetch(type *ptr, type value, ...); // m^n
type __sync_nand_and_fetch(type *ptr, type value, ...); // (~m)&n
/* 对应的伪代码 */
{ *ptr op= value; return *ptr; }
{ *ptr = (~*ptr) & value; return *ptr; } // nand

4.CAS类  compare and swap    CAS，就是不使用系统提供的锁，而是直接利用cpu提供的指令，实现互斥操
  
 bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...);
type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...);
/* 对应的伪代码 */
{ if (*ptr == oldval) { *ptr = newval; return true; } else { return false; } }
{ tmp = *ptr; if (*ptr == oldval) { *ptr = newval; } return tmp; } 
	
	
88 int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；
本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。

89 int atexit (void (*)(void))）atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数
	⼀个进程可以登记若⼲个（具体⾃⼰验证⼀下）个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理函数， 
	atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反（网上很多说造成顺序相反的原因是参数压栈造成的，
	参数的压栈是先进后出，和函数的栈帧相同），如果⼀个函数被多次登记，也会被多次调⽤

90 void std::vector::resize (size_type n);
   void std::vector::resize (size_type n, const value_type& val);
   如果n比当前的vector元素数目要小，vector的容量要缩减到resize的第一个参数大小，既n。并移除那些超出n的元素同时销毁他们。
   比当前vector元素数目要大，在vector的末尾扩展需要的元素数目，如果第二个参数val指定了，扩展的新元素初始化为val的副本，
   类型默认初始化

91 void std::vector::reserve (size_type n);
   reserve表示容器预留空间,实际申请的内存不小于n
  
92 std::search() 
   ForwardIterator search (ForwardIterator first1, ForwardIterator last1,
   ForwardIterator first2, ForwardIterator last2);
   search() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last1 迭代器相同

93 std::find_end()

94  函数原型：extern int memcmp(void *str1, void *str2, unsigned int n)
    参数说明：str1和str2为指定作比较的字符串，比较两个字符串的前n个字节。
    memcmp函数实现的是字节的比较，而不是字符的比较。

95 函数原型：extern int memicmp(void *str1, void *str2, unsigned int count)
   *参数说明：str1和str2为指定作比较的字符串，比较两个字符串的前count个字节，不区分大小写。

96 函数原型extern void *memchr(const void *buf, int ch, size_t count)
   功能：从buf所指内存区域的前count个字节查找字符ch。
   说明：当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回NULL。

97 std::copy 
  std::copy(start, end, std::back_inserter(container));  
  这里，start和end是输入序列（假设有N个元素）的迭代器（iterator），container是一个容器，该容器的接口包含函数push_back。
  假设container开始是空的，那么copy完毕后它就包含N个元素，并且顺序与原来队列中的元素顺序一样。标准库提供的back_inserter模板函数很方便，
  因为它为container返回一个back_insert_iterator迭代器，这样，复制的元素都被追加到container的末尾了

98 uLong ZEXPORT adler32 (uLong adler, const Bytef *buf, uInt len)

99 void *memset (void *__s, int __c, size_t __n)

100  timerfd是Linux为用户程序提供的一个定时器接口。这个接口基于文件描述符，通过文件描述符的可读事件进行超时通知，所以能够被用于select/poll的应用场景
     编译时加编译选项 -lrt      ???
     timerfd是每个进程唯一的吗  ???

	 int timerfd_create(int clockid, int flags); 
		timerfd_create（）函数创建一个定时器对象，同时返回一个与之关联的文件描述符。
		clockid：clockid标识指定的时钟计数器，可选值（CLOCK_REALTIME、CLOCK_MONOTONIC。。。）
		CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户改成其他,则对应的时间相应改变
		CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响
		flags：参数flags（TFD_NONBLOCK(非阻塞模式)/TFD_CLOEXEC（表示当程序执行exec函数时本fd将被系统自动关闭,表示不传递）	
        
        O_CLOEXEC : 在进程执行exec系统调用时关闭此打开的文件描述符。防止父进程泄露打开的文件给子进程，即便子进程没有相应权限 
     
     int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);
     函数返回0代表设置成功
        
        struct itimerspec {
            struct timespec it_interval;
            struct timespec it_value;
        };
        
	 	struct timespec {
      		time_t tv_sec;                /* Seconds */
      		long   tv_nsec;               /* Nanoseconds */
  		};
	 timerfd_settime()此函数用于设置新的超时时间，并开始计时,能够启动和停止定时器;
     fd: 参数fd是timerfd_create函数返回的文件句柄
     flags：参数flags为1代表设置的是绝对时间（TFD_TIMER_ABSTIME 表示绝对定时器）；为0代表相对时间。
     new_value: 参数new_value指定定时器的超时时间以及超时间隔时间
     old_value: 如果old_value不为NULL, old_vlaue返回之前定时器设置的超时时间，具体参考timerfd_gettime()函数
     it_interval不为0则表示是周期性定时器。
     it_value和it_interval都为0表示停止定时器
		
     timerfd_settime：能够启动和停止定时器；可以设置第二个参数：flags，0表示是相对定时器，TFD_TIMER_ABSTIME表示是绝对定时器。
     第三个参数设置超时时间，如果为0则表示停止定时器。定时器设置超时方法：
     设置超时时间是需要调用clock_gettime获取当前时间，如果是绝对定时器，那么需要获取CLOCK_REALTIME，在加上要超时的时间。
     如果是相对定时器，要获取CLOCK_MONOTONIC时间
		
  
  		struct itimerspec {
     		struct timespec it_interval;  /* Interval for periodic timer （定时间隔周期）*/
     		struct timespec it_value;     /* Initial expiration (第一次超时时间)*/
 		};
	 
     int timerfd_gettime(int fd, struct itimerspec *curr_value);
	 
	 timerfd_gettime()函数获取距离下次超时剩余的时间
      curr_value.it_value 字段表示距离下次超时的时间，如果改值为0，表示计时器已经解除
      改字段表示的值永远是一个相对值，无论TFD_TIMER_ABSTIME是否被设置
      curr_value.it_interval 定时器间隔时间
	  
	  read函数可以读timerfd，读的内容为uint_64，表示超时次数
	
timefd_*系列函数优点:
 1. 这一组函数不涉及到信号，安全好用
 2. 这一组函数通过操作时间相关的文件描述符实现功能，可以和其它的文件相关操作融为一体
 3. timerf_create(2)函数把时间变成了一个描述符，该文件描述符在定时器超时的那一刻变得可读，这样就方便融入select(2)或poll(2)中去
	 
	 
101   int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
     pthread_atfork()在fork()之前调用，当调用fork时，内部创建子进程前在父进程中会调用prepare，内部创建子进程成功后，父进程会调用parent ，子进程会调用child
	 
	 
102 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    timeout时间内监听到事件，会立即返回。 当timeout为-1是，epoll_wait调用将永远阻塞，直到某个时间发生。当timeout为0时，epoll_wait调用将立即返回.
	epoll_create()、
	epoll_ctl()、
	epoll_wait()、
	close()
	
    POLLIN: 		有数据可读。
	POLLRDNORM: 	有普通数据可读。
	POLLRDBAND:     有优先数据可读。
	POLLPRI:		有紧迫数据可读。
	POLLOUT:		写数据不会导致阻塞。
	POLLWRNORM:		写普通数据不会导致阻塞。
	POLLWRBAND:		写优先数据不会导致阻塞。
	//POLLMSG:	SIGPOLL 消息可用。

	此外，revents域中还可能返回下列事件：
	POLLER:		指定的文件描述符发生错误。
	POLLHUP:	指定的文件描述符挂起事件。
	POLLNVAL:	指定的文件描述符非法。
	
    该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误，需要检查 errno错误码判断错误类型

103 	#include <arpe/inet.h>
   这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。
   地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值
   
   int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1
 
   const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
   
104 size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);  strftime是一种计算机函数，根据区域设置格式化本地时间/日期，函数的功能：将时间格式化！！！，或者说格式化一个时间字符串

105 struct tm *localtime_r(const time_t *timep, struct tm *result); // 根据timep 返回本地时区时间信息
    struct tm *gmtime_r(const time_t *timep, struct tm *result); // 根据timep 返回utc时区时间信息
	
	
106  读写锁 
初始化一个读写锁pthread_rwlock_init
读锁定读写锁      pthread_rwlock_rdlock
非阻塞读锁定　　pthread_rwlock_tryrdlock
写锁定读写锁      pthread_rwlock_wrlock
非阻塞写锁定      pthread_rwlock_trywrlock
解锁读写锁         pthread_rwlock_unlock
释放读写锁         pthread_rwlock_destroy

107 获取或设定资源使用限制
	int getrlimit(int resource, struct rlimit *rlim);
	int setrlimit(int resource, const struct rlimit *rlim);
	
resource：可能的选择有
RLIMIT_AS //进程的最大虚内存空间，字节为单位。
RLIMIT_CORE //内核转存文件的最大长度。
RLIMIT_CPU //最大允许的CPU使用时间，秒为单位

struct rlimit {
　　rlim_t rlim_cur;　　//soft limit
　　rlim_t rlim_max;　　//hard limit
};

108  char * basename(char *path)  截取path中的去目录部分的最后的文件或路径名  失败： 返回 NULL
     char *dirname(char *path);  返回截取path中的目录路径指针   失败： 返回 NULL

    path         dirname    basename
    "/usr/lib"    "/usr"    "lib"
    "/usr/"       "/"       "usr"
    "usr"         "."       "usr"
    "/"           "/"       "/"
    "."           "."       "."
    ".."          "."       ".."
	
109 std::mt19937_64  C++11生成32位/64位随机数

110 int getopt(int argc,char * const argv[ ],const char * optstring);

111 #define	EXIT_FAILURE	1	/* Failing exit status.  */
    #define	EXIT_SUCCESS	0
	
112 int chdir（const char * path）;  函数说明：chdir（）用户将当前的工作目录改变成以参数路径所指的目录。

113 char * getcwd(char * buf, size_t size);  getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。

114 int dup(int oldfd);                复制一个已经存在的文件描述符，如果成功，返回复制成功后的文件描述符，失败返回-1
    
	int dup2(int fd, int fd2);    复制一个文件描述符，fd表示已经存在的打开的文件描述符，fd2是指定新的文件描述符，如果fd2等于fd，则直接返回，如果fd2存在并且打开，
	                                   则先close(fd2)后，重新打开，这样fd2和fd就指向了同一个文件（共享打开的文件），如果fd2不存在或者没有打开，
									   则打开fd2，并且指向fd所指向的文件。函数的返回值和fd2一致。该函数可以实现文件的重定位
                                  返回值：
                                  若dup2调用成功则返回新的文件描述符，出错则返回-1
    int dup2(int oldfd, intnewfd);  将已有的一个newfd重定向到oldfd的位置，返回第一个不小于oldfd的整数值
								
115  pid_t setsid(void); 
	当进程是会话组长时setsid()调用失败。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。
	由于会话过程对控制终端的独占性，进程同时与控制终端脱离

  在Linux系统下，每一个进程都有惟一的一个定时器，该定时器提供了以秒为单位的定时功能。在定时器设置的超时时间到达后，调用alarm的进程将收到SIGALRM信号
  unsigned int alarm(unsigned int seconds);
參数说明：
1）seconds：要设定的定时时间，以秒为单位。在alarm调用成功后開始计时。超过该时间将触发SIGALRM信号。
返回值：
返回当前进程曾经设置的定时器剩余秒数
  
  
116 int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
    struct itimerval 
{
	/* Interval for periodic timer */
	struct timeval it_interval;
	/* Time until next expiration */ 
	struct timeval it_value;    
};
struct timeval 
{
	time_t      tv_sec;         /* seconds */
	suseconds_t tv_usec;        /* microseconds 1/1000000 seconds */
};

  new_value： 参数用来对计时器进行设置，it_interval为计时间隔，it_value为延时时长，下面例子中表示的是在setitimer方法调用成功后，延时it_value后触发一次SIGALRM信号，以后每隔it_interval触发一次SIGALRM信号。
  settimer工作机制是，先对it_value倒计时，当it_value为零时触发信号，然后重置为it_interval，继续对it_value倒计时，一直这样循环下去
  
117 shared_from_this()
    c++11中的shared_from_this()来源于boost中的enable_shared_form_this类和shared_from_this()函数，功能为返回一个当前类的std::share_ptr,使用方法如下


118 C++11的chrono库

119 bool __sync_bool_compare_and_swap (type*ptr, type oldval, type newval, ...)
    type __sync_val_compare_and_swap (type *ptr, type oldval,  type newval, ...)
    这两个函数提供原子的比较和交换，如果*ptr == oldval,就将newval写入*ptr,
    第一个函数在相等并写入的情况下返回true.
    第二个函数在返回操作之前的值。

120 type __sync_lock_test_and_set (type *ptr, type value, ...)
    将*ptr设为value并返回*ptr操作之前的值。

121 void __sync_lock_release (type *ptr, ...)
    将*ptr置0
	
	
121  __sync_synchronize()  内存屏障
    内存屏障是一个程序员要面对的涉及CPU方面知识的一个问题。在多核多线程的情况下，如果你不知道这个CPU乱序执行这个问题的话，将会是一场噩梦，
	无论怎么进行代码走读也不可能发现的bug。不过只要加上一个__sync_synchronize()  问题就迎刃而解

	
122  int sscanf (const char *str,const char * format,........);
     sscanf()会将参数str的字符串根据参数format字符串来转换并格式化数据
	  返回值 成功则返回参数数目，失败则返回-1，错误原因存于errno中。 返回0表示失败    否则，表示正确格式化数据的个数    
	  例如：sscanf(str，"%d%d%s", &i,&i2, &s);    如果三个变成都读入成功会返回3。    如果只读入了第一个整数到i则会返回1。
	 
	 char str[100]; sscanf("12345","%4s",str); printf("%s\n",str); 输出"1234"
	char str[100];  sscanf("12345","%s",str);  printf("%s\n",str);  输出12345
	char str1[100], str2[100], str3[100]; gets(str1); sscanf(str1,"%s%s",str2,str3); printf("%s %s\n",str2,str3); 输入"hello world hello" 输出"hello world"
	
123 信号集处理函数
int sigemptyset(sigset_t *set);  //清空set信号集中的所有信号
int sigfillset(sigset_t *set);  //将所有的信号赋给set信号集
int sigaddset(sigset_t *set, int signo);  //将signo信号加入到set信号集中
int sigdelset(sigset_t *set, int signo);  //将set信号集中的signo信号移除
//这4和函数的返回值：成功返回0;出错返回-1

int sigismember(const sigset_t *set, int signo);  //判断signo信号是否在set信号集中
	
124 int sigaction(int signum,const struct sigaction *act ,struct sigaction *oldact) 
        sigaction函数用来查询和设置信号处理方式，它是用来替换早期的signal函数
            signum     可以指定SIGKILL和SIGSTOP以外的所有信号
            signum参数指出要捕获的信号类型，act参数指定新的信号处理方式，oldact参数输出先前信号的处理方式（如果不为NULL的话）
struct sigaction
{
void (*sa_handler) (int);
void  (*sa_sigaction)(int, siginfo_t *, void *);
sigset_t sa_mask;
int sa_flags;
void (*sa_restorer) (void);
}
sa_handler：此参数和signal()的参数handler相同，此参数主要用来对信号旧的安装函数signal()处理形式的支持  SIG_IGN 忽略信号
sa_sigaction：新的信号安装机制，处理函数被调用的时候，不但可以得到信号编号，而且可以获悉被调用的原因以及产生问题的上下文的相关信息。
sa_mask：用来设置在处理该信号时暂时将sa_mask指定的信号搁置
sa_restorer： 此参数没有使用
sa_flags：用来设置信号处理的其他相关操作，下列的数值可用。可用OR 运算（|）组合
A_NOCLDSTOP:如果参数signum为SIGCHLD，则当子进程暂停时并不会通知父进程
SA_ONESHOT/SA_RESETHAND:当调用新的信号处理函数前，将此信号处理方式改为系统预设的方式
SA_RESTART:被信号中断的系统调用会自行重启  //http://blog.chinaunix.net/uid-28414100-id-5751154.html  应该是函数还会继续等待执行/执行
 void int_handler (int signum)
  {
          printf ("int handler %d/n",signum);
  }
 
  int main(int argc, char **argv)
  {
          char buf[100];
          ssize_t ret;
          struct sigaction oldact;
          struct sigaction act;
 
          act.sa_handler = int_handler;
          act.sa_flags=0;
          act.sa_flags |= SA_RESTART;
          sigemptyset(&act.sa_mask);
          if (-1 == sigaction(SIGINT,&act,&oldact))
          {
                  printf("sigaction failed!/n");
                  return -1;
          }
 
          bzero(buf,100);
 
          ret = read(STDIN_FILENO,buf,10);
          if (ret == -1)
          {
                  printf ("read error %s/n", strerror(errn    o))
          }
          printf ("read %d bytes, content is %s/n",ret,buf    );
          sleep (10);
          return 0;
  }



^Cint handler 2
^Cint handler 2
^Cint handler 2
^Cint handler 2
^Cint handler 2
^Cint handler 2
hgfd
read 5 bytes, content is hgfd
SA_NOMASK/SA_NODEFER:在处理此信号未结束前不理会此信号的再次到来
SA_SIGINFO：信号处理函数是带有三个参数的sa_sigaction
	
125  int clock_getres(clockid_t clk_id, struct timespec *res); 获取对应时钟类型能够提供的时间精确度 
CLOCK_REALTIME:             系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,
                                   //中间时刻如果系统时间被用户改成其他,则对应的时间相应改变
CLOCK_MONOTONIC:            从系统启动这一刻起开始计时,不受系统时间被用户改变的影响
CLOCK_PROCESS_CPUTIME_ID:   本进程到当前代码系统CPU花费的时间
CLOCK_THREAD_CPUTIME_ID:    本线程到当前代码系统CPU花费的时间

struct timespec { 
    time_t   tv_sec;        /* seconds */
	long     tv_nsec;       /* nanoseconds 纳秒*/
};

126   int pipe(int pipefd[2]);  成功：0；失败：-1，设置errno  //https://blog.csdn.net/qq_42914528/article/details/82023408
      函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w
读管道： 
1. 管道中有数据，read返回实际读到的字节数。
2. 管道中无数据：
(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)
(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)

写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)
2. 管道读端没有全部关闭：
(1) 管道已满，write阻塞。
(2) 管道未满，write将数据写入，并返回实际写入的字节数。

管道容量分为pipi capacity 和 pipe_buf .这两者的区别在于pipe_buf定义的是内核管道缓冲区的大小，
这个值的大小是由内核设定的，这个值仅需一条命令就可以查到； ulimit -a ; sizeof(pipe_buf)= 512 bytes* 8 = 4k byte

而pipe capacity指的是管道的最大值，即容量 通过不断写 可以写入65536 字节

127  int setjmp(jmp_buf jb);
     void longjmp(jmp_buf jb, int r);
  setjmp用于保存当前AR到jb变量中；
  而longjmp用于设置当前AR为jb，并跳转到调用setjmp()；之后的第一个语句处。其结果就相当于回到了setjmp()刚执行完毕，只是偷偷的修改了setjmp的返回值。
  setjmp()第一次调用时总是返回0，而通过longjmp(jb,r)跳转后其返回值总是被修改为r，并且r不能为0。这样程序中就很容易根据setjmp()的返回值来判断是否是longjmp()导致了跳转才执行到此
  
128 int system(const char*command)  std::system("ls -l >test.txt");
   执行shell 命令
   
   
129 void sync(void); 
   在操作系统中，除非设置了自动同步，否则为了减少磁盘的写入量，延长磁盘寿命，写入文件时并不是即时写入到磁盘中，
   而是先写入内存，这段内存区域被称为系统缓冲区。在系统缓冲区数据累计到一定数量后（具体数量因系统实际设置而定），
   会有系统进程一次性写入所有缓冲数据。这样，如果意外断电，那么系统缓冲区内数据就会因此丢失
   
130 int daemon(int nochdir, int noclose); daemon()函数适用于希望从控制终端脱离并作为系统守护进程在后台运行的程序
    如果nochdir为零，daemon()将进程的当前工作目录更改为根目录（“/”）; 否则，当前工作目录保持不变。
    如果noclose为零，daemon()将标准输入，标准输出和标准错误重定向到/dev/null; 否则，不会对这些文件描述符进行更改。(参数为0时有效)
    返回值：
    deamon()调用了fork()，如果fork成功，那么父进程就调用_exit()退出，因此只能通过子进程看到进一步的错误。如果成功函数返回0，否则返回-1并设置errno

131 int access(const char *pathname, int mode); 判断文件权限
    R_OK 只判断是否有读权限
	W_OK 只判断是否有写权限
	X_OK 判断是否有执行权限
	F_OK 只判断是否存在
    
    成功返回0 失败返回-1

132 char *strtok_r(char *str, const char *delim, char **saveptr);
   
   str是传入的字符串。需要注意的是  ：第一次使用strtok_r之后，要把str置为NULL,
   delim指向依据分割的字符串。常见的空格“ ”    逗号“,”等
   saveptr保存剩下待分割的字符串

133  boost::spirit 

134 long int strtol(const char *nptr, char **endptr, int base)             long long int strtoll(const char *nptr, char **endptr, int base);
    strtol()会将nptr指向的字符串，根据参数base，按权转化为long int, 然后返回这个值。
参数base的范围为2~36,和0；它决定了字符串以被转换为整数的权值。
可以被转换的合法字符依据base而定，举例来说，当base为2时，合法字符为‘0’，‘1’；base为8时，合法字符为‘0’，‘1’，……‘7’；
 base为10时，合法字符为‘0’，‘1’，……‘9’；base 为16时，合法字符为‘0’，‘1’，……‘9’，‘a’，……‘f’；base为24时，合法字符为‘0’，……‘9’，‘a’，……‘n’，base为36时，
 合法字符为‘0’，……‘9’，‘a’，……‘z’；等等。其中，不区分大小写，比如，‘A’和‘a’会都会被转化为10。
当字符合法时，‘0’，……‘9’依次被转换为十进制的0～9，‘a’，……‘z’一次北转换为十进制的10～35。
strtol()函数检测到第一个非法字符时，立即停止检测，其后的所有字符都会被当作非法字符处理。合法字符串会被转换为long int, 作为函数的返回值。
非法字符串，即从第一个非法字符的地址，被赋给*endptr。**endptr是个双重指针，即指针的指针。strtol()函数就是通过它改变*endptr的值，即把第一个非法字符的地址传给endptr

135 #include <signal.h> 
int sigemptyset(sigset_t *set);                //清空set信号集中的所有信号 
int sigfillset(sigset_t *set);                 //将所有的信号赋给set信号集
int sigaddset(sigset_t *set, int signo);       //将signo信号加入到set信号集中
int sigdelset(sigset_t *set, int signo);       //将set信号集中的signo信号移除
//这4和函数的返回值：成功返回0;出错返回-1
int sigismember(const sigset_t *set, int signo);  //判断signo信号是否在set信号集中
//返回值：若为真返回1;若为假返回-1
信号集类型
  1.概念：一种类型，能够保存多个信号
  2.类型：sigset_t

136 int kill(pid_t pid, int sig);   用于向任何进程组或进程发送信号 kill(getpid(),sig)
pid：可能选择有以下四种
1. pid大于零时，pid是信号欲送往的进程的标识。
2. pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。
3. pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。
4. pid小于-1时，信号将送往以-pid为组标识的进程。

sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在执行
返回值说明： 成功执行时，返回0。失败返回-1，errno被设为以下的某个值 EINVAL：指定的信号码无效（参数 sig 不合法） 
           EPERM；权限不够无法传送信号给指定进程 ESRCH：参数 pid 所指定的进程或进程组不存在
		 
137 int fscanf(FILE *stream, const char *format, ...);
    fscanf() 返回参数列表中被成功赋值的参数个数

138 int daemon(int nochdir, int noclose);   daemon()函数主要用于希望脱离控制台，以守护进程形式在后台运行的程序
    参数nochdir为0时,即可将工作目录修改为根目录
	当noclose为0是，daemon将进程的STDIN, STDOUT, STDERR都重定向到/dev/null
	如果成功函数返回0，否则返回-1并设置errno
	
139 int flock(int fd,int operation);会依参数operation所指定的方式对参数fd所指的文件做各种锁定或解除锁定的动作。
                                    此函数只能锁定整个文件，无法锁定文件的某一区域
   参数 operation有下列四种情况:
   LOCK_SH 建立共享锁定。多个进程可同时对同一个文件作共享锁定。
   LOCK_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。
   LOCK_UN 解除文件锁定状态。
   LOCK_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。通常与LOCK_SH或LOCK_EX 做OR(|)组合。
   单一文件无法同时建立共享锁定和互斥锁定，而当使用dup()或fork()时文件描述词不会继承此种锁定。
   返回值 返回0表示成功，若有错误则返回-1，错误代码存于errno。

140  首先介绍一个重要的结构体：fd_set，它会作为下面某些函数的参数而多次用到，fd_set可以理解为一个集合，
     这个集合中存放的是文件描述符(file descriptor)，即文件句柄
	 
	 1》FD_ZERO
     用法：FD_ZERO(fd_set*);
     用来清空fd_set集合，即让fd_set集合不再包含任何文件句柄。
     2》FD_SET
     用法：FD_SET(int ,fd_set *);
     用来将一个给定的文件描述符加入集合之中
     3》FD_CLR
     用法：FD_CLR(int ,fd_set*);
     用来将一个给定的文件描述符从集合中删除
     4》FD_ISSET
     用法：FD_ISSET(int ,fd_set*);
     检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真，否则，返回假（也可以认为集合中指定的文件描述符是否可以读写）。

140	 int select(int maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout);
      select()用来等待文件描述词状态的改变。参数n代表最大的文件描述词加1，参数readfds、writefds和exceptfds 称为描述词组，是用来回传该描述词的读，写或例外的状况
      https://blog.csdn.net/hmxz2nn/article/details/79777372
1.   int n:是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！
2.   fd_set*readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，
     如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，
     若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化
3.   writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，
     如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，
     若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化
4.   fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常
5.   timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态，第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，
     一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，
	 文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，
	 否则在超时后不管怎样一定返回，返回值同上述.

6.   返回值: 正值：某些文件可读写或出错     0：等待超时，没有可读写或错误的文件    负值：select错误
     返回值：错误返回-1，超时返回0。当关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。
     
	 FD_ZERO(fd_set* fdset)： 将fd_set变量的所有位初始化为0。
     FD_SET（int fd, fd_set* fdset）：在参数fd_set指向的变量中注册文件描述符fd的信息。
     FD_CLR(int fd, fd_set* fdset)：参数fd_set指向的变量中清除文件描述符fd的信息。
     FD_ISSET(int fd, fd_set* fdset)：若参数fd_set指向的变量中包含文件描述符fd的信息，则返回真。


141  FD_SETSIZE 

通常，操作系统通过宏FD_SETSIZE来声明在一个进程中select所能操作的文件描述符的最大数目。例如：
在4.4BSD的头文件中我们可以看到：
＃ifndef FD_SETSIZE
#define FD_SETSIZE 1024
#endif
在红帽Linux的头文件<bits/types.h>中我们可以看到：
＃define __FD_SETSIZE 1024
以及在头文件<sys/select.h>中我们可以看到：
#include <bits/types.h>
#define FD_SETSIZE __FD_SETSIZE
既定义FD_SETSIZE为1024，一个整数占4个字节，既32位，那么就是用包含32个元素的整数数组来表示文件描述符集

142 unsigned long int strtoul(const char *nptr, char **endptr, int base);           //字符数字转换
    unsigned long long int strtoull(const char *nptr, char **endptr,int base);      //字符数字转换
	
143 int vsnprintf(char* str, size_t size, const char* format, va_list ap);
	str 把生成的格式化的字符串存放在这里.
    size str可接受的最大字节数,防止产生数组越界.
    format 指定输出格式的字符串，它决定了你需要提供的可变参数的类型、个数和顺序。
    ap 可变参数
函数功能：将可变参数格式化输出到一个字符数组。
返回值：执行成功，返回写入到字符数组str中的字符个数（不包含终止符），最大不超过size；执行失败，返回负值，并置errno.[1] 

144  std::setprecision( ) 浮点数位数

145 int usleep(useconds_t usec);    //睡眠 ，单位微秒

146 ssize_t read(int fd,void*buf,size_t count)

fd: 是文件描述符, 从command line获取数据时，为0
buf: 为读出数据的缓冲区；
count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保
存在缓冲区buf中，同时文件的当前读写位置向后移）
返回值:
成功：返回读出的字节数
失败：返回-1，并设置errno，如果在调用read
之前到达文件末尾，则这次read返回0

147 ssize_t write(int fd,const void*buf,size_t count);
参数说明：
fd:是文件描述符（输出到command line，就是1）
buf:通常是一个字符串，需要写入的字符串
count：是每次写入的字节数
返回值:
成功：返回写入的字节数
失败：返回-1并设置errno
ps： 写常规文件时，write的返回值通常等于请求写的字节
数count， 而向终端设备或者网络写时则不一定


读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。
从终端设备读，通常以行为单位，读到换行符就返回了。
从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数，后面socket编程部分会详细讲解

写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定。
读常规文件是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回。从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，
如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。同样，写常规文件是不会阻塞的，
而向终端设备或网络写则不一定。

现在明确一下阻塞（Block）这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行，
直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行（Running）状态，
在Linux内核中，处于运行状态的进程分为两种情况
   1. 正在被调度执行。CPU处于该进程的上下文环境中，程序计数器（eip）里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，
      正在读写该进程的地址空间。
   2. 就绪状态。该进程不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，
      那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，
	  同时要兼顾用户体验，不能让和用户交互的进程响应太慢

如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。以read为例，如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK
（或者EAGAIN，这两个宏定义的值相同），表示本来应该阻塞在这里（would block，虚拟语气），事实上并没有阻塞而是直接返回错误，调用者应该试着再读一次（again）。
这种行为方式称为轮询（Poll），调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备



148

typedef struct ucontext_t
  {
    unsigned long int __ctx(uc_flags);
    struct ucontext_t *uc_link;           //为当前context执行结束之后要执行的下一个context，若uc_link为空，执行完当前context之后退出程序
    stack_t uc_stack;                     //为当前context运行的栈信息
    mcontext_t uc_mcontext;               //保存具体的程序执行上下文，如PC值，堆栈指针以及寄存器值等信息。它的实现依赖于底层，是平台硬件相关的。此实现不透明
    sigset_t uc_sigmask;                  //执行当前上下文过程中需要屏蔽的信号列表，即信号掩码
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;



148  void makecontext(ucontext_t* ucp, void (*func)(), int argc, ...);
     初始化一个ucontext_t,func参数指明了该context的入口函数，argc为入口参数的个数，每个参数的类型必须是int类型。
	 另外在makecontext之前，一般需要显示的初始化栈信息以及信号掩码集同时也需要初始化uc_link，以便程序退出上下文后继续执行
149  int swapcontext(ucontext_t* olducp, ucontext_t* newucp);
     原子操作，该函数的工作是保存当前上下文并将上下文切换到新的上下文运行 , 运行newucp指定的上下文
150  int getcontext(ucontext_t* ucp);
     将当前的执行上下文保存在ucp中，以便后续恢复上下文
151  int setcontext(const ucontext_t* ucp);
     将当前程序切换到新的context,在执行正确的情况下该函数直接切换到新的执行状态，不会返回
 注意:setcontext执行成功不返回，getcontext执行成功返回0，若执行失败都返回-1。若uc_link为NULL,执行完新的上下文之后程序结束。

152  trdiff_t类型变量通常用来保存两个指针减法操作的结果  
     int *a=new int(1);        //0x5602ddc65280
     int *b=new int(2);        //0x5602ddc652a0
     ptrdiff_t result=a-b;     //-8

153  reverse  反转序列   //<algorithm>

154 unordered_set和unordered_map内部实现是基于哈希表(hashtable)

155 迭代器失效    (insert, erase都会导致迭代器失效)  
   (vector deque) erase()返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点） map没有返回值
    for(vector<int>::iterator iter = ivec.begin(); iter != ivec.end(); ) {
			if((*iter) %2 == 0){
				iter = ivec.erase(iter);
			} else {
                iter++;
            }
	}

    void deleteValueFromVector(Vec &v, int n = 5) {
        typedef vector<int> Vec;
        typedef vector<int>::iterator VecIt;
        VecIt it;
        for(it = v.begin(); it != v.end(); /*不能再自增了*/) {
            if(0 == *it % n) {
                v.erase(it); // vector元素自动向前挪动了(关联的map容器元素不会自动挪动)， 所以不能再把it进行++了,it 如果是最后一个有效值呢(这样也可以)
            } else {
                it++;
            }
        }
    }

    void deleteValueFromMap(Map &m, int n = 5) {
    typedef map<int, int> Map;
    typedef map<int, int>::iterator MapIt;
    MapIt it;
    for(it = m.begin(); it != m.end(); /*不能再自增了*/) {
        if(0 == it->second % n) {
            m.erase(it++);
        } else {
            it++;
        }
    }

156  int stat(const char *restrict path, struct stat *restrict buf);    //获取文件信息
    返回值：成功返回0，失败返回-1；
    ​参数：文件路径（名），struct stat 类型的结构体

    struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
    };



157  key_t ftok(const char *pathname, int proj_id);  //把从pathname导出的信息与id的低序8位组合成一个整数IPC键
    pathname：指定的文件，此文件必须存在且可存取
    proj_id：计划代号（project ID）
    系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值。通常情况下，该id值通过ftok函数得到
    在一般的UNIX实现中，是将文件的索引节点号取出，前面加上子序号得到key_t的返回值。如指定文件的索引节点号为65538，换算成16进制为 0x010002，
    而你指定的ID值为38，换算成16进制为0x26，则最后的key_t返回值为0x26010002。
    查询文件索引节点号的方法是： ls -i
成功：返回key_t值（即IPC 键值）
出错：-1，错误原因存于error中

158  int msgget(key_t key, int msgflg)  该函数用来创建和访问一个消息队列

159  size_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);   该函数用来从一个消息队列获取消息

msqid: 由消息队列的标识符
msgp :消息缓冲区指针。消息缓冲区结构为：
struct msgbuf {
long mtype;
char mtext[1];
｝
msgsz: 消息数据的长度
msgtyp: 决定从队列中返回哪条消息：
=0 返回消息队列中第一条消息
>0 返回消息队列中等于mtype 类型的第一条消息。
<0 返回mtype<=type 绝对值最小值的第一条消息。
msgflg 为０表示阻塞方式，设置IPC_NOWAIT 表示非阻塞方式
msgrcv 调用成功返回0，不成功返回-1。



160  int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);  用来向消息队列发送消息的
     msgflg 取0 忽略标志位， 取IPC_NOWAIT 如果消息队列已满，函数返回。否则会阻塞等待消息队列不为满，写入消息
     返回值 0 成功 -1 失败


170  喂狗  int ioctl(int fd, unsigned long request, ...);

171  int clock_gettime(clockid_t clk_id, struct timespec* tp);

clk_id : 检索和设置的clk_id指定的时钟时间。
CLOCK_REALTIME:            系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,
                           中间时刻如果系统时间被用户改成其他,则对应的时间相应改变
CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响   //系统运行时间
CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间            //程序运行占用cpu时间，并不是程序运行时间
CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间
struct timespec {
        time_t tv_sec; /* 秒*/
        long tv_nsec; /* 纳秒*/
};

172   void shrink_to_fit();
      请求容器降低其容量和size匹配。
      该请求不具有约束力，容器可以自由地去执行其他的优化方案（capacity可以大于size）。//我查了一下网上说是该方法由编译器决定是否真正释放多余的内存，
      该方法值是提出请求，是否要实现由编译器说了算

173 int _access(char* path,int mode)
    头文件<io.h>
    功能：确定文件或文件夹的访问权限。如果指定的存取方式有效，则函数返回0，否则函数返回-1。
    参数path 是访问文件所在的路径名，mode是访问判断模式，
    具体含义如下：
    　　R_OK 只判断是否有读权限
    　　W_OK 只判断是否有写权限
    　　X_OK 判断是否有执行权限
    　　F_OK 只判断是否存在

174 int tcgetattr(int fd, struct termios *termios_p);    //用于获取与终端相关的参数，提供异步通讯接口      0：成功  -1：错误，
    struct termios *termios_p：返回值保留在termios结构体中：
           tcflag_t c_iflag;      /* input modes */             输入模式标识
           tcflag_t c_oflag;      /* output modes */            输出
           tcflag_t c_cflag;      /* control modes */           控制
           tcflag_t c_lflag;      /* local modes */             本地
           cc_t     c_cc[NCCS];   /* special characters */      控制字符，保存中断驱动程序中的特殊字符
    
    https://blog.csdn.net/dongshibo12/article/details/76209112

175 https://blog.csdn.net/qishi_blog/article/details/9238673
    波特率的设置通常使用cfsetospeed和cfsetispeed函数来完成。获取波特率信息是通过cfgetispeed和cfgetospeed函数来完成的
    int cfsetospeed(struct termios *termptr, speed_t speed);        如果成功返回0,否则返回-1
       struct termios *termptr - 指向termios结构的指针
       speed_t speed - 需要设置的输出波特率
    int cfsetispeed(struct termios *termptr, speed_t speed);        如果成功返回0,否则返回-1
        struct termios *termptr - 指向termios结构的指针
        speed_t speed - 需要设置的输入波特率

176 int tcflush(int fd, int queue_selector);
    fd                // 终端I/O打开的句柄 
    queue_selector    // 控制tcflush的操作，取值为下面三个常数中的一个：
        TCIFLUSH  // 清除正收到的数据，且不会读取出来。
        TCOFLUSH  // 清除正写入的数据，且不会发送至终端。
        TCIOFLUSH // 清除所有正在发生的I/O数据。
    返回值说明：
    0     // 成功
    -1    // 失败，并且为 errno 置值来指示错误

177   int tcsetattr(int fd, int optional_actions, const struct termios *termios_p); 函数用于设置终端的相关参数
      optional_actions可以取如下的值。
      TCSANOW：不等数据传输完毕就立即改变属性。
      TCSADRAIN：等待所有数据传输结束才改变属性。
      TCSAFLUSH：清空输入输出缓冲区才改变属性。

178  char *strsep(char **stringp, const char *delim);
    
   char str[] = "root:/root:/bin/bash";
　　char *buf;
　　char *token;
　　buf = str;
　　while((token = strsep(&buf, ":")) != NULL){
　　printf("%s/n", token);
　　}
    输出  root
         /root
         /bin/bash

179   double ldexp(double x, int exponent) 返回 x 乘以 2 的 exponent 次幂。 
      double sinh(double x)
         返回 x 的双曲正弦。
        9	double tanh(double x)
         返回 x 的双曲正切。
      10	double exp(double x)
         返回 e 的 x 次幂的值。
     11	double frexp(double x, int *exponent)
      把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent。
      12	double ldexp(double x, int exponent)

180 int unlink(const char *pathname);
    unlink()函数功能即为删除文件。执行unlink()函数会删除所给参数指定的文件
    执行unlink()函数并不一定会真正的删除文件，它先会检查文件系统中此文件的连接数是否为1，如果不是1说明此文件还有其他链接对象，
    因此只对此文件的连接数进行减1操作。若连接数为1，并且在此时没有任何进程打开该文件，此内容才会真正地被删除掉。
    在有进程打开此文件的情况下，则暂时不会删除，直到所有打开该文件的进程都结束时文件就会被删除

181 size_t regerror(int errcode, const regex_t *preg, char *errbuf,size_t errbuf_size);
    当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串

182 string::find()
    size_t find (const string& str, size_t pos = 0) const noexcept;
    size_t find (const char* s, size_t pos = 0) const;
    size_t find (const char* s, size_t pos, size_type n) const;
    size_t find (char c, size_t pos = 0) const noexcept;
    返回值都是查找到的字符所做的位置

183  boost::asio::deadline_timer    定时器
     https://www.cnblogs.com/xuaidongstdudyrecording/p/6077639.html

184  boost::asio::io_service

185  int connect(int sockfd, const struct sockaddr* server_addr, socklen_t addrlen)
     返回：0──成功， -1──失败。

186  post = malloc(re_len);
     if(post == NULL){
         return -1;
     }
     sprintf(post, "POST %s HTTP/1.0\r\n", page);
     sprintf(post, "%sHost: %s:%d\r\n",post, host, port);
     sprintf(post, "%s%s", post, HttpsPostHeaders);
     sprintf(post, "%sContent-Length: %d\r\n\r\n", post, len);
     sprintf(post, "%s%s", post, content); 		// 此处需要修改, 当业务需要上传非字符串数据的时候, 会造成数据传输丢失或失败
     printf("post::  \n%s\n", post);

187 ssize_t send(int sockfd, const void *buf, size_t len, int flags);
该函数的第一个参数指定发送端套接字描述符；
第二个参数指明一个存放应用程序要发送数据的缓冲区；
第三个参数指明实际要发送的数据的字节数；
第四个参数一般置0。

188 int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
        pthread_create 创建线程时，若不指定分配堆栈大小，系统会分配默认值，查看默认值方法如下：
# ulimit -s
8192
上述表示为8M；单位为KB
stacksize    堆栈大小  单位 字节char
一般来说 默认堆栈大小为 8388608; 堆栈最小为 16384 。 单位为字节。
堆栈最小值定义为 PTHREAD_STACK_MIN ，包含#include <limits.h>后可以通过打印其值查看。
对于默认值可以通过pthread_attr_getstacksize (&attr, &stack_size); 打印stack_size来查看。
尤其在嵌入式中内存不是很大，若采用默认值的话，会导致出现问题，若内存不足，则 pthread_create 会返回 12，定义如下

189  int pthread_cond_signal(pthread_cond_t *cond);
     使用pthread_cond_signal不会有“惊群现象”产生，他最多只给一个线程发信号。
     假如有多个线程正在阻塞等待着这个条件变量的话，那么是根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。
     如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。
     但无论如何一个pthread_cond_signal调用最多发信一次

190  int pthread_cond_broadcast(pthread_cond_t *cond);

192  PTHREAD_COND_INITIALIZER
    创建互斥量cond：
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER
    还可以通过函数的方式创建：
    int pthread_cond_init(pthread_cond_t *cond,NULL);
    注意：两种方式创建有所区别，第一种是创建静态全局的，所创建的量在全局区，第二种创建的量在栈，
    两种的区别我们可以理解为全局变量和局部变量的差异，对于两种方式，如果创建的是全局的条件量则用第一种方式初始化，
    如果是在函数内部创建则用第二种方式。这里其实跟互斥锁一样，互斥锁也可以用这两种方式初始化，原理相同

193  int aio_read(struct aiocb *aiocbp);  异步读操作，向内核发出读的命令，传入的参数是一个aiocb的结构
     int aio_write(struct aiocb *aiocbp);  异步写操作，向内核发出写的命令，传入的参数仍然是一个aiocb的结构
     int aio_error(const struct aiocb *aiocbp);
            如果该函数返回0，表示aiocbp指定的异步I/O操作请求完成。
            如果该函数返回EINPROGRESS，表示aiocbp指定的异步I/O操作请求正在处理中。
            如果该函数返回ECANCELED，表示aiocbp指定的异步I/O操作请求已经取消。
            如果该函数返回-1，表示发生错误，检查errno
    ssize_t aio_return(struct aiocb *aiocbp);这个函数的返回值相当于同步I/O中，read/write的返回值。只有在aio_error调用后才能被调用
    int aio_cancel(int fd, struct aiocb *aiocbp);
            取消在文件描述符fd上的aiocbp所指定的异步I/O请求。
            如果该函数返回AIO_CANCELED，表示操作成功。
            如果该函数返回AIO_NOTCANCELED，表示取消操作不成功，使用aio_error检查一下状态。
            如果返回-1，表示发生错误，检查errno

    int lio_listio(int mode, struct aiocb *restrict const list[restrict],int nent, struct sigevent *restrict sig)
            使用该函数，在很大程度上可以提高系统的性能，因为再一次I/O过程中，OS需要进行
            用户态和内核态的切换，如果我们将更多的I/O操作都放在一次用户太和内核太的切换中，
            减少切换次数，换句话说在内核尽量做更多的事情。这样可以提高系统的性能。
            用户程序提供一个struct aiocb的数组，每个元素表示一次AIO的请求操作。需要设置struct aiocb
            中的aio_lio_opcode数据成员的值，有LIO_READ，LIO_WRITE和LIO_NOP。
            nent表示数组中元素的个数。最后一个参数是对AIO操作完成后的通知机制的设置

194  int syscall(int number, ...);
    syscall() 执行一个系统调用，根据指定的参数number和所有系统调用的汇编语言接口来确定调用哪个系统调用。
    系统调用所使用的符号常量可以在头文件<sys/syscll.h>里面找到

195  
int io_setup(int maxevents, io_context_t *ctxp);
创建一个异步IO上下文（io_context_t是一个句柄）

int io_destroy(io_context_t ctx);
销毁一个异步IO上下文（如果有正在进行的异步IO，取消并等待它们完成）

long io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp);
提交异步IO请求

long io_cancel(aio_context_t ctx_id, struct iocb *iocb, struct io_event *result);
取消一个异步IO请求

long io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event *events, struct timespec *timeout);
等待并获取异步IO请求的事件（也就是异步请求的处理结果）

196  char *strdup(const char *s)

char * __strdup(const char *s) {
   size_t  len = strlen(s) +1;
   void *new = malloc(len);
   if (new == NULL)
      return NULL;
   return (char *)memecpy(new,s,len);
}

197 int isalpha(int c)    检查参数c是否为英文字母
    相关函数 isalnum，islower，isupper

198 #include <sys/socket.h>
    #include <netdb.h>

    int getaddrinfo(const char *restrict nodename, /* host 或者IP地址 */
                const char *restrict servname, /* 十进制端口号 或者常用服务名称如"ftp"、"http"等 */
                const struct addrinfo *restrict hints, /* 获取信息要求设置 */
                struct addrinfo **restrict res); /* 获取信息结果 */
    void freeaddrinfo(struct addrinfo *ai);

    IPv4中使用 gethostbyname()函数完成主机名到地址解析，这个函数仅仅支持IPv4，且不允许调用者指定所需地址类型的任何信息，
    返回的结构只包含了用于存储IPv4地址的空间。IPv6中引入了getaddrinfo()的新API，它是协议无关的，既可用于IPv4也可用于IPv6。
    getaddrinfo函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo的结构（列表）指针而不是一个地址清单。
    这些addrinfo结构随后可由套接口函数直接使用。如此以来，getaddrinfo函数把协议相关性安全隐藏在这个库函数内部。
    应用程序只要处理由getaddrinfo函数填写的套接口地址结构 

函数原型 int getaddrinfo( const char *hostname, const char *service, 
                    const struct addrinfo *hints, struct addrinfo **result );
    gethostbyname() 已经不再维护了,官方推荐用 getaddrinfo() 替代

参数说明
    hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)
    service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等
    hints：可以是一个空指针，也可以是一个指向某个 addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。
    举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成
    SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。
    result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。
    返回值：0——成功，非0——出错

    typedef struct addrinfo {
        int        　　　　    　　ai_flags;//指示在getaddrinfo函数中使用的选项的标志。
        int        　　　　   　　 ai_family;
        int        　　　　    　　ai_socktype;
        int        　　　　　 　　ai_protocol;
        size_t       　　　　 　　ai_addrlen;
        char       　　　　 　　*ai_canonname;
        struct sockaddr    　　*ai_addr;
        struct addrinfo     　　*ai_next;//指向链表中下一个结构的指针。此参数在链接列表的最后一个addrinfo结构中设置为NULL。
    } ADDRINFOA, *PADDRINFOA;
    struct sockaddr {
        ushort  sa_family;
        char    sa_data[14];
    };
    struct sockaddr_in {
        short           sin_family; //指代协议族，在socket编程中只能是 AF_INET
        u_short         sin_port;   //存储端口号（使用网络字节顺序）
        struct in_addr  sin_addr;   //存储IP地址，使用in_addr这个数据结构
        char            sin_zero[8];//为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节。
    };

ai_flags：
Value Meaning
AI_PASSIVE 套接字地址将用于调用bind 函数
AI_CANONNAME 返回规范名称
AI_NUMERICHOST 传递给getaddrinfo函数的nodename参数必须是数字字符串。
AI_ALL If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED.
AI_ADDRCONFIG 只有配置了全局地址后，getaddrinfo才会解析。 IPv6和IPv4环回地址不被认为是有效的全局地址。
AI_V4MAPPED 如果对IPv6地址的getaddrinfo请求失败，则对IPv4地址进行名称服务请求，这些地址将转换为IPv4映射IPv6地址格式。
AI_NON_AUTHORITATIVE 地址信息可以来自非授权命名空间提供商
AI_SECURE 地址信息来自安全信道。
AI_RETURN_PREFERRED_NAMES 地址信息是用于用户的优选名称。
AI_FQDN getaddrinfo将返回名称最终解析为的完全限定域名。 完全限定域名在ai_canonname成员中返回。
这与AI_CANONNAME位标记不同，后者返回在DNS中注册的规范名称，该名称可能与平面名称解析为的完全限定域名不同。
只能设置AI_FQDN和AI_CANONNAME位中的一个。 如果EAI_BADFLAGS同时存在这两个标志，getaddrinfo函数将失败。
AI_FILESERVER 命名空间提供程序提示正在查询的主机名正在文件共享方案中使用。 命名空间提供程序可以忽略此提示。

ai_flags

   附加选项,多个选项可以使用或操作进行结合，具体取值范围请查看struct addrinfo , 常用的标志如下：

AI_PASSIVE
    如果设置了 AI_PASSIVE 标志,并且 nodename 是 NULL, 那么返回的socket地址可以用于的bind()函数，返回的地址是通配符地址(wildcard address, IPv4时是INADDR_ANY,IPv6时是IN6ADDR_ANY_INIT)，
    这样应用程序(典型是server)就可以使用这个通配符地址用来接收任何请求主机地址的连接，如果 nodename 不是NULL，那么 AI_PASSIVE 标志被忽略；如果未设置AI_PASSIVE标志,返回的socket地址可以用于connect(), 
    sendto(), 或者 sendmsg()函数。如果 nodename 是NULL，那么网络地址会被设置为lookback接口地址(IPv4时是INADDR_LOOPBACK,IPv6时是IN6ADDR_LOOPBACK_INIT)，这种情况下，
    应用是想与运行在同一个主机上另一个应用通信。

AI_CANONNAME
 　　请求canonical(主机的official name)名字。如果设置了该标志，那么 res 返回的第一个 struct addrinfo 中的 ai_canonname 域会存储official name的指针。

AI_NUMERICHOST
 　　阻止域名解析，具体见 nodename 中的说明。

AI_NUMERICSERV
     阻止服务名解析，具体见 servname 中的说明。

AI_V4MAPPED
 　当 ai_family 指定为AF_INT6(IPv6)时，如果没有找到IPv6地址，那么会返回IPv4-mapped IPv6 地址，也就是说如果没有找到AAAA record(用来将域名解析到IPv6地址的DNS记录),那么就查询A record(IPv4),将找到的IPv4地址映射到IPv6地址, IPv4-mapped IPv6 地址其实是IPv6内嵌IPv4的一种方式，地址的形式为"0::FFFF:a.b.c.d"，例如"::ffff:192.168.89.9"(混合格式)这个地址仍然是一个IPv6地址，只是"0000:0000:0000:0000:0000:ffff:c0a8:5909"(16机制格式)的另外一种写法罢了。当 ai_family 不是AF_INT6(IPv6)时，该标志被忽略。AI_ALL查询IPv4和IPv6地址AI_ADDRCONFIG只有当主机配置了IPv4地址才进行查询IPv4地址；只有当主机配置了IPv6地址才进行查询IPv6地址.



ai_family: The address family.

AF_UNSPEC 地址系列未指定。
AF_INET IPv4 address family.
AF_NETBIOS NetBIOS地址系列。
AF_INET6 IPv6 address family.
AF_IRDA The Infrared Data Association address family.
AF_BTH Bluetooth address family.

ai_protocol: 协议类型。

Value Meaning
IPPROTO_TCP 传输控制协议（TCP）。 当ai_family成员为AF_INET或AF_INET6且ai_socktype成员为SOCK_STREAM时，这是一个可能的值
IPPROTO_UDP 用户数据报协议（UDP）。 当ai_family成员为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。
IPPROTO_RM PGM协议用于可靠的组播。 当ai_family成员为AF_INET且ai_socktype成员为SOCK_RDM时，这是一个可能的值。 在为Windows Vista及更高版本发布的Windows SDK上，此值也称为IPPROTO_PGM。
可能的选项特定于指定的地址系列和套接字类型。
如果为ai_protocol指定了值0，则调用者不希望指定协议，服务提供者将选择要使用的ai_protocol。 对于IPv4和IPv6之外的协议，将ai_protocol设置为零。
下表列出了ai_protocol成员的通用值，尽管其他许多值也是可能的。

ai_socktype:　　套接字类型

Value Meaning
SOCK_STREAM 使用OOB数据传输机制提供顺序，可靠，双向，基于连接的字节流。使用Internet地址系列（AF_INET或AF_INET6）的传输控制协议（TCP）。如果ai_family成员是AF_IRDA，则SOCK_STREAM是唯一支持的套接字类型。
SOCK_DGRAM 支持数据报，它是无连接的，不可靠的固定（通常小）最大长度的缓冲区。对Internet地址系列（AF_INET或AF_INET6）使用用户数据报协议（UDP）。
SOCK_RAW 提供一个原始套接字，允许应用程序处理下一个上层协议头。要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。要操作IPv6头，必须在套接字上设置IPV6_HDRINCL套接字选项。
SOCK_RDM 提供可靠的消息数据报。这种类型的示例是在Windows中的实用通用多播（PGM）多播协议实现，通常被称为可靠多播节目。
SOCK_SEQPACKET 基于数据报提供伪流包

199  char *gai_strerror(int error);
    getaddrinfo出错时返回非零值，gai_strerror根据返回的非零值返回指向对应的出错信息字符串的指针，其原型如下
    
    常量                     描述
EAI_ADDRFAMILY	     不支持hostname的地址族
EAI_AGAIN	         名字解析中的暂时失败
EAI_BADFLAGS	     ai_flags的值无效
EAI_FAIL	         名字解析中不可恢复的失败
EAI_FAMILY	         不支持ai_family
EAI_MEMORY	         内存分配失败
EAI_NODATA	         没有与hostname相关联的地址
EAI_NONAME	         hostname或service未提供，或者不可知
EAI_SERVICE	         不支持ai_socktype类型的service
EAI_SOCKTYPE	     不支持ai_socktype
EAI_SYSTEM	         errno中有系统错误返回

200  void freeaddrinfo (struct addrinfo*ai);
     getaddrinfo返回的存储空间，包括addrinfo结构、ai_addr结构和ai_canonname字符串，都是用malloc动态获取的。这些空间可调用 freeaddrinfo释放。其原型如下

201 int isupper ( int c );判断一个字符是否是大写字母
    返回值为非零（真）表示c是大写字母，返回值为零（假）表示c不是大写字母。

    int tolower(int c)  字母字符转换成小写
    int touppre()函数是把字符串都转化为大写字母
    
    int isxdigit(int c) 检查参数c是否为16进制数字，真返回非零值，否则返回0。
    isalnum()：判断字符是否为字母或者数字
    isalpha()：判断字符是否为字母
    isdigit()：判断字符是否为数字

202 int isspace(int c) 当c为空白符时，返回true值，否则返回零。（空白符指空格、水平制表、垂直制表、换页、回车和换行符。
    \r    回车，将当前位置移到本行开头
    \n    换行，将当前位置移到下一行开头

203  int semget(key_t  _key ,int  _nsems,int _semflg);
    功能：创建一个新的信号量或获取一个已经存在的信号量的键值
    key  为整型值，用户可以自己设定。有两种情况：
    1.       键值是IPC_PRIVATE，该值通常为0，意思就是创建一个仅能被进程进程给我的信号量。
    2.       键值不是IPC_PRIVATE，我们可以指定键值，例如1234；也可以一个ftok()函数来取得一个唯一的键值。
    _nsems 表示初始化信号量的个数。比如我们要创建一个信号量，则该值为1.,创建2个就是2。
    _semflg  ：信号量的创建方式或权限。有IPC_CREAT，IPC_EXCL。
    IPC_CREAT如果信号量不存在，则创建一个信号量，否则获取。
    IPC_EXCL只有信号量不存在的时候，新的信号量才建立，否则就产生错误。

204  int semop(int   semid ,struct    sembuf   *_sops ,size_t  _nsops);
    功能：用户改变信号量的值。也就是使用资源还是释放资源使用权。
    返回值：成功返回0，失败返回-1；
参数：
    _semid : 信号量的标识码。也就是semget（）的返回值。
    _sops是一个指向结构体数组的指针。
struct   sembuf{
    unsigned short  sem_num;//第几个信号量，第一个信号量为0；
    short  sem_op;//对该信号量的操作。
    short _semflg;
};
sem_num:  操作信号在信号集中的编号。第一个信号的编号为0；
sem_op :  如果其值为正数，该值会加到现有的信号内含值中。通常用于释放所控资源的使用权；如果sem_op的值为负数，而其绝对值又大于信号的现值，
          操作将会阻塞，直到信号值大于或等于sem_op的绝对值。通常用于获取资源的使用权；如果sem_op的值为0，则操作将暂时阻塞，直到信号的值变为0。
_semflg IPC_NOWAIT //对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。
IPC_UNDO //程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。

205 std::transform在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内
    template <class InputIterator, class OutputIterator, class UnaryOperation>
    OutputIterator transform (InputIterator first1, InputIterator last1,
                            OutputIterator result, UnaryOperation op);
    std::vector<int> arr{ 1, 3, 5 };
    std::transform(arr.begin(), arr.end(), arr.begin(),[](int d) -> int {return d * 5; }); 
    或者 std::vector<int> arr2
    std::transform(arr.begin(), arr.end(), arr2.begin(),[](int d) -> int {return d * 5; }); 

206 void *calloc(size_t n, size_t size)；
    在内存的 动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的 指针；如果分配不成功，返回NULL

207 int pipe(int fd[2]);
    pipe函数定义中的fd参数是一个大小为2的一个数组类型的指针。该函数成功时返回0，并将一对打开的文件描述符值填入fd参数指向的数组。失败时返回 -1并设置errno。
    通过pipe函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0]
    一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。
    默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；
    如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。
    如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的read操作将返回0(管道内不存在数据的情况)，
    即读到了文件结束标记(EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有任何进程需要从管道读取数据，
    则针对该管道的写端文件描述符 fd[1] 的write操作将失败，并引发SIGPIPE信号(往读端被关闭的管道或socket连接中写数据)

208 int sysinfo(struct sysinfo *info);    操作成功返回0，错误返回-1；
    
    在Linux 2.3.16中，结构体的信息是（单位是字节）：
    struct sysinfo {                    
        long uptime;              
        /* 启动到现在经过的时间 */                    
        unsigned long loads[3];    
        /* 1, 5, and 15 minute load averages */                    
        unsigned long totalram;  /* 总的可用的内存大小 */  
        unsigned long freeram;   /* 还未被使用的内存大小 */  
        unsigned long sharedram; /* 共享的存储器的大小 */  
        unsigned long bufferram; /* 缓冲区大小 */                    
        unsigned long totalswap; /* 交换区大小 */                    
        unsigned long freeswap;  /* 还可用的交换区大小 */  
        unsigned short procs;    /* 当前进程数目 */  
        char _f[22];         /* 64字节的补丁结构 */
    }
    自Linux 2.3.23(i386), 2.3.48 (all architectures)中，结构体的信息是（单位是mem_unit字节）：
    struct sysinfo {  
        long uptime;          /* 启动到现在经过的时间 */  
        unsigned long loads[3];    
        /* 1, 5, and 15 minute load averages */  
        unsigned long totalram;  /* 总的可用的内存大小 */  
        unsigned long freeram;   /* 还未被使用的内存大小 */  
        unsigned long sharedram; /* 共享的存储器的大小*/  
        unsigned long bufferram; /* 共享的存储器的大小 */  
        unsigned long totalswap; /* 交换区大小 */  
        unsigned long freeswap;  /* 还可用的交换区大小 */  
        unsigned short procs;    /* 当前进程数目 */  
        unsigned long totalhigh; /* 总的高内存大小 */  
        unsigned long freehigh;  /* 可用的高内存大小 */  
        unsigned int mem_unit;   /* 以字节为单位的内存大小 */  
        char _f[20-2*sizeof(long)-sizeof(int)];   
        /* libc5的补丁  
    };

209 gzoffset()    返回压缩文件中将要读或写的位置

210  int setjmp(jmp_buf env);
     void longjmp(jmp_buf env, int val);
    =============================================================
        #include <stdio.h>
        #include <stdlib.h>
        #include <setjmp.h>
        jmp_buf env;
        int my_func(int a, int b) {
            if (b == 0) {
                printf("do not allow division by 0\n");
                longjmp(env, 1);
            }
            return a / b;
        }
        int main(int argc, char const *argv[]) {
            int res = setjmp(env);
            printf("***************************\n");
            if (res == 0) {
                printf("return from setjmp\n");
                my_func(10, 0);
            } else {
                printf("return from longjmp: %d\n", res);
            }
            return 0;
        }
    -----------------------------------------------------------
            输出结果为：
            ***************************
            return from setjmp
            do not allow division by 0
            ***************************
            return from longjmp: 1
    ===========================================================

211    ioctl(int fd, ind cmd, …)     ioctl是设备驱动程序中对设备的I/O通道进行管理的函数
       在驱动程序中实现的ioctl函数体内，实际上是有一个switch{case}结构，每一个case对应一个命令码，做出一些相应的操作。怎么实现这些操作，
       这是每一个程序员自己的事情。因为设备都是特定的，这里也没法说。关键在于怎样组织命令码，因为在ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径

212    int feof(FILE *stream);
       feof是C语言标准库函数，其原型在stdio.h中，其功能是检测流上的文件结束符，如果文件结束，则返回非0值，
       否则返回0（即，文件结束：返回非0值；文件未结束：返回0值）

213    char *fgets(char *str, int n, FILE *stream);
       从指定的流 stream 读取一行，并把它存储在str所指向的字符串内。当读取(n-1)个字符时，
       或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。

214    int strcmp(const char *s1, const char *s2);
       返回值：若s1、s2字符串相等，则返回零；若s1大于s2，则返回大于零的数；否则，则返回小于零的数。

215     在C11标准中，首次引入原子操作，正式将其标准化。然而在我现在的系统ubuntu14.04上，仍然不能使用man来查看其相关手册，需要看标准文档。ansi.org上的文档估计要$60吧，
        不过在网上还能免费下载到草案文档WG14 draft version N1570。里面7.17 Atomics <stdatomic.h>章节中给出了详尽的定义。这里简单的介绍一下。
        首先，定义了所需要引用的头文件stdatomic.h。在我的系统上，该头文件并没有在/usr/include目录下，而是/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdatomic.h
        插一句题外话，从标准中还可以看到stdbool.h，stdint.h, stddef.h等等头文件，定义了很多以前标准中没有、然而特别实用的类型，特别是很多C++里的类型。
        其次，标准定义了__STDC_NO_ATOMICS__宏，用来在编译时检测是否支持stdatomic。同时还有一系列的宏和函数用来判断各种数据类型在当前的实现中是否支持原子操作，
        例如ATOMIC_CHAR_LOCK_FREE, atomic_is_lock_free。
        然后，标准引入了memory order and consistency，在不同的memory order下，原子操作的效率和严格性不尽相同，具体可以看这里和这里。
        同时，标准定义了许多原子数据类型，例如atomic_char, atomic_int, atomic_size_t。必须使用这些数据类型，因为其类型内部可能包含其他数据来保证原子性操作。
        初始化原子变量可以使用如下函数，但不保证原子性(当然一般也不会在多线程中进行初始化):
        
        ATOMIC_VAR_INIT
        atomic_init
        ATOMIC_FLAG_INIT
       
        操作原子变量则使用如下函数，保证原子性:
        atomic_store
        atomic_load
        atomic_exchange
        atomic_compare_exchange_strong, atomic_compare_exchange_weak
        atomic_fetch_add, atomic_fetch_sub, atomic_fetch_or, atomic_fetch_xor, atomic_fetch_and
        atomic_flag_test_and_set
        atomic_flag_clear

216  原型：int mkdir (const char *filename, mode_t mode)
    以model方式创建一个以参数pathname命名的目录，mode定义新创建目录的权限
    返回0表示成功，返回-1表述出错。使用该函数需要包含头文件sys/stat.h

217  定义函数：
int open(const char * pathname, int flags);
int open(const char * pathname, int flags, mode_t mode);
int fd = open(pidfile, O_RDWR|O_CREAT, 0644);
函数说明：参数 pathname 指向欲打开的文件路径字符串. 下列是参数flags 所能使用的旗标:
O_RDONLY 以只读方式打开文件
O_WRONLY 以只写方式打开文件
O_RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.
O_CREAT 若欲打开的文件不存在则自动建立该文件.
O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.
O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.
O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.
O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.
O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.
O_NDELAY 同O_NONBLOCK.
O_SYNC 以同步的方式打开文件.
O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.
O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。注：此为Linux2. 2 以后特有的旗标, 以避免一些系统安全问题.

对于open函数来说，第三个参数仅当创建新文件时（即 使用了O_CREAT 时）才使用，用于指定文件的访问权限位（access permission bits）
参数mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask 值所影响, 因此该文件权限应该为 (mode-umaks).

S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.
S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.
S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.
S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.
S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.
S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.
S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.
S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.
S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.
S_IROTH 00004 权限, 代表其他用户具有可读的权限
S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.
S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.

返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1.
       return the new file descriptor, or -1 if an error occurred (in which case, errno is set appropriately).

错误代码：
EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和O_EXCL 旗标.
EACCESS 参数pathname 所指的文件不符合所要求测试的权限.
EROFS 欲测试写入权限的文件存在于只读文件系统内.
EFAULT 参数pathname 指针超出可存取内存空间.
EINVAL 参数mode 不正确.
ENAMETOOLONG 参数 pathname 太长.
ENOTDIR 参数pathname 不是目录.
ENOMEM 核心内存不足.
ELOOP 参数pathname 有过多符号连接问题.
EIO I/O 存取错误.

218 多次打开同一文件 与 O_APPEND
1、重复打开同一文件读取
(1)一个进程中两次打开同一个文件，然后分别读取，看结果会怎么样
(2)结果无非2种情况：一种是fd1和fd2分别读，第二种是接续读。经过实验验证，证明了结果是fd1和fd2分别读。
(3)分别读说明：我们使用open两次打开同一个文件时，fd1和fd2所对应的文件指针是不同的2个独立的指针。文件指针是包含在动态文件的文件管理表中的，所以可以看出linux系统的进程中不同fd对应的是不同的独立的文件管理表。
2、重复打开同一文件写入
(1)一个进程中2个打开同一个文件，得到fd1和fd2.然后看是分别写还是接续写？
(2)正常情况下我们有时候需要分别写，有时候又需要接续写，所以这两种本身是没有好坏之分的。关键看用户需求
(3)默认情况下应该是：分别写（实验验证过的）
3、加O_APPEND解决覆盖问题
(1)有时候我们希望接续写而不是分别写？办法就是在open时加O_APPEND标志即可
4、O_APPEND的实现原理和其原子操作性说明
(1)O_APPEND为什么能够将分别写改为接续写？关键的核心的东西是文件指针。分别写的内部原理就是2个fd拥有不同的文件指针，并且彼此只考虑自己的位移。但是O_APPEND标志可以让write和read函数内部多做一件事情，就是移动自己的文件指针的同时也去把别人的文件指针同时移动。（也就是说即使加了O_APPEND，fd1和fd2还是各自拥有一个独立的文件指针，但是这两个文件指针关联起来了，一个动了会通知另一个跟着动）
(2)O_APPEND对文件指针的影响，对文件的读写是原子的。
(3)原子操作的含义是：整个操作一旦开始是不会被打断的，必须直到操作结束其他代码才能得以调度运行，这就叫原子操作。每种操作系统中都有一些机制来实现原子操作，以保证那些需要原子操作的任务可以运行。

219 FILE *freopen( const char *path, const char *mode, FILE *stream );
参数说明：
path: 文件名，用于存储输入输出的自定义文件名。
mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。
stream: 一个文件，通常使用标准流文件。
返回值：成功，则返回一个path所指定文件的指针；失败，返回NULL。
功能：实现重定向，把预定义的标准流文件定向到由path指定的文件中。标准流文件具体是指stdin、stdout和stderr。
     其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认

220 int snprintf(char *str, size_t size, const char *format, ...) 
    最多从源串中拷贝size－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为size的话，将不会溢出
    返回值:若成功则返回欲写入的字符串长度，若出错则返回负值。返回值并不是真正写入字符串的大小  -->snprintf函数返回的是预写入的字符串长度

    size是限定最终生成的dest的字符数,最多拷贝size-1个字符; 一般情况下size会取sizeof(dest),这是为了dst不溢出.
    在snprintf(dest, size, "str: %s\n", src)中如果size-1大于等于"str: %s\n"的长度,则把"str: %s\n"都拷贝到dst; 
    如果size-1小于"str: %s\n"的长度,则从"str: %s\n"拷贝size-1长度的字符串到dst，并且末尾置\0.

int main()  
{  
  char buf[10] = "";  
  char src[30] = "hello world! hello world!";  
  int len = snprintf(buf, sizeof(buf), "%s", src);  
  printf("return len=%d\n", len);  
  buf[len] = '\0';  
  printf("buf=%s, bufLen=%d\n", buf, strlen(buf));  
  return 0;  
}
输出结果:
return len=25
buf=hello wor, bufLen=9

221  char *strncpy(char *dest, const char *src, size_t n) 
     把src所指向的字符串复制到dest，最多复制n个字符。当src的长度小于n时，dest的剩余部分将用空字节填充

222  size_t malloc_usable_size (void *ptr);
        malloc_usable_size() returns the number of usable bytes in the block of allocated memory pointed to by ptr.  If ptr is NULL, 0 is returned.
        void *p1 = malloc(sizeof(int));   printf("malloc p1: %ld\n", malloc_usable_size(p1));   //24
        void *p2 = malloc(0);printf("malloc p2: %ld\n", malloc_usable_size(p2));                //24
        char *p3 = (char*)malloc(25);printf("malloc p3: %ld\n", malloc_usable_size(p3));        //40
        void *p4 = malloc(1000);printf("malloc p4: %ld\n", malloc_usable_size(p4));             //1000
    结论：
    1、malloc分配最小的大小是24个字节，我的机器是64位的，可能与机器有有关
    2、如果分配的大小大于24个字节，例如希望分配25个字节，可能会分配比这个稍大一点的内存
    原因：
    Linux 处理内存分配通过创建一套固定大小的内存对象池。分配请求被这样来处理，进入一个持有足够大的对象的池子并且将整个内存块递交给请求者。
    内核只能分配某些预定义的，固定大小的字节数组。如果你请求一个任意数量内存，你可能得到稍微多于你请求的，至多是 2 倍数量

223  atomic_fetch_add_explicit

224  void *memmove (void *__dest, const void *__src, size_t __n)
     memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。
     但是当目标区域与源区域没有重叠则和memcpy函数功能相同
     int main(void) {
            char s[]="Golden Global View";
            memmove(s,s+7,strlen(s)+1-7);
            printf("%s",s);
            getchar();
            return 0;
     }
    程序输出结果：Global View
    *注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的'\0'也拷贝进来
    void *memmove(void *dest, const void *source, size_t count) {
        assert((NULL != dest) && (NULL != source));  
        char *tmp_source, *tmp_dest;  
        tmp_source = (char *)source;  
        tmp_dest = (char *)dest;  
        if((pdest < psrc) || (source + count) <dest))  {// 如果没有重叠区域  
            while(count--)  
            *tmp_dest++ = *tmp_source++;  
        } else { //如果有重叠  
            tmp_source += count - 1;  
            tmp_dest += count - 1;  
            while(count--)  
            *--tmp_dest = *--tmp_source;  
        }  
            return dest;
    }  

但是实际在C99实现中，是将内容拷贝到临时空间，再拷贝到目标地址中
    void *memmove(void *dest, const void *src, size_t n) {
        unsigned char tmp[n];
        memcpy(tmp,src,n);
        memcpy(dest,tmp,n);
        return dest;
    }

224  void *memccpy(void *dest, void *src, unsigned char ch, unsigned int count);
　　  功能：由src所指内存区域复制不多于count个字节到dest所指内存区域，如果遇到字符ch则停止复制。
　　  说明：返回指向字符ch后的第一个字符的指针，如果src前n个字节中不存在ch则返回NULL。ch被复制

225  int memcmp (const void *__s1, const void *__s2, size_t __n)

226   int isprint( int ch );
      功能：如果参数是可打印字符（包括空格），函数返回非零值，否则返回零值。

227  目录/文件 宏
    S_ISLNK(st_mode)：是否是一个连接.
    S_ISREG(st_mode)：是否是一个常规文件.
    S_ISDIR(st_mode)：是否是一个目录
    S_ISCHR(st_mode)：是否是一个字符设备.
    S_ISBLK(st_mode)：是否是一个块设备
    S_ISFIFO(st_mode)：是否 是一个FIFO文件.
    S_ISSOCK(st_mode)：是否是一个SOCKET文件     

228 常用的VIDIOC命令    https://blog.csdn.net/Mark_minGE/article/details/81427489#commentBox

使用ioctl VIDIOC_QUERYCAP 来查询当前driver是否合乎规范。因为V4L2要求所有driver 和Device都支持这个Ioctl。 所以，
可以通过这个ioctl是否成功来判断当前设备和dirver,是否支持V4L2规范。当然，这样同时还能够得到设备足够的能力信息

    V4L2_CAP_VIDEO_CAPTURE   // 是否支持图像获取
    V4L2_CAP_STREAMING       // 判断是否支持Streaming方式访问
    1. VIDIOC_QUERYCAP （查询设备属性）
    2. VIDIOC_ENUM_FMT (显示所有支持的格式)
    3. VIDIOC_S_FMT （设置视频捕获格式）
    4. VIDIOC_G_FMT （获取硬件现在的视频捕获格式）
    5. VIDIOC_TRY_FMT （检查是否支持某种帧格式）
    6. VIDIOC_ENUM_FRAMESIZES （枚举设备支持的分辨率信息）
    7. VIDIOC_ENUM_FRAMEINTERVALS (获取设备支持的帧间隔)
    8. VIDIOC_S_PARM && VIDIOC_G_PARM (设置和获取流参数)
    9. VIDIOC_QUERYCAP (查询驱动的修剪能力)
    10. VIDIOC_S_CROP (设置视频信号的边框)
    11. VIDIOC_G_CROP (读取设备信号的边框)
    12. VIDIOC_REQBUFS (向设备申请缓存区)
    13. VIDIOC_QUERYBUF (获取缓存帧的地址、长度)
    14. VIDIOC_QBUF (把帧放入队列)
    15. VIDIOC_DQBUF (从队列中取出帧)
    16. VIDIOC_STREAMON && VIDIOC_STREAMOFF (启动/停止视频数据流)

1. VIDIOC_ENUM_FMT
  Fun：显示所有支持的格式，即允许应用查询所支持的格式，属于格式协商的部分
  函数原型： int ioctl(int fd, int request, struct v4l2_fmtdesc *argp);
  此处 request 即 VIDIOC_ENUM_FMT，后续request 都由前文标注的VIDIOC 命令代替。

//相关的结构体：	
struct v4l2_fmtdesc
{
  __u32  index;   	           // 要查询的格式序号，应用程序设置
  enum   v4l2_buf_type type;   // 帧类型，应用程序设置
  __u32  flags;    			   // 是否为压缩格式
  __u8   description[32];      // 格式名称
  __u32  pixelformat;		   // 格式
  __u32	 reserved[4]; 		  // 保留，不使用设置为0
};
 参数分析：
  1. index ：是用来确定格式的一个简单整型数。与其他V4L2所使用的索引一样，这个也是从0开始递增，至最大允许值为止。应用可以通过一直递增索引值知道返回-EINVAL的方式枚举所有支持的格式。
  2. type：是描述数据流类型的字段。对于视频捕获设备（摄像头或调谐器）来说，就是V4L2_BUF_TYPE_VIDEO_CAPTURE。
  3. flags: 只定义了一个值，即V4L2_FMT_FLAG_COMPRESSED，表示这是一个压缩的视频格式。
  4. description: 是对这个格式的一种简短的字符串描述。
  5. pixelformat: 应是描述视频表现方式的四字符码
  ps: 其中第3、4、5项为就index所支持的某个图像格式，V4L2驱动会自动填写的结构体成员信息。

//fun: display all supported formats
void enum_camera_format(int fd)
{
  struct v4l2_fmtdesc fmtdesc;
  memset(&fmtdesc, 0, sizeof(fmtdesc));
  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  printf("Supported format:\n");
  while(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)
  {
    printf("\t%d.%s\n",fmtdesc.index+1, fmtdesc.description);	
    fmtdesc.index++;
  }
  
  
V4L2(Video For Linux Two) 是内核提供给应用程序访问音、视频驱动的统一接口。V4L2 的相关定义包含在头文件<linux/videodev2.h> 中.
2. 工作流程：
打开设备－> 检查和设置设备属性－> 设置帧格式－> 设置一种输入输出方法（缓冲 区管理）－> 循环获取数据－> 关闭设备


VIDIOC_REQBUFS:  分配内存
VIDIOC_QUERYBUF： 把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址
VIDIOC_QUERYCAP： 查询驱动功能
VIDIOC_ENUM_FMT： 获取当前驱动支持的视频格式
VIDIOC_S_FMT： 设置当前驱动的频捕获格式
VIDIOC_G_FMT： 读取当前驱动的频捕获格式
VIDIOC_TRY_FMT： 验证当前驱动的显示格式
VIDIOC_CROPCAP： 查询驱动的修剪能力
VIDIOC_S_CROP： 设置视频信号的边框
VIDIOC_G_CROP： 读取视频信号的边框
VIDIOC_QBUF： 把数据放回缓存队列
VIDIOC_DQBUF： 把数据从缓存中读取出来
VIDIOC_STREAMON： 开始视频显示函数
VIDIOC_STREAMOFF： 结束视频显示函数
VIDIOC_QUERYSTD： 检查当前视频设备支持的标准，例如PAL或NTSC

229  函数
    int ioctl(int fd, int request, struct v4l2_requestbuffers *argp);
参数
 fd:open()返回的文件描述符
 request:VIDIOC_REQBUFS
 argp
描述
    这个ioctl用于初始化内存映射或者用户指针IO，内存映射缓冲区由设备内存分配而且必须在应用程序地址空间分配之前由ioctl分配。用户空间的缓冲区由用户层自己分配，这个ioctl只是用来转换用户指针的一个驱动模块。
    为分配设备缓冲区的应用程序初始化3个v4l2_requestbuffer结构，用type来区分流或者缓冲区，count是所需buffer数量，memory必须设置为v4l2_MEMORY_MMAP，当ioctl调用一个指针结构去驱动分配buffer数量并把这个数存在count中。当驱动运行的可用内存，请求的number可以更小甚至是0。当驱动正确调用函数请求更多的buffer，number也可以更大，当内存映射i/o不支持ioctl返回EINVAL。
    应用程序可以重复调用VIDIOC_REQBUFS改变buffer数量，但是对于已经在映射的buffer不能成功。count值为0释放所有buffer，当所有DMA结束或退出，即VIDIOC_STEAMOFF。
struct v4l2_requestbuffers
__u32 count       /*请求或得到的buffer数量，这个字段只能在memory设置为V4L2_MEMORY_MMAP后才能生效*/
enum v4l2_buf_type type  /*stream或者buffer的类型，和v4l2_format结构的type字段相同，*/
enum v4l2_memory memory  /*应用程序设置这个字段用来设置V4L2_MEMORY_MMAP 或 V4L2_MEMORY_USERPTR*/
__u32 reserved[2]  /*留出扩展空间，定制buffer类型V4L2_BUF_TYPE_PRIVATE或更高*/
返回值
    成功返回0，出错返回-1且errno设为某特定值：
EBUSY
    该驱动程序支持多种开放和I / O是已经在进行中，或试图重新分配的缓冲区，虽然仍有一个或多个映射。
EINVAL
    缓冲区型（类型字段）或I / O请求方法（内存）不支持

230  想获取一下目标机运行时linux系统的硬件占用情况，写了这几个小程序，以后直接用了。
     方法就是读取proc下的文件来获取了。 cpu使用率：    /proc/stat ，内存使用情况：     /proc/meminfo

231  FILE *popen(const char *command, const char *type);
函数说明：
（1）popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。
（2）参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。
    随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。
（3）fclose()关闭文件指针
（4）如果 type 为 r，那么调用进程读进 command 的标准输出。
如果 type 为 w，那么调用进程写到 command 的标准输入。
返回值：若成功则返回文件指针，否则返回NULL，错误原因存于errno中。
**注意：**popen()会继承环境变量，通过环境变量可能会造成系统安全的问题

232 int system(const char *command);
    system()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，
    -c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，
    然后将这个结束状态返回给system()函数的调用者。
    返回值：
    （1）当参数command是NULL的时候
    在参数为NULL的情况下，system函数的返回值很简单明了，只有0和1。
    返回1，表明系统的命令处理程序，即/bin/sh是可用的。
    相反，如果命令处理程序不可用，则返回0。
    （2）当参数command不是NULL的时候
    当参数不为NULL的时候，情况有些小复杂，根据APUE这里可以分为以下三种情况：
    1）如果fork等系统调用失败，或者waitpid函数发生除EINTR外的错误时，system返回-1
    2）一切致使execl失败的情况下，system返回127
    3）除此之外，system返回/bin/sh的终止状态

233  char* ctime_r( const time_t* timer, char* buf );
    time_t Nowt=0;
	char Buf[50];
	ctime_r(&Nowt,Buf);			//可重入的版本，指定输出的位置，而不是内核随机位置输出
	printf("Buf=%s",Buf)        // Thu Sep 20 14:00:05 2018

234   int rename(const char *oldpath, const char *newpath)
        【参数】oldname为旧文件名，newname为新文件名。
        【返回值】修改文件名成功则返回0，否则返回-1。
        重命名文件：
        如果newname指定的文件存在，则会被删除。
        如果newname与oldname不在一个目录下，则相当于移动文件。
        重命名目录：
        如果oldname和oldname都为目录，则重命名目录。
        如果newname指定的目录存在且为空目录，则先将newname删除。
        对于newname和oldname两个目录，调用进程必须有写权限。
        重命名目录时，newname不能包含oldname作为其路径前缀。例如，不能将/usr更名为/usr/foo/testdir，因为老名字（ /usr/foo）是新名字的路径前缀，因而不能将其删除。

235.    头文件：#include <unistd.h>
        定义函数：int execv (const char * path, char * const argv[]);
        函数说明：execv()用来执行参数path 字符串所代表的文件路径, 与execl()不同的地方在于execve()只需两个参数, 第二个参数利用数组指针来传递给执行文件.
        返回值：如果执行成功则函数不会返回, 执行失败则直接返回-1, 失败原因存于errno中.

236.    exit() 函数与 _exit() 函数的最大区别在于exit()函数在调用exit  系统调用前要检查文件的打开情况，把文件缓冲区中的内容写回文件。也就是图中的“清理I/O缓冲”.

237.    double strtod (const char* str, char** endptr);

【参数说明】str 为要转换的字符串，endstr 为第一个不能转换的字符的指针。
【函数说明】strtod() 函数会扫描参数str字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，
          到出现非数字或字符串结束时('\0')才结束转换，并将结果返回。参数 str 字符串可包含正负号、小数点或E(e)来表示指数部分。如123. 456 或123e-2。
若endptr 不为NULL，则会将遇到的不符合条件而终止的字符指针由 endptr 传回；若 endptr 为 NULL，则表示该参数无效，或不使用该参数。
【返回值】返回转换后的浮点型数；若不能转换或字符串为空，则返回 0.0。
         温馨提示：ANSI C 规范定义了 stof()、atoi()、atol()、strtod()、strtol()、strtoul() 共6个可以将字符串转换为数字的函数，大家可以对比学习；
         使用 strtod(str, NULL) 与使用 atof() 结果相同。另外在 C99 / C++11 规范中又新增了5个函数，分别是 atoll()、strtof()、strtold()、strtoll()、strtoull()，

238.    这里面的三个函数openlog， syslog， closelog是一套系统日志写入接口。
首先系统里应该具有syslog等程序，ubuntu下可以apt-get install sysklogd安装。（这里选用的sysklogd， 还有rsyslog，syslog-ng等日志软件）
通常syslog守护进程读取三种格式的记录消息。此守护进程在启动时读一个配置文件。一般来说，其文件名为/etc/syslog.conf，该文件决定了不同种类的消息应送向何处。例如，紧急消息可被送向系统管理员，并在控制台上显示，而警告消息则可记录到一个文件中。该机制提供了syslog函数，其调用格式如下 
#include <syslog.h> //头文件
void openlog (char*ident, int option, int facility); 
void syslog(int priority, char*format,……);
void closelog();
调用openlog是可选择的。如果不调用openlog，则在第一次调用syslog时，自动调用openlog。调用closelog也是可选择的，它只是关闭被用于与syslog守护进程通信的描述符。调用openlog 使我们可以指定一个ident，以后， 此ident 将被加至每则记录消息中。ident 一般是程序的名称（例如 ，cron ，ine 等）。

#include <syslog.h>
int main(int argc, char **argv) {
    openlog("zooyo", LOG_CONS | LOG_PID, 0);
    syslog(LOG_INFO,
           "This is a syslog test message generated by program %sn",
           argv[0]);
    closelog();
    return 0;
}
编译生成可执行程序后，运行一次程序将向/var/log/message文件添加一行信息如下：
Mar  2 16:17:52 ubuntu zooyo[1380]: This is a syslog test message generated by program ./a.out
openlog函数：
第一个参数ident将是一个标记，ident所表示的字符串将固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记。
第二个参数option是下列值取与运算的结果：
LOG_CONS        直接写入系统控制台，如果有一个错误，同时发送到系统日志记录。
LOG_NDELAY    立即打开连接（通常，打开连接时记录的第一条消息）。
LOG_NOWAIT   不要等待子进程，因为其有可能在记录消息的时候就被创建了（GNU C库不创建子进程，所以该选项在Linux上没有影响。）
LOG_ODELAY    延迟连接的打开直到syslog函数调用。（这是默认情况下，需要没被指定的情况下。）
LOG_PERROR   （不在SUSv3情况下）同时输出到stderr（标准错误文件）。
LOG_PID          包括每个消息的PID。
第三个参数facility是用来指定记录消息程序的类型。它让指定的配置文件，将以不同的方式来处理来自不同方式的消息。
它的值可能为 LOG_KERN、LOG_USER、LOG_MAIL、LOG_DAEMON、LOG_AUTH、LOG_SYSLOG、LOG_LPR、LOG_NEWS、LOG_UUCP、LOG_CRON 或 LOG_AUTHPRIV。
LOG_AUTH ——认证系统：login、su、getty等 
LOG_AUTHPRIV ——同LOG_AUTH，但只登录到所选择的单个用户可读的文件中 
LOG_CRON           ——cron守护进程 
LOG_DAEMON       ——其他系统守护进程，如routed 
LOG_FTP ——文件传输协议：ftpd、tftpd 
LOG_KERN ——内核产生的消息 
LOG_LPR ——系统打印机缓冲池：lpr、lpd 
LOG_MAIL ——电子邮件系统 
LOG_NEWS ——网络新闻系统 
LOG_SYSLOG ——由syslogd（8）产生的内部消息 
LOG_USER ——随机用户进程产生的消息 
LOG_UUCP ——UUCP子系统 
LOG_LOCAL0~LOG_LOCAL7 ——为本地使用保留 
Syslog为每个事件赋予几个不同的优先级： 
LOG_EMERG ——紧急情况 
LOG_ALERT ——应该被立即改正的问题，如系统数据库破坏 
LOG_CRIT ——重要情况，如硬盘错误 
LOG_ERR ——错误 
LOG_WARNING ——警告信息 
LOG_NOTICE ——不是错误情况，但是可能需要处理 
LOG_INFO ——情报信息 
LOG_DEBUG ——包含情报的信息，通常旨在调试一个程序时使用

239. 
int backtrace (void **buffer, int size);
char **backtrace_symbols (void *const *buffer, int size);
void backtrace_symbols_fd (void *const *buffer, int size, int fd);
函数描述
backtrace()函数，获取函数调用堆栈帧数据，即回溯函数调用列表。数据将放在buffer中。参数size用来指定buffer中可以保存多少个void*元素（表示相应栈帧的地址，一个返回地址）。
如果回溯的函数调用大于size，则size个函数调用地址被返回。为了取得全部的函数调用列表，应保证buffer和size足够大。
backtrace_symbols()函数，参数buffer是从backtrace()函数获取的数组指针，size是该数组中的元素个数（backtrace()函数的返回值）。该函数主要功能：
将从backtrace()函数获取的地址转为描述这些地址的字符串数组。每个地址的字符串信息包含对应函数的名字、在函数内的十六进制偏移地址、以及实际的返回地址（十六进制）。需注意的是，
当前，只有使用elf二进制格式的程序才能获取函数名称和偏移地址，此外，为支持函数名功能，可能需要添加相应的编译链接选项如-rdynamic；否则，只有十六进制的返回地址能被获取。
backtrace_symbols()函数返回值是一个字符串指针，是通过malloc函数申请的空间，使用完后，调用者必需把它释放掉。注：如果不能为字符串获取足够的空间，该函数的返回值为NULL。
backtrace_symbols_fd()函数，与backtrace_symbols()函数具有相同的功能，不同的是它不会给调用者返回字符串数组，而是将结果写入文件描述符为fd的文件中，每个函数对应一行。它不会调用malloc函数，因此，它可以应用在函数调用可能失败的情况下。
返回值:
backtrace()函数返回通过buffer返回的地址个数，这个数目不会超过size。如果这个返回值小于size，那么所有的函数调用列表都被保存；如果等于size，那么函数调用列表可能被截断，此时，
一些最开始的函数调用没有被返回。成功时，backtrace_symbols()函数返回一个由malloc分配的数组；失败时，返回NULL。
注意事项
这些函数对函数返回地址如何保存在栈内有一些假设，注意如下：
    忽略帧指针（由gcc任何非零优化级别处理了）可能引起这些假设的混乱。
    内联函数没有栈帧。
    Tail-call（尾调用）优化会导致栈帧被其它调用覆盖。
    为支持函数名功能，可能需要添加相应的编译链接选项如-rdynamic；否则，只有十六进制的返回地址能被获取。
    “static”函数名是不会导出的，也不会出现在函数调用列表里，即使指定了-rdynamic链接选项

240. isinf()函数是cmath标头的库函数，用于检查给定值是否为无限(负无穷大或正无穷大)。 它接受一个值( float ， double或long double )，如果给定值是无穷大，则返回1；
    否则，返回1. 

241.    int strcoll(const char *s1,const char * s2);
        #include<string.h>
        比较字符串s1和s2。功能和strcmp类似,用法也一样.
        特别注意:strcoll()会依环境变量LC_COLLATE所指定的文字排列次序来比较s1和s2 字符串。
        strcmp是根据ASCII来比较2个串的.说明若LC_COLLATE为"POSIX"或"C"，则strcoll()与strcmp()作用完全相同。

242.    int pthread_setname_np(pthread_t thread, const char *name);
        int pthread_getname_np(pthread_t thread, char *name, size_t len);
        prctl()只能设置/获取当前线程的名字
        在glibc 2.12之后的版本中提供了两个扩展的接口pthread_setname_np()和pthread_getname_np()，可以在进程中设置和读取其他线程的名字
        #define    redis_set_thread_title(name) pthread_setname_np(pthread_self(), name)

243.    
       int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask);
       int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
       CPU的亲和性， 就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，也称为CPU关联性；再简单的点的描述就将制定的进程或线程绑定到相应的cpu上；在多核运行的机器上，
       每个CPU本身自己会有缓存，缓存着进程使用的信息，而进程可能会被OS调度到其他CPU上，如此，CPU cache命中率就低了，当绑定CPU后，程序就会一直在指定的cpu跑，不会由操作系统调度到其他CPU上，
       性能有一定的提高。
       软亲和性（affinity）:  就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity） 的特性，
                            这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。
        硬亲和性（affinity）：简单来说就是利用linux内核提供给用户的API，强行将进程或者线程绑定到某一个指定的cpu核运行。
        解释：在linux内核中，所有的进程都有一个相关的数据结构，称为 task_struct。这个结构非常重要，原因有很多；其中与 亲和性（affinity）相关度最高的是 cpus_allowed 位掩码。
        这个位掩码由 n 位组成，与系统中的 n 个逻辑处理器一一对应。 具有 4 个物理 CPU 的系统可以有 4 位。如果这些 CPU 都启用了超线程，那么这个系统就有一个 8 位的位掩码。 
        如果为给定的进程设置了给定的位，那么这个进程就可以在相关的 CPU 上运行。因此，如果一个进程可以在任何 CPU 上运行，并且能够根据需要在处理器之间进行迁移，那么位掩码就全是 
        1。实际上，这就是 Linux 中进程的缺省状态

244.    int pthread_setcancelstate(int state,   int *oldstate)  
            设置本线程对Cancel信号的反应，state有两种值：PTHREAD_CANCEL_ENABLE（缺省）和PTHREAD_CANCEL_DISABLE，
            分别表示收到信号后设为CANCLED状态和忽略CANCEL信号继续运行；old_state如果不为NULL则存入原来的Cancel状态以便恢复。
        int pthread_setcanceltype(int type, int *oldtype)  
            设置本线程取消动作的执行时机，type由两种取值：PTHREAD_CANCEL_DEFFERED和PTHREAD_CANCEL_ASYCHRONOUS，仅当Cancel状态为Enable时有效，
            分别表示收到信号后继续运行至下一个取消点再退出和立即执行取消动作（退出）；oldtype如果不为NULL则存入运来的取消动作类型值

245.     int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
          pthread_sigmask 用于多线程 ; 新线程拥有一份pthread_create那个线程的屏蔽信号拷贝;
        每个线程均有自己的信号屏蔽集（信号掩码），可以使用pthread_sigmask函数来屏蔽某个线程对某些信号的
        响应处理，仅留下需要处理该信号的线程来处理指定的信号。实现方式是：利用线程信号屏蔽集的继承关系
        （在主进程中对sigmask进行设置后，主进程创建出来的线程将继承主进程的掩码）
        注意事项：sigprocmask()函数只为单线程的进程定义的，在多线程中要使用pthread_sigmask变量，在使用之前需要声明和初始化
        1．SIG_BLOCK:　该值代表的功能是将newset所指向的信号集中所包含的信号加到当前的信号掩码中，作为新的信号屏蔽字。
        2．SIG_UNBLOCK:将参数newset所指向的信号集中的信号从当前的信号掩码中移除。
        3．SIG_SETMASK:设置当前信号掩码为参数newset所指向的信号集中所包含的信号

        屏蔽过程中接受到的信号如何处理
           在信号屏蔽过程中，出现的所有被屏蔽的信号，不管发生多少次，
           在信号解除屏蔽后，系统会执行一次被屏蔽信号上的操作

246.  oom_score_adj
      OOM killer 给进程打分，把 oom_score 最大的进程先杀死。
      打分主要有两部分组成：
      一是系统根据该进程的内存占用情况打分，进程的内存开销是变化的，所以该值也会动态变化。
      二是用户可以设置的 oom_score_adj，范围是 -1000到 1000

247   double fmod(double x, double y)
      C 库函数 double fmod(double x, double y) 返回 x 除以 y 的余数。
      参数
        x -- 代表分子的浮点值。
        y -- 代表分母的浮点值。
       9.200000 / 2 的余数是 1.200000      9.200000 / 3.700000 的余数是 1.800000

248   time_t mktime(struct tm *timeptr) 
      把 timeptr 所指向的结构转换为自 1970 年 1 月 1 日以来持续时间的秒数，发生错误时返回-1
      struct tm {
           int tm_sec;         /* 秒，范围从 0 到 59                */
           int tm_min;         /* 分，范围从 0 到 59                */
           int tm_hour;        /* 小时，范围从 0 到 23               */
           int tm_mday;        /* 一月中的第几天，范围从 1 到 31       */
           int tm_mon;         /* 月份，范围从 0 到 11               */
           int tm_year;        /* 自 1900 起的年数                  */
           int tm_wday;        /* 一周中的第几天，范围从 0 到 6        */
           int tm_yday;        /* 一年中的第几天，范围从 0 到 365      */
           int tm_isdst;       /* 夏令时                            */    
      };

249   
    https://blog.csdn.net/naipeng/article/details/89918482
    int io_setup(unsigned nr_events,  aio_context_t *ctxp);
    int io_destroy(aio_context_t ctx);
    int io_submit(aio_context_t ctx,  long nr,  struct iocb *cbp[]);
    int io_cancel(aio_context_t ctx,  struct iocb *,  struct io_event *result);
    int io_getevents(aio_context_t ctx, long min_nr, long nr, struct io_event *events, struct timespec *timeout);
AIO系统调用总共五个，后面会一一介绍。

int io_setup(unsigned nr_events,  aio_context_t *ctxp);
int io_destroy(aio_context_t ctx);
int io_submit(aio_context_t ctx,  long nr,  struct iocb *cbp[]);
int io_cancel(aio_context_t ctx,  struct iocb *,  struct io_event *result);
int io_getevents(aio_context_t ctx, long min_nr, long nr, struct io_event *events, struct timespec *timeout);

2.1 异步IO上下文 aio_context_t
#define _GNU_SOURCE     /* syscall() is not POSIX */
#include <stdio.h>      /* for perror() */
#include <unistd.h>     /* for syscall() */
#include <sys/syscall.h>    /* for __NR_* definitions */
#include <linux/aio_abi.h>  /* for AIO types and constants */
inline int io_setup(unsigned nr, aio_context_t *ctxp)
{
    return syscall(__NR_io_setup, nr, ctxp);
}
inline int io_destroy(aio_context_t ctx)
{
    return syscall(__NR_io_destroy, ctx);
}
int main()
{
    aio_context_t ctx;
    int ret;
    ctx = 0;
    ret = io_setup(128, &ctx);
    if (ret < 0) {
        perror("io_setup error");
        return -1;
    }
    printf("after io_setup ctx:%Ld\n",ctx);
    ret = io_destroy(ctx);
    if (ret < 0) {
        perror("io_destroy error");
        return -1;
    }
    printf("after io_destroy ctx:%Ld\n",ctx);
    return 0;
}
系统调用io_setup会创建一个所谓的"AIO上下文"(即aio_context，后文也叫‘AIO context’等)结构体到在内核中。aio_context是用以内核实现异步AIO的数据结构。它其实是一个无符号整形,位于头文件 /usr/include/linux/aio_abi.h。

typedef unsigned long   aio_context_t;
1
每个进程都可以有多个aio_context_t。传入io_setup的第一个参数在这里是128，表示同时驻留在上下文中的IO请求的个数；第二个参数是一个指针，内核会填充这个值。
io_destroy的作用是销毁这个上下文aio_context_t。
上面的例子很简单，创建一个aio_context_t并销毁。

2.2 提交并查询IO
#define _GNU_SOURCE /* syscall() is not POSIX */ 
#include <stdio.h> /* for perror() */ 
#include <unistd.h> /* for syscall() */ 
#include <sys/syscall.h> /* for __NR_* definitions */ 
#include <linux/aio_abi.h> /* for AIO types and constants */ 
#include <fcntl.h> /* O_RDWR */ 
#include <string.h> /* memset() */ 
#include <inttypes.h> /* uint64_t */ 
inline int io_setup(unsigned nr, aio_context_t *ctxp) 
{ 
    return syscall(__NR_io_setup, nr, ctxp); 
} 

inline int io_destroy(aio_context_t ctx) 
{ 
	return syscall(__NR_io_destroy, ctx); 
} 

inline int io_submit(aio_context_t ctx, long nr, struct iocb **iocbpp) 
{ 
	return syscall(__NR_io_submit, ctx, nr, iocbpp); 
}

inline int io_getevents(aio_context_t ctx, long min_nr, long max_nr, struct io_event *events, struct timespec *timeout) 
{ 
	return syscall(__NR_io_getevents, ctx, min_nr, max_nr, events, timeout);
} 

int main() 
{ 
	aio_context_t ctx; 
	struct iocb cb; struct iocb *cbs[1]; 
	char data[4096]; 
	struct io_event events[1]; 
	int ret; 
	int fd;
	int i ; 
	for(i=0;i<4096;i++) 
	{ 
		data[i]=i%50+60; 
	} 
	fd = open("./testfile", O_RDWR | O_CREAT,S_IRWXU);
	if (fd < 0) 
	{ 
		perror("open error"); 
		return -1; 
	} 
	
    ctx = 0;
    ret = io_setup(128, &ctx); 
    printf("after io_setup ctx:%ld",ctx); 
    if (ret < 0)
    { 
    	perror("io_setup error"); 
    	return -1; 
    } /* setup I/O control block */ 
    memset(&cb, 0, sizeof(cb)); 
    cb.aio_fildes = fd; 
    cb.aio_lio_opcode = IOCB_CMD_PWRITE;/* command-specific options */ 
    cb.aio_buf = (uint64_t)data; 
    cb.aio_offset = 0; 
    cb.aio_nbytes = 4096; 
    cbs[0] = &cb;
	ret = io_submit(ctx, 1, cbs);
	if (ret != 1) 
	{ 
		if (ret < 0) 
			perror("io_submit error"); 
		else
			fprintf(stderr, "could not sumbit IOs"); 
		return -1; 
	} /* get the reply */ 
    
    ret = io_getevents(ctx, 1, 1, events, NULL); 
    printf("%d\n", ret); 
    struct iocb * result = (struct iocb *)events[0].obj; 
    printf("reusult:%Ld",result->aio_buf); 
    ret = io_destroy(ctx); 
    if (ret < 0)
    { 
    	perror("io_destroy error"); 
    	return -1; 
    } 
    return 0;
}

每一个提交的IO请求用结构体struct iocb来表示。
首先初始化这个结构体为全零： memset(&cb, 0, sizeof(cb));
然后初始化文件描述符(cb.aio_fildes = fd)和AIO 命令(cb.aio_lio_opcode = IOCB_CMD_PWRITE)
文件描述符对应上文所打开的文件。本例中是./testfile.
内核当前支持的AIO 命令有
IOCB_CMD_PREAD   	读; 对应系统调用pread().
IOCB_CMD_PWRITE   	写，对应系统调用pwrite().
IOCB_CMD_FSYNC   	同步文件数据到磁盘，对应系统调用fsync()
IOCB_CMD_FDSYNC   	同步文件数据到磁盘，对应系统调用fdatasync()
IOCB_CMD_PREADV  	读，对应系统调用readv()
IOCB_CMD_PWRITEV    写，对应系统调用writev()
IOCB_CMD_NOOP   	只是内核使用

调用io_submit
函数原型int io_submit(aio_context_t ctx, long nr, struct iocb *cbp[]);
当一个IO控制块（struct iocb cb）初始化完毕，把这个指针放入一个数组中( cbs[0] = &cb)，因为io_submit系统调用需要接受一个二维指针。在io_submit(ctx, 1, cbs)中， 参数分别为IO上下文（aio_context_t）、数组（struct iocb）大小、数组地址(cbs).
io_submit的返回值，可以是如下值：
A. ret = (提交的iocb的数目)           表示所有的iocb都被接受并处理
B. 0 < ret <  (提交的iocb的数目)      io_submit() 系统调用会从传入的cbs中一个一个处理iocb，如果提交的某个iocb失败，将停止并且返回iocb的索引号。没办法知晓错误的具体原因，但是如果第一个iocb提交失败，参看C条。
C. ret < 0 							有两种原因：
									1. 在io_submit()开始之前发生了某种错误(e.g.比如AIO context非法). 
									2. 提交第一个iocb(cbx[0])失败

调用io_getevents()
当提交了iocb之后，可以不用等待IO完成去做其他的操作。对于每一个已经完成的IO请求(成功或失败），内核都会创建一个io_event结构。io_getevent()系统调用可以用来获取这一结构。这需要做以下操作。
int io_getevents(aio_context_t ctx, long min_nr, long nr, struct io_event *events, struct timespec *timeout)
1
a) 使用哪一个AIO上下文(变量ctx)
b) 内核把这个变量放入哪个内存位置 (变量events)
c) events的最小个数(变量min_nr,)，如果完成的iocb的个数比这个值要小io_getevents会阻塞，直到达到这个值, 参看第e条查看阻塞时间。
d) 想要获取的events的最大个数(变量nr)。
e) 如果获取不到足够的events，而又不想永久等待。可以指定相对时间(timeout)到最后一个参数，
如果timeout为NULL，表示永久等待。
如果timeout为0，io_getevents()不阻塞 。

250    getaddrinfo()

#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *restrict nodename, /* host 或者IP地址 */
    const char *restrict servname, /* 十进制端口号 或者常用服务名称如"ftp"、"http"等 */
    const struct addrinfo *restrict hints, /* 获取信息要求设置 */
    struct addrinfo **restrict res); /* 获取信息结果 */

void freeaddrinfo(struct addrinfo *ai); 
复制代码
Data Structure
http://www.cnblogs.com/LubinLew/p/POSIX-DataStructure.html#struct_addrinfo

Description
IPv4中使用gethostbyname()函数完成主机名到地址解析，这个函数仅仅支持IPv4，

且不允许调用者指定所需地址类型的任何信息，返回的结构只包含了用于存储IPv4地址的空间。

IPv6中引入了新的API getaddrinfo()，它是协议无关的，既可用于IPv4也可用于IPv6。

getaddrinfo() 函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个 struct addrinfo 的结构体(列表)指针而不是一个地址清单。

这些 struct addrinfo 结构体随后可由套接口函数直接使用。如此以来，getaddrinfo()函数把协议相关性安全隐藏在这个库函数内部。

应用程序只要处理由getaddrinfo()函数填写的套接口地址结构。

Parameter
1) nodename
主机名("www.baidu.com")或者是数字化的地址字符串(IPv4的点分十进制串("192.168.1.100")或者IPv6的16进制串("2000::1:2345:6789:abcd"))，

如果 ai_flags 中设置了AI_NUMERICHOST 标志，那么该参数只能是数字化的地址字符串，不能是域名，

该标志的作用就是阻止进行域名解析。

nodename 和 servname 可以设置为NULL，但是同时只能有一个为NUL。

2) servname
服务名可以是十进制的端口号("8080")字符串，也可以是已定义的服务名称，如"ftp"、"http"等,详细请查看/etc/services 文件，

最后翻译成对应服务的端口号。如果此参数设置为NULL，那么返回的socket地址中的端口号不会被设置。

如果 ai_flags 设置了AI_NUMERICSERV 标志并且该参数未设置为NULL，那么该参数必须是一个指向10进制的端口号字符串，

不能设定成服务名，该标志就是用来阻止服务名解析。

 

3) hints
该参数指向用户设定的 struct addrinfo 结构体，只能设定该结构体中 ai_family、ai_socktype、ai_protocol 和 ai_flags 四个域，

其他域必须设置为0 或者 NULL, 通常是申请 结构体变量后使用memset()初始化再设定指定的四个域。

该参数可以设置为NULL，等价于 ai_socktype = 0， ai_protocol = 0，ai_family = AF_UNSPEC， 

ai_flags = 0 （在GNU Linux中ai_flag = AI_V4MAPPED | AI_ADDRCONFIG,可以看作是GNU的改进）。

　① ai_family
　　指定返回地址的协议簇，取值范围:AF_INET(IPv4)、AF_INET6(IPv6)、AF_UNSPEC(IPv4 and IPv6)

   ② ai_socktype
　　具体类型请查看struct addrinfo 中的 enum __socket_type 类型，用于设定返回地址的socket类型，

　　常用的有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW, 设置为0表示所有类型都可以。

　③ ai_protocol
　　具体取值范围请查看 Ip Protocol ，常用的有 IPPROTO_TCP、IPPROTO_UDP 等，设置为0表示所有协议。

　④ ai_flags
　　附加选项,多个选项可以使用或操作进行结合，具体取值范围请查看struct addrinfo , 常用的标志如下：

AI_PASSIVE
　　　　如果设置了 AI_PASSIVE 标志,并且 nodename 是 NULL, 那么返回的socket地址可以用于的bind()函数，

     　　返回的地址是通配符地址(wildcard address, IPv4时是INADDR_ANY,IPv6时是IN6ADDR_ANY_INIT)，

     　　这样应用程序(典型是server)就可以使用这个通配符地址用来接收任何请求主机地址的连接，

     　　如果 nodename 不是NULL，那么 AI_PASSIVE 标志被忽略；

　　　　如果未设置AI_PASSIVE标志,返回的socket地址可以用于connect(), sendto(), 或者 sendmsg()函数。

　　　　如果 nodename 是NULL，那么网络地址会被设置为lookback接口地址(IPv4时是INADDR_LOOPBACK,IPv6时是IN6ADDR_LOOPBACK_INIT)，

　　　　这种情况下，应用是想与运行在同一个主机上另一个应用通信。

AI_CANONNAME
 　　　　请求canonical(主机的official name)名字。如果设置了该标志，那么 res 返回的第一个 struct addrinfo 中的 ai_canonname 域会存储official name的指针。

AI_NUMERICHOST
 　　　　阻止域名解析，具体见 nodename 中的说明。

AI_NUMERICSERV
　　　　阻止服务名解析，具体见 servname 中的说明。

AI_V4MAPPED
 　　　　当 ai_family 指定为AF_INT6(IPv6)时，如果没有找到IPv6地址，那么会返回IPv4-mapped IPv6 地址，

　　　　也就是说如果没有找到AAAA record(用来将域名解析到IPv6地址的DNS记录),那么就查询A record(IPv4),

　　　　将找到的IPv4地址映射到IPv6地址, IPv4-mapped IPv6 地址其实是IPv6内嵌IPv4的一种方式，

　　　　地址的形式为"0::FFFF:a.b.c.d"，例如"::ffff:192.168.89.9"(混合格式)这个地址仍然是一个IPv6地址，

           只是"0000:0000:0000:0000:0000:ffff:c0a8:5909"(16机制格式)的另外一种写法罢了。

　　　　当 ai_family 不是AF_INT6(IPv6)时，该标志被忽略。

AI_ALL
 　　　　查询IPv4和IPv6地址

AI_ADDRCONFIG
　　　　只有当主机配置了IPv4地址才进行查询IPv4地址；只有当主机配置了IPv6地址才进行查询IPv6地址.

4) res
 该参数获取一个指向存储结果的 struct addrinfo 结构体列表，使用完成后调用 freeaddrinfo() 释放存储结果空间。

 

Return Value
如果 getaddrinfo() 函数执行成功，返回值为 0 ， 其他情况返回值表示错误种别。使用函数gai_strerror() 可以获取可读性的错误信息,用法用strerror()相同，

错误种别如下：

EAI_ADDRFAMILY
　　　　指定的主机上没有请求的address family对应的网络地址.

EAI_AGAIN
　　　　DNS(name server)返回临时性错误. 可以稍后重试.

EAI_BADFLAGS
　　　　hints.ai_flags 包含了无效的标志; 或者 hints.ai_flags 包含了 AI_CANONNAME 标志但是 name 是 NULL.

EAI_FAIL
　　　　DNS(name server)返回永久性错误

EAI_FAMILY
　　　　不支持的 address family(hints.ai_family).

EAI_MEMORY
　　　　内存耗尽.

EAI_NODATA
　　　　指定的网络主机存在，但是其未定义任何网络地址.

EAI_NONAME
　　　　nodename 或者 servname 未知;或者两者都设置为NULL;

　　　　或者设置了 AI_NUMERICSERV 标志但是 servname 不是一个数字化的端口名字符串。

EAI_SERVICE
　　　　请求的socket类型不支持请求的服务类型.例如服务类型是 "shell" (基于流的socket服务)，

　　　　但是 hints.ai_protocol 是  IPPROTO_UDP 或者hints.ai_socktype 是 SOCK_DGRAM;

　　　　或者 servname 不是NULL 但是 hints.ai_socktype 是 SOCK_RAW (原始套接字不支持服务的概念).

EAI_SOCKTYPE
　　　　不支持请求的socket类型. 例如, hints.ai_socktype 和 hints.ai_protocol 冲突 (例如分别是SOCK_DGRAM、IPPROTO_TCP).

EAI_SYSTEM
　　　　系统调用错误，检查 errno.

Example
man getaddrinfo 最后有客户端和服务器端2个例子。

下面是一个获取google https 所有服务地址(IPv4 和 IPv6 的例子)

 

复制代码
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

#define BUF_SIZE 500

int main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, s, j;
    size_t len;
    ssize_t nread;
    char buf[BUF_SIZE];
    struct sockaddr_in  *ipv4;
    struct sockaddr_in6 *ipv6;

    /* Obtain address(es) matching host/port */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_ALL;
    hints.ai_protocol = IPPROTO_TCP;

    s = getaddrinfo("www.google.com", "https", &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    for (rp = result; rp != NULL; rp = rp->ai_next) {
        switch (rp->ai_family) {
        case AF_INET:
            ipv4 = (struct sockaddr_in *)rp->ai_addr;
            inet_ntop(rp->ai_family, &ipv4->sin_addr, buf, sizeof(buf));
            break;
        case AF_INET6:
            ipv6 = (struct sockaddr_in6 *)rp->ai_addr;
            inet_ntop(rp->ai_family, &ipv6->sin6_addr, buf, sizeof(buf));
            break;
        }
        
        printf("[IPv%d]%s\n", rp->ai_family==AF_INET?4:6, buf);
    }

    /* No longer needed */
    freeaddrinfo(result);           

    exit(EXIT_SUCCESS);
}


251. 每一个线程在任何情况，要么是可结合的状态（joinable），要么是可分离的状态（detached）。
先将这两个函数的原型列一下
int pthread_join(pthread_t tid, void ** pthread_return);
int pthread_detach(pthread_t tid);
当我们的线程运行结束后，最后显示的调用被回收。这样就出现两种回收方式。
1. pthread_join是一个阻塞函数，调用方会阻塞到pthread_join所指定的tid的线程结束后才被回收，但是在此之前，调用方是霸占系统资源的。
2. pthread_detach，不会阻塞，调用它后，线程运行结束后会自动释放资源。
PS：一个可结合线程在运行结束后，若没有调用pthread_join，会进入一个类似zombie process的状态，也就是系统中还有一些资源没有回收。需要pthread_join来回收这些资源。
（这就类似进程操作中的waitpid函数）线程在创建时默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process（僵尸进程）,
即还有一部分资源没有被回收（退出状态码），所以创建线程者应该 pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid)，
这样不会导致系统越用越慢的现象。
但是 pthread_join(pthread_id)函数是阻塞函数，在 调用pthread_join(pthread_id)后，如果该 线程 没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，
比如在Web服务器中当 主线程 为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码
pthread_detach( pthread_self())
或者父线程调用
pthread_detach(thread_id)（非阻塞，可立即返回）
这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。 
在嵌入式系统中，如果某些线程要伴随系统一直运行下去，该种情况下是否采用该该函数进行回收，没有什么价值。

252. 定义函数：char * getcwd(char * buf, size_t size);
     函数说明：getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。
    注：
    1、在调用此函数时，buf 所指的内存空间要足够大。若工作目录绝对路径的字符串长度超过参数size 大小，则返回NULL，errno 的值则为ERANGE。
    2、倘若参数buf 为NULL，getcwd()会依参数size 的大小自动配置内存(使用malloc())，如果参数size 也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，
       进程可以在使用完次字符串后利用free()来释放此空间。

253. streamsize istream::gcount();
函数gcount()用于输入流, 返回read最后一次非格式化读取的字符的个数

254. int sendto(int s, const void * msg, int len, unsigned int flags, const struct sockaddr * to, int tolen);
    函数说明：sendto() 用来将数据由指定的socket 传给对方主机. 参数s 为已建好连线的socket, 如果利用UDP协议则不需经过连线操作. 参数msg 指向欲连线的数据内容, 参数flags 一般设0, 
             详细描述请参考send(). 参数to 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数tolen 为sockaddr 的结果长度.
    返回值：成功则返回实际传送出去的字符数, 失败返回－1, 错误原因存于errno 中.
    int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen);

255. 迭代器
    begin() 返回一个迭代器，它指向容器c的第一个元素
    end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置
    rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素
    rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置

256. sscanf()

257. 头文件：#include <unistd.h>
     定义函数：size_t getpagesize(void);
     函数说明：返回一分页的大小，单位为字节(byte)。此为系统的分页大小，不一定会和硬件分页大小相同。
     返回值：内存分页大小。
     附加说明：在 Intel x86 上其返回值应为4096bytes。

258. 在Linux中，mprotect()函数可以用来修改一段指定内存区域的保护属性。
函数原型如下：
#include <unistd.h> 
#include <sys/mmap.h> 
int mprotect(const void *start, size_t len, int prot); 
mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。
prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：
1）PROT_READ：表示内存段内的内容可写；
2）PROT_WRITE：表示内存段内的内容可读；
3）PROT_EXEC：表示内存段中的内容可执行；
4）PROT_NONE：表示内存段中的内容根本没法访问。
需要指出的是，锁指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。
如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：
1）EACCES
该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。
2）EINVAL
start 不是一个有效的指针，指向的不是某个内存页的开头。
3）ENOMEM
内核内部的结构体无法分配。
4）ENOMEM
进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。
如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程。
原文链接：https://blog.csdn.net/earbao/article/details/51536304

259. void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
返回说明
成功执行时，mmap()返回被映射区的指针。失败时，mmap()返回MAP_FAILED[其值为(void *)-1]， error被设为以下的某个值：
EACCES：访问出错
EAGAIN：文件已被锁定，或者太多的内存已被锁定
EBADF：fd不是有效的文件描述词
EINVAL：一个或者多个参数无效
ENFILE：已达到系统对打开文件的限制
ENODEV：指定文件所在的文件系统不支持内存映射
ENOMEM：内存不足，或者进程已超出最大内存映射数量
EPERM：权能不足，操作不允许
ETXTBSY：已写的方式打开文件，同时指定MAP_DENYWRITE标志
SIGSEGV：试着向只读区写入
SIGBUS：试着访问不属于进程的内存区
参数
start：映射区的开始地址
length：映射区的长度
prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起
PROT_EXEC：页内容可以被执行
PROT_READ：页内容可以被读取
PROT_WRITE：页可以被写入
PROT_NONE：页不可访问
flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体
MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。
MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
MAP_DENYWRITE //这个标志被忽略。
MAP_EXECUTABLE //同上
MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。
MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。
MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。
MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。
MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。
MAP_FILE //兼容标志，被忽略。
MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。
MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。
fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1
offset：被映射对象内容的起点
相关函数
int munmap( void * addr, size_t len ) 
成功执行时，munmap()返回0。失败时，munmap返回-1，error返回标志和mmap一致；
该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；
当映射关系解除后，对原来映射地址的访问将导致段错误发生。
int msync( void *addr, size_t len, int flags )
一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。
可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致

259. mmap使用细节
1、使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。
2、内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。具体情形参见“情形三”。
3、映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。
在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：
情形一：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。
分析：因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。映射后的对应关系如下图所示：
此时：
（1）读/写前5000个字节（0~4999），会返回操作文件内容。
（2）读字节5000~8191时，结果全为0。写5000~8191时，进程不会报错，但是所写的内容不会写入原文件中 。
（3）读/写8192以外的磁盘部分，会返回一个SIGSECV错误。
情形二：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。
分析：由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常。如下图所示：
此时：
（1）进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中。
（2）对于5000~8191字节，进程可以进行读写过程，不会报错。但是内容在写入前均为0，另外，写入后不会反映在文件中。
（3）对于8192~14999字节，进程不能对其进行读写，会报SIGBUS错误。
（4）对于15000以外的字节，进程不能对其读写，会引发SIGSEGV错误。
情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。
分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。
但是如果，每次操作ptr读写前，先增加文件的大小，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr ~ [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。
这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。

260. std::transform
unary operation(1)	
template <class InputIterator, class OutputIterator, class UnaryOperation>
    OutputIterator transform (InputIterator first1, InputIterator last1, OutputIterator result, UnaryOperation op);

binary operation(2)	
template <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation> 
    OutputIterator transform (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op);

261. int fsync(int fildes);
     int fdatasync(int fildes)
     fsync()强制与描述字fildes相连文件的所有修改过的数据（包括核内I/O缓冲区中的数据）传送到外部永久介质，即刷新fildes给出的文件的所有信息。
     调用 fsync()的进程将阻塞直到设备报告传送已经完成。这里“所有修改过的数据”包括用户写出的数据以及文件本身的特征数据（4.1.1节和表4-1），
     如文件的访问时间、修改时间、文件的属主等。
     fdatasync()的功能与fsync()类似，只是它只强制传送用户已写出的数据至物理存储设备，不包括文件本身的特征数据。这样可以适当减少文件刷新时的数据传送量。
     不过有的系统并不支持fdatasync()，在这种系统上，fdatasync()等价于fsync()。

262. 头文件：#include <stdio.h>
     remove()函数用于删除指定的文件，其原型如下：
     int remove(char * filename);
     【参数】filename为要删除的文件名，可以为一目录。如果参数filename 为一文件，则调用unlink()处理；若参数filename 为一目录，则调用rmdir()来处理。
     【返回值】成功则返回0，失败则返回-1，错误原因存于errno。

263.  #include <unistd.h>
       int rmdir(const char *pathname);
       RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

264. 函数原型：extern void *memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen);
     功能：memmem - locate a
     substring，用于在一块内存中寻找匹配另一块内存的内容的第一个位置
     返回值：返回该位置的指针，如找不到，返回空指针

265. 