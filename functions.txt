#include <stdio.h>
#include <iostream>
#include <string>
using namespace std;

int main(int argc, char *argv[]) {
	
	return 0;
}


1. std::floor 和 std::ceil都是对变量进行四舍五入，只不过四舍五入的方向不同。 
1: std::floor -->向下取整数
2: std::ceil   -->向上取整数：
例如： 5.88   std::floor(5.88) = 5;
std::ceil(5.88)   = 6;


2.
thread::hardware_concurrency();//获取cpu核心个数 


3. 
1.typeid是C++的关键字之一，等同于sizeof这类的操作符
2.typeid操作符的返回结果是名为type_info的标准库类型的对象的引用（在头文件typeinfo中定义）
3.C++并没有规定typeid实现标准，各个编译器可能会不一样
4.编译器会为每一种typeid操作的类型生成一份保存在数据段的type_info数据。
5.每种类型的type_info数据长度依赖于类型名称，至少9个字节


4. 数字转成字符串

to_string(x)

5.strftime()  格式化输出时间
6.strptime()  函数将字符串转换成 tm 结构
7.int vsprintf(char *string, char *format, va_list param) 可变参数按照format格式输出到string
8.int vfprintf(FILE *stream, char *format, va_list param) 可变参数按照format格式输出到文件 stream
9.  int inet_aton(const char *cp, struct in_addr *inp) 将IPv4的字符串地址（xxx.xxx.xxx.xxx）转换成网络地址结构体 struct in_addr
10. char *inet_ntoa(struct in_addr in)  是将网络字节序的整形转化成字符串（“xxx.xxx.xxx.xxx"）的IPv4地址
11. int fcntl(int fd, int cmd, ...) fcntl是用来修改已经打开文件的属性的函数.
12. void *realloc(void *ptr, size_t size); 尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小
12. void *calloc(size_t n, size_t size)；
    其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int *p = (int *)calloc(20, sizeof(int)）,
	这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，
	对空间逐一进行初始化，并设置值为0

13. void perror(const char *s);
    perror ( )用 来 将 上 一 个 函 数 发 生 错 误 的 原 因 输 出 到 标 准 设备 (stderr) 。参数 s 所指的字符串会先打印出,后面再加上错误原因字符串

14. char* strerror(int errnum);
15. int strerror_r(int errnum, char *buf, size_t n); 它的好处是可以把错误描述字符串放在用户自定义的buffer中
16. std::reverse  反转  std::reverse(myvector.begin(),myvector.end()); 
17. std::reverse_copy  myvector.resize(9) std::reverse_copy (myints, myints+9, myvector.begin());
18. std::string reserve() 改变容器大小.
19. struct tm *gmtime_r(const time_t *timep, struct tm *result)
 gmtime和localtime后要立即处理结果，否则返回的指针指向的内容可能会被覆盖，一个好的方法是使用gmtime_r和localtime_r，由于使用了用户分配的内存，这两个函数是不会出错的
 
20. time_t time(time_t *tloc);  ime() 是指返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数的函数，主要用来获取当前的系统时间，返回的结果是一个time_t类型

21  int gethostname(char *name, size_t len);   // miao-System-Product-Name
22. std::reverse  反转  std::reverse(myvector.begin(),myvector.end()); 
23. std::reverse_copy  myvector.resize(9) std::reverse_copy (myints, myints+9, myvector.begin());
24. std::string reserve() 改变容器大小.


25. int memcmp(const void *buf1, const void *buf2, unsigned int count);
    比较内存区域buf1和buf2的前count个字节。返回值当buf1<buf2时，返回值<0当buf1=buf2时，返回值=0当buf1>buf2时，返回值>0
	
26  string 构造函数
1    string s; //生成一个空字符串s 
2 b) string s(str) //拷贝构造函数 生成str的复制品 
3 c) string s(str, int stridx) //将字符串str内"始于位置stridx"的部分当作字符串的初值 
4 d) string s(str, int stridx, int strlen) //将字符串str内"始于stridx且长度顶多strlen"的部分作为字符串的初值 
5 e) string s(const char*) //将cstr字符串作为s的初值 
6 f) string s(chonst char*, int len) //将C字符串前chars_len个字符作为字符串s的初值。 
7 g) string s(int num, char c) //生成一个字符串，包含num个c字符 
8 h) string s(beg, end) //以区间beg;end(不包含end)内的字符作为字符串s的初值 


27 std::string.assign()方法可以理解为先将原字符串清空，然后赋予新的值作替换
   1.  string& assign ( const string& str );  将str替换原字串的内容
   2.  string& assign ( const string& str, size_t pos, size_t n );将str的内容从位置pos起的n个字符作为原字串的新内容赋给原字串
   3.  string& assign ( const char* s, size_t n ); 将字符数组或者字符串的首n个字符替换原字符串内容
   4.  string& assign ( const char* s ); 将字符串或者字符数组作为新内容替换原字串
   5.  string& assign ( size_t n, char c );   将原字串替换为n个字符c
   6.  template <class InputIterator>   string& assign ( InputIterator first, InputIterator last)  //从终端读取字符
   
28. string.reserve(size_t n = 0)  //改变内存大小
  将字符串的容量设置为至少size. 如果size指定的数值要小于当前字符串中版的字符数(亦即size < this→权size()), 容量将被设置为可以恰好容纳字符的数值. reserve()以线性时间(linear time)运行。
  它最大的用处是为了避免反复重新分配缓冲区内存而导致效率降低

29. string.resize(size_type size, char val = char())   //改变字符长度大小，
    val默认为空格，如果size小于原来的大小，则截取size大小的字符，反之用'0'来代替.

30. pid_t getpid(void); 获取进程id //26110

31. pid_t getppid(void); 获取父进程id //26066

32. uid_t getuid(void); 获得用户 UID 值 // 1

33. int getpwuid_r(uid_t uid, struct passwd *pwd, char *buf, size_t buflen, struct passwd **result); 得到用户id  "miao"

34. uid_t geteuid(void);用户有效 UID 值 1000

35. void std::unique_ptr::reset (nullptr_t p) noexcept;  cplusplus.com/  deletes managed object, acquires new pointe

36. FILE *fopen(const char *pathname, const char *mode); // 'a' appending

37. void setbuffer(FILE * stream,char * buf,size_t size);
    打开文件流后，读取内容之前，调用setbuffer()可用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址，参数size为缓冲区大小

38. int fflush(FILE *stream)
    清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入时
	
39. size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 
    size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream); fwrite_unlocked是fwrite的线程不安全版本，因为不加锁
      1) buffer是一个指针。对fwrite来说是要写入数据的地址。
      2) size是要写入内容的单字节数。
      3) count是要 进行写入size字节的数据项的个数。
      4) stream为目标文件指针
      5) 返回实际写入的数据项个数count
	
40. int ferror(FILE *stream);  ferror 函数返回为真时就表示有错误发生

41. int strerror_r(int errnum, char *buf, size_t n); 错误描述拷贝到buf中.

42. int fstat(int fildes,struct stat *buf);
    用来将参数fildes所指的文件状态，复制到参数buf所指的结构中(struct stat).
	
43. S_ISREG(mode)        是否是一个常规文件.
44. S_ISDIR(mode)              是否是一个目录

45. char *strchr(const char *s, int c);  returns a pointer to the first occurrence of the character c in the string s
    
46. char *strrchr(const char *s, int c);  returns a pointer to the last occurrence of  the character c in the string s .可以说是从右边遍历

47.  static_assert(常量表达式，"提示字符串")
    如果第一个参数常量表达式的值为false，会产生一条编译错误。错误位置就是该static_assert语句所在行，第二个参数就是错误提示字符串
	
48  digits10  返回得是float不损失精度的小数位; 
    cout << "digits10(float): " << numeric_limits<float>::digits10 << endl; 6
	
49  digits  返回的是float不损失精度的整数位:24 
    std::numeric_limits::digits函数用于查找数据类型可以表示而不损失精度的基数位数   //可以看下浮点数内存分布
    
    numeric_limits<int>::digits           //31
    numeric_limits<float>::digits         //24
    numeric_limits<double>::digits        //53
    numeric_limits<long double>::digits   //64

50. abort()和exit()
   共同点: 都是用来终止程序
   不同点:
   1)abort(): 立即结束，不做任何操作
   2)exit():   释放所有静态全局的对象、缓存，关掉所有的I/O通道，然后终止程序.如果有函数通过atexit来注册，还会调用注册的函数，如果atexit函数抛出异常就会直接调用结束。

51. int atexit(void （*func)(void));
   很多时候我们需要在程序退出的时候做一些诸如释放资源的操作，但程序退出的方式有很多种，比如main()函数运行结束、在程序的某个地方用exit()结束程序、
   用户通过Ctrl+C或Ctrl+break操作来终止程序等等，因此需要有一种与程序退出方式无关的方法来进行程序退出时的必要处理。方法就是用atexit()函数来注册程序正常终止时要被调用的函数
   在一个程序中最多可以用atexit()注册32个处理函数，这些处理函数的调用顺序与其注册的顺序相反，也即最先注册的最后调用，最后注册的最先调用

52.  pthread_t pthread_self(void);  // 11281
   返回一个 pthread_t 类型的变量，指代的是调用 pthread_self 函数的线程的 “ID”。
   怎么理解这个“ID”呢？这个“ID”是 pthread 库给每个线程定义的进程内唯一标识，是 pthread 库维持的。
   由于每个进程有自己独立的内存空间，故此“ID”的作用域是进程级而非系统级（内核不认识）
   其实 pthread 库也是通过内核提供的系统调用（例如clone）来创建线程的，而内核会为每个线程创建系统全局唯一的“ID”来唯一标识这个线程。
   这个系统全局唯一的“ID”叫做线程PID（进程ID），或叫做TID（线程ID），也有叫做LWP（轻量级进程=线程）的
   
53   pid_t syscall(SYS_gettid) 系统调用返回一个 pid_t 类型值，即线程在内核中的ID   //140429854775040

54 int isdigit(int c); 参数c表示要检测的字符或者 ASCII 码。
   返回值为非 0（真）表示 c 是数字，返回值为 0（假）表示c不是数字
   
55  ssize_t readlink(const char *pathname, char *buf, size_t bufsiz)；  readlink("/proc/self/exe", buf, sizeof(buf)) 可获取exe文件目录

56 int getrlimit(int resource, struct rlimit *rlp);
　　int setrlimit(int resource, const struct rlimit *rlp);
  我们能够通过函数getrlimit()、setrlimit()分别获得、设置每个进程能够创建的各种系统资源的限制使用量
  资源限制是一对值：一个指定了当前（软）限制，另一个则代表一个最大（硬）限制。软限制能够被一个进程改变，
  只要保证它不大于硬限制。一个进程能够（不能够撤回的）降低它的硬件限制，前提是大于等于软限制。仅当一个进程工作在一个系统超级用户权限下时能够提高它的硬件限制
  
		  名称					意义
	RLIMIT_AS			进程总共可用的内存大小的最大值
	RLIMIT_CORE			core文件的最大尺寸，如果为0说明不能创建core文件
	RLIMIT_CPU			CPU时间的最大值（单位：秒）
	RLIMIT_DATA			数据段大小的最大值
	RLIMIT_FSIZE		创建文件的大小的最大值
	RLIMIT_LOCKS		进程可建立的文件锁的数量的最大值
	RLIMIT_MEMLOCK		进程中使用mlock锁定内存的最大尺寸
	RLIMIT_NOFILE		进程中文件的打开数量的最大值
	RLIMIT_NPROC		每个real user id的子进程数量的最大值
	RLIMIT_RSS			最大常驻存储区大小
	RLIMIT_SBSIZE		socket缓冲的大小的最大值
	RLIMIT_STACK		栈的最大尺寸
	RLIMIT_VMEM			=RLIMIT_AS

57 long sysconf(int name); 获取一些系统的参数
    printf("Size of a page in bytes:%ld\n",sysconf(_SC_PAGESIZE));                        //4096                    
	printf("Max length of a  hostname:%ld\n",sysconf(_SC_HOST_NAME_MAX));                 //64
	printf(" The maximum number of files that a process can have open at any time.:%ld\n",sysconf(_SC_OPEN_MAX));         //1024
	printf("  The  number  of  clock  ticks  per  second.:%ld\n",sysconf(_SC_CLK_TCK));                      //100
	printf("The number of processors currently online .:%ld\n",sysconf(_SC_NPROCESSORS_ONLN));               //1
	printf("The number of processors configured..:%ld\n",sysconf(_SC_NPROCESSORS_CONF));                     //1
    
	
    printf("配置的处理器数量为 :%ld\n", sysconf(_SC_NPROCESSORS_CONF));                //1
    printf("当前在线(可用)的处理器数量为 :%ld\n"  ", sysconf(_SC_NPROCESSORS_ONLN));       //1
    printf ("页大小: %ld\n", sysconf(_SC_PAGESIZE));                                //4096
    printf ("页数: %ld\n", sysconf(_SC_PHYS_PAGES));                                //248933  
    printf ("可用页面的数量: %ld\n", sysconf(_SC_AVPHYS_PAGES));                      //17336
    printf ("内存大小: %lld MB\n", (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB );  
    printf ("最大打开的文件数: %ld\n", sysconf(_SC_OPEN_MAX));                        //1024
    printf("每秒的节拍数: %ld\n", sysconf(_SC_CLK_TCK));                             //100
    printf ("主机名的最大长度: %ld\n", sysconf(_SC_HOST_NAME_MAX));                   //64
    printf ("登录名的最大长度: %ld\n", sysconf(_SC_LOGIN_NAME_MAX));                  //256

    具体还是要看man page里的东西

58  std::atomic

59 int clock_gettime(clockid_t clk_id, struct timespec* tp);
    clk_id : 检索和设置的clk_id指定的时钟时间。
   CLOCK_REALTIME     				 :系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,
                       					中间时刻如果系统时间被用户改成其他,则对应的时间相应改变  // second:: 1600324428, nsec:298077879
　　CLOCK_MONOTONIC                 	:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响    // second:: 184002, nsec:195857000002,
　　CLOCK_PROCESS_CPUTIME_ID			:本进程到当前代码系统CPU花费的时间
　　CLOCK_THREAD_CPUTIME_ID			:本线程到当前代码系统CPU花费的时间
  
    struct timespec
 {
        time_t tv_sec; /* 秒*/
        long tv_nsec; /* 纳秒*/
 };
 
 60 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, 
                               const struct timespec *restrict abstime)
							 
							 
							 
 61 int pthread_cond_wait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex)
    3、wait：当前线程调用wait()后将被阻塞，直到另外某个线程调用notify_*唤醒当前线程；
	当线程被阻塞时，该函数会自动调用std::mutex的unlock()释放锁，使得其它被阻塞在锁竞争上的线程得以继续执行。
	一旦当前线程获得通知(notify，通常是另外某个线程调用notify_*唤醒了当前线程)，wait()函数也是自动调用std::mutex的lock()。wait分为无条件被阻塞和带条件的被阻塞两种
		   
62  void assert( int expression );
   assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行  
   // fp = fopen( "noexitfile.txt", "r" )   assert( fp ); 出错的话，打印 Assertion  fp  failed  
   已放弃使用assert()的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。应该在debug模式下使用。
   
63 int prctl ( int option,unsigned long arg2,unsigned long arg3,unsigned long arg4,unsigned long arg5 )
   这个系统调用指令是为进程制定而设计的，明确的选择取决于option:
   PR_GET_PDEATHSIG :返回处理器信号；
   PR_SET_NAME :把参数arg2作为调用进程的经常名字。（SinceLinux 2.6.11） 
   备注：prctl(PR_SET_NAME, childname[i], NULL, NULL, NULL); 设置进程名字；  prctl(PR_SET_NAME, "THREAD1");设置线程名字
   
64 swap()
  1. swap的函数原型：
  template <class T> void swap ( T& a, T& b )  
    {  
      T c(a); a=b; b=c;  
    }
	
  2.  vect中swap成员函数实现源码：
void swap(vector<_Tp, _Alloc>& __x) {  
    __STD::swap(_M_start, __x._M_start);  
    __STD::swap(_M_finish, __x._M_finish);  
    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);  
  } 
　　仅仅是交换了指向的首尾指针和容量指针
  
  
65. ssize_t pread(int fd, void *buf, size_t count, off_t offset);
    ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
	pread简单来说就是在指定偏移offset位置开始读取count个字节，同理可推 pwrite 。;
	pread函数相当于先后调用了lseek和read函数，但是还是有区别的，有以下两点区别：1. pread函数是原子操作，而先后调用两个函数不是原子操作;2. pread函数是不会改变当前文件偏移量的，而read和wr
	
66. char* getenv( const char* env_var );
    于宿主环境（操作系统）提供的环境列表搜索匹配 env_var 所指向的 C 字符串，并返回指向与匹配的列表成员关联的 C 字符串的指针。
	
	如果想要环境变量永久生效可以修改下面两个文件中的任何一个：
    1 /etc/profile
	2 .bash_profile
  其中，/etc/profile是全局的环境变量，对所有用户生效，而.bash_profile只对当前用户启作用。
  设置完毕，注销并重新登录，设置就生效了。
  注意：export设置只对当前的bash登录session有效。这是存在内存里面的
	
	
	
	
67    int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen);
      int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);
	  
	  sock：将要被设置或者获取选项的套接字。
	  level：选项所在的协议层。
	  optname：需要访问的选项名。
	  optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。
	  optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度

68 ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
   ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
   只需一次系统调用就可以实现在文件和进程的多个缓冲区之间传送数据，免除了多次系统调用或复制数据的开销  //https://blog.csdn.net/weixin_36750623/article/details/84579243
   
69 int close(int fd);
   内核中，打开的文件会被维护一个引用计数，每次close()会把文件的引用计数减一，引用计数减少到0的文件才会从内核中释放资源

70 int shutdown(intsockfd,inthowto)
   调用close()是关闭TCP连接的正常方式，但这种方式存在两个限制，而这正是引入shutdown()的原因：
       1）close()其实只是将socket fd的引用计数减1，只有当该socket fd的引用计数减至0时，TCP传输层才会发起4次握手从而真正关闭连接。
	      而shutdown则可以直接发起关闭连接所需的4次握手，而不用受到引用计数的限制；
       2）close()会终止TCP的双工链路。由于TCP连接的全双工特性，可能会存在这样的应用场景：local peer不会再向remote peer发送数据，
	      而remote peer可能还有数据需要发送过来，在这种情况下，如果local peer想要通知remote peer自己不会再发送数据但还会继续收数据这个事实，
		  用close()是不行的，而shutdown()可以完成这个任务
		  
   SHUT_RD   ： 关闭读这一半，此时用户不能再从这个套接字读数据，这个套接口接收到的数据都会被丢弃，对等方不知道这个过程。
                关闭连接的读端。也就是该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被丢弃。进程将不能对该套接字发出任何读操作。
			    对TCP套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。
   SHUT_WR   ： 相应地关闭写这一半，此时用户不能再向套接字中写数据，内核会把缓存中的数据发送出去，接着不会再发送数据，对等端将会知道这一点。
                当对等端试图去读的时候，可能会发生错误。
   SHUT_RDWR ： 关闭读与写两半，此时用户不能从套接字中读或写。它相当于再次调用shutdown函数，并且一次指定SHUT_RD，一次指定SHUT_WR。
   
   a.  如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。
   b.  在多进程中如果一个进程中shutdown(sfd,SHUT_RDWR)后其它的进程将无法进行通信. 如果一个进程close(sfd)将不会影响到其它进程.
   
   
71      (无符号)64字节主机转网络：htobe64(uint64_t data)
        (无符号)64字节网络转主机：be64toh(uint64_t data)
        (无符号)32字节主机转网络：htobe32(uint32_t data)
        (无符号)32字节网络转主机：be32toh(uint32_t data)
        (无符号)16字节主机转网络：htobe16(uint16_t data)
        (无符号)16字节网络转主机：be16toh(uint16_t data)

72   int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1
 
73   const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
        返回值：若成功则为指向结构的指针，若出错则为NULL
		
74 int getsockname(int sockfd, struct sockaddr *localaddr,socklen_t *addrlen); //getsockname函数用于获取与某个套接字关联的本地协议地址
   getsockname可以获得一个与socket相关的地址。
   服务器端可以通过它得到相关客户端地址。
   而客户端也可以得到当前已连接成功的socket的ip和端口。
   对于TCP连接的情况，如果不进行bind指定IP和端口，那么调用connect连接成功后，
   使用getsockname可以正确获得当前正在通信的socket的IP和端口地址。
   而对于UDP的情况，无论是在调用sendto之后还是收到服务器返回的信息之后调用，
   都无法得到正确的ip地址：使用getsockname得到ip为0，端口正确
   
75 getsockname函数用于获取与某个套接字关联的本地协议地址
   getpeername函数用于获取与某个套接字关联的外地协议地址
   int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen); // sockfd 是accept 返回的套接字 服务端可以绑定多个ip ,如多个网卡
 
   int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); // sockfd 是accept 返回的套接字

76 struct hostent *gethostbyname(const char *name); 
   这个函数的传入值是域名或者主机名，例如"www.google.com","wpc"等等。
  传出值，是一个hostent的结构（如下）。如果函数调用失败，将返回NULL。
  struct hostent {
     char *h_name;
     char **h_aliases;
     int h_addrtype;
     int h_length;
     char **h_addr_list;
};

解释一下这个结构, 其中:
char *h_name 表示的是主机的规范名。例如www.google.com的规范名其实是www.l.google.com。
char **h_aliases 表示的是主机的别名。www.google.com就是google他自己的别名。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。
int h_addrtype 表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是ipv6(AF_INET6)
int h_length 表示的是主机ip地址的长度
int **h_addr_lisst 表示的是主机的ip地址，注意，这个是以网络字节序存储的。千万不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，
需要调用inet_ntop()。


77 int gethostbyname_r(const char *name, struct hostent *ret, char *buf, size_t buflen, struct hostent **result, int *h_errnop);
   在网络开发中 经常出现需要从主机名得到ip地址的情况 这时就使用gethostbyname
   但是因为gethostbyname返回的是一个指向静态变量的指针 不可重入
   很可能刚要读时值就被其它线程修改
   所以 新的posix中增加了另一个可重入的从主机名(域名)得到DNS的孙数 gethostbyname_r


78 int gettimeofday(struct  timeval*tv,struct  timezone *tz ) //使用gettimeofday获得的值是Unix time。Unix time是以UTC 1970年1月1号00:00:00为基准时间。服务器一般都是以这个时间为基准
  
  struct  timeval{
       long  tv_sec;/*秒*/
       long  tv_usec;/*微妙*/
   }；
   
79  int eventfd(unsigned int initval, int flags); 
    eventfd是Linux 2.6提供的一种系统调用，它可以用来实现事件通知
	eventfd() 创建一个 eventfd 对象，可以由用户空间应用程序实现事件等待/通知机制，或由内核通知用户空间应用程序事件。
    该对象包含了由内核维护的无符号64位整数计数器 count 。使用参数 initval 初始化此计数器
	
	flags 可以是以下值的 OR 运算结果，用以改变 eventfd 的行为。

	EFD_CLOEXEC (since Linux 2.6.27)	文件被设置成 O_CLOEXEC，创建子进程 (fork) 时不继承父进程的文件描述符。
    EFD_NONBLOCK (since Linux 2.6.27)	文件被设置成 O_NONBLOCK，执行 read / write 操作时，不会阻塞。
	EFD_SEMAPHORE (since Linux 2.6.30)	提供类似信号量语义的 read 操作，简单说就是计数值 count 递减 1
	
	读:
	1.read函数会从eventfd对应的64位计数器中读取一个8字节的整型变量；
    2.read函数设置的接收buf的大小不能低于8个字节，否则read函数会出错，errno为EINVAL;
    3.read函数返回的值是按小端字节序的；
    4.如果eventfd设置了EFD_SEMAPHORE，那么每次read就会返回1，并且让eventfd对应的计数器减一；
	  如果eventfd没有设置EFD_SEMAPHORE，那么每次read就会直接返回计数器中的数值，read之后计数器就会置0。
	  不管是哪一种，当计数器为0时，如果继续read，那么read就会阻塞（如果eventfd没有设置EFD_NONBLOCK）或者返回EAGAIN错误（如果eventfd设置了EFD_NONBLOCK)
 
    写: 1.在没有设置EFD_SEMAPHORE的情况下，write函数会将发送buf中的数据写入到eventfd对应的计数器中，最大只能写入0xffffffffffffffff，否则返回EINVAL错误；
        2.在设置了EFD_SEMAPHORE的情况下，write函数相当于是向计数器中进行“添加”，比如说计数器中的值原本是2，如果write了一个3，那么计数器中的值就变成了5。
	  如果某一次write后，计数器中的值超过了0xfffffffffffffffe（64位最大值-1），
	  那么write就会阻塞直到另一个进程/线程从eventfd中进行了read（如果write没有设置EFD_NONBLOCK），或者返回EAGAIN错误（如果write设置了EFD_NONBLOCK）。
	  
80  int epoll_create1(int flags);
    如果flags为0，epoll_create1（）和删除了过时size参数的epoll_create（）相同。
    如果flags中包含以下值就有不同的表现：
    EPOLL_CLOEXEC
    在文件描述符上面设置执行时关闭（FD_CLOEXEC）标志描述符
	
	需要对epoll_create的create作一个说明，这里的1024并非是epoll只能监听1024个fd，而是初始分配的内存大小为1024，当要epoll实例监听的fd超过1024以后，
	会重新分配内存以容纳更多的fd。新版本的linux中，epoll已经在内核中，自己管理初始的fd列表大小，这个值已经没有意义，但是仍然必须填>0的值，
	目的是兼容老版本的操作系统内核
    默认情况下，epoll采用 LT模式工作，这时可以处理阻塞和非阻塞套接字，而上表中的 EPOLLET表示可以将一个事件改为 ET模式。ET模式的效率要比 LT模式高，它只支持非阻塞套接字
	
81 vector初始化
(1): vector<int> ilist1;
    默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。
(2): vector<int> ilist2(ilist);
vector<int> ilist2  = ilist; 
两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素
(3): vector<int> ilist = {1,2,3.0,4,5,6,7};
 vector<int> ilist {1,2,3.0,4,5,6,7};
ilist 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。
(4): vector<int> ilist3(ilist.begin()+2,ilist.end()-1);

ilist3初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容，在本例中ilist3被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，
因此迭代器来自不同的容器是可能的，例如，用一个double的list的范围来初始化ilist3是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并没有区别。
这种初始化方法特别适合于获取一个序列的子序列。
(5): vector<int> ilist4(7);
默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。
(6):vector<int> ilist5(7,3);
指定值初始化，ilist5被初始化为包含7个值为3的int


82  int epoll_ctl(int epfd, intop, int fd, struct epoll_event*event); 

   epoll的事件注册函数，
   第一个参数是epoll_create()的返回值，
   第二个参数表示动作，用三个宏来表示：
   EPOLL_CTL_ADD：       注册新的fd到epfd中；
   EPOLL_CTL_MOD：      修改已经注册的fd的监听事件；
   EPOLL_CTL_DEL：        从epfd中删除一个fd；
   第三个参数是需要监听的fd，
   第四个参数是告诉内核需要监听什么事件，structepoll_event结构如下：
   
   EPOLLOUT事件只有在连接时触发一次，表示可写，其他时候想要触发，那你要先准备好下面条件：
   1.某次write，写满了发送缓冲区，返回错误码为EAGAIN。
   2.对端读取了一些数据，又重新可写了，此时会触发EPOLLOUT
   简单地说：EPOLLOUT事件只有在不可写到可写的转变时刻，才会触发一次，所以叫边缘触发，这叫法没错的
   
   EPOLLIN事件则只有当对端有数据写入时才会触发，所以触发一次后需要不断读取所有数据直到读完EAGAIN为止。
   否则剩下的数据只有在下次对端有写入时才能一起取出来了
   
   EAGAIN，提示你的应用程序现在没有数据可读请稍后再试
   
   EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
   EPOLLOUT：表示对应的文件描述符可以写；
   EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
   EPOLLERR：表示对应的文件描述符发生错误；
   EPOLLHUP：表示对应的文件描述符被挂断； 表示读写都关闭;
   EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
   EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
   
   
   
   
 
 83 std::map 
   1.  void erase (iterator position);
   2.  size_type erase (const key_type& k);
   3.  void erase (iterator first, iterator last);

 for(ITER iter=mapTest.begin();iter!=mapTest.end();)
{
cout<<iter->first<<":"<<iter->second<<endl;
mapTest.erase(iter++);
}
 
 84 int pthread_setspecific(pthread_key_t key, const void *value);
   void *pthread_getspecific(pthread_key_t key);
   int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
   下面说一下线程中特有的线程存储， Thread Specific Data 。线程存储有什么用了？他是什么意思了？大家都知道，
   在多线程程序中，所有线程共享程序中的变量。
   现在有一全局变量，所有线程都可以使用它，改变它的值。而如果每个线程希望能单独拥有它，那么就需要使用线程存储了。
   表面上看起来这是一个全局变量，所有线程都可以使用它，而它的值在每一个线程中又是单独存储的。这就是线程存储的意义
   
1  创建一个类型为pthread_key_t类型的变量。
2  调用 pthread_key_create(pthread_key_t *key, void (*destructor)(void*))来创建该变量。
   该函数有两个参数，第一个参数就是上面声明的pthread_key_t变量，第二个参数是一个清理函数，
   用来在线程释放该线程存储的时候被调用。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。
   该函数成功返回0.其他任何返回值都表示出现了错误。
   
   pthread_key_create 只需要调用一次 表面上key看起来这是一个全局变量，所有线程都可以使用它，
   而它的值在每一个线程中又是单独存储的
   
3  当线程中需要存储特殊值的时候，可以调用 pthread_setspecific() 。该函数有两个参数，第一个为前面声明的pthread_key_t变量，
    第二个为void*变量，这样你可以存储任何类型的值。
4   如果需要取出所存储的值，调用pthread_getspecific()。该函数的参数为前面提到的pthread_key_t变量，该函数返回void *类型的值。下面是前面提到的函数的原型：

85 int pthread_key_delete(pthread_key_t key);用来删除一个键，删除后，键所占用的内存将被释放。注销一个TSD，这个函数并不检查当前是否有线程正使用该TSD，
   也不会调用清理函数（destr_function），而只是将TSD释放以供下一次调用pthread_key_create()使用。需要注意的是，键占用的内存被释放。与该键关联的线程数据所占用的内存并不被释放。
   因此，线程数据的释放，必须在释放键之前完成
   
86 儒略历日数
     科普小知识：天文学把24小时算作一个周期，起始和结束都是正午，这种整周期数就是儒略历日数。儒略历日的0是很久很久以前。一个方便的参考点事儒略历日244000起始于1968年5月23日。
     如果知道历书中某天正午起始的儒略历日数，那么将其加1再对7求模，就可以知道该天是星期几。结果是0对应星期天，1对应星期一，由此类推
	 
87 gcc 原子操作 这些函数不需要头文件
  n++类 
type __sync_fetch_and_add(type *ptr, type value, ...); // m+n
type __sync_fetch_and_sub(type *ptr, type value, ...); // m-n
type __sync_fetch_and_or(type *ptr, type value, ...);  // m|n
type __sync_fetch_and_and(type *ptr, type value, ...); // m&n
type __sync_fetch_and_xor(type *ptr, type value, ...); // m^n
type __sync_fetch_and_nand(type *ptr, type value, ...); // (~m)&n
/* 对应的伪代码 */
{ tmp = *ptr; *ptr op= value; return tmp; }  //op 类似于 + - 
{ tmp = *ptr; *ptr = (~tmp) & value; return tmp; }   // nand

++n类
type __sync_add_and_fetch(type *ptr, type value, ...); // m+n
type __sync_sub_and_fetch(type *ptr, type value, ...); // m-n
type __sync_or_and_fetch(type *ptr, type value, ...); // m|n
type __sync_and_and_fetch(type *ptr, type value, ...); // m&n
type __sync_xor_and_fetch(type *ptr, type value, ...); // m^n
type __sync_nand_and_fetch(type *ptr, type value, ...); // (~m)&n
/* 对应的伪代码 */
{ *ptr op= value; return *ptr; }
{ *ptr = (~*ptr) & value; return *ptr; } // nand

4.CAS类  compare and swap    CAS，就是不使用系统提供的锁，而是直接利用cpu提供的指令，实现互斥操
  
 bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...);
type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...);
/* 对应的伪代码 */
{ if (*ptr == oldval) { *ptr = newval; return true; } else { return false; } }
{ tmp = *ptr; if (*ptr == oldval) { *ptr = newval; } return tmp; } 
	
	
88 int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；
本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。

89 int atexit (void (*)(void))）atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数
	⼀个进程可以登记若⼲个（具体⾃⼰验证⼀下）个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理函数， 
	atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反（网上很多说造成顺序相反的原因是参数压栈造成的，
	参数的压栈是先进后出，和函数的栈帧相同），如果⼀个函数被多次登记，也会被多次调⽤

90 void std::vector::resize (size_type n);
   void std::vector::resize (size_type n, const value_type& val);
   如果n比当前的vector元素数目要小，vector的容量要缩减到resize的第一个参数大小，既n。并移除那些超出n的元素同时销毁他们。
   比当前vector元素数目要大，在vector的末尾扩展需要的元素数目，如果第二个参数val指定了，扩展的新元素初始化为val的副本，
   类型默认初始化

91 void std::vector::reserve (size_type n);
   reserve表示容器预留空间,实际申请的内存不小于n
  
92 std::search() 
   ForwardIterator search (ForwardIterator first1, ForwardIterator last1,
   ForwardIterator first2, ForwardIterator last2);
   search() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last1 迭代器相同

93 std::find_end()

94  函数原型：extern int memcmp(void *str1, void *str2, unsigned int n)
    参数说明：str1和str2为指定作比较的字符串，比较两个字符串的前n个字节。
    memcmp函数实现的是字节的比较，而不是字符的比较。

95 函数原型：extern int memicmp(void *str1, void *str2, unsigned int count)
   *参数说明：str1和str2为指定作比较的字符串，比较两个字符串的前count个字节，不区分大小写。

96 函数原型extern void *memchr(const void *buf, int ch, size_t count)
   功能：从buf所指内存区域的前count个字节查找字符ch。
   说明：当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回NULL。

97 std::copy 
  std::copy(start, end, std::back_inserter(container));  
  这里，start和end是输入序列（假设有N个元素）的迭代器（iterator），container是一个容器，该容器的接口包含函数push_back。
  假设container开始是空的，那么copy完毕后它就包含N个元素，并且顺序与原来队列中的元素顺序一样。标准库提供的back_inserter模板函数很方便，
  因为它为container返回一个back_insert_iterator迭代器，这样，复制的元素都被追加到container的末尾了

98 uLong ZEXPORT adler32 (uLong adler, const Bytef *buf, uInt len)

99 void *memset (void *__s, int __c, size_t __n)

100  timerfd是Linux为用户程序提供的一个定时器接口。这个接口基于文件描述符，通过文件描述符的可读事件进行超时通知，所以能够被用于select/poll的应用场景
     编译时加编译选项 -lrt      ???
     timerfd是每个进程唯一的吗  ???

	 int timerfd_create(int clockid, int flags); 
		timerfd_create（）函数创建一个定时器对象，同时返回一个与之关联的文件描述符。
		clockid：clockid标识指定的时钟计数器，可选值（CLOCK_REALTIME、CLOCK_MONOTONIC。。。）
		CLOCK_REALTIME:系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户改成其他,则对应的时间相应改变
		CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响
		flags：参数flags（TFD_NONBLOCK(非阻塞模式)/TFD_CLOEXEC（表示当程序执行exec函数时本fd将被系统自动关闭,表示不传递）	
        
        O_CLOEXEC : 在进程执行exec系统调用时关闭此打开的文件描述符。防止父进程泄露打开的文件给子进程，即便子进程没有相应权限 
		
	 
     int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);
        
        struct itimerspec {
            struct timespec it_interval;
            struct timespec it_value;
        };
        
	 	struct timespec {
      		time_t tv_sec;                /* Seconds */
      		long   tv_nsec;               /* Nanoseconds */
  		};
	 timerfd_settime()此函数用于设置新的超时时间，并开始计时,能够启动和停止定时器;
     fd: 参数fd是timerfd_create函数返回的文件句柄
     flags：参数flags为1代表设置的是绝对时间（TFD_TIMER_ABSTIME 表示绝对定时器）；为0代表相对时间。
     new_value: 参数new_value指定定时器的超时时间以及超时间隔时间
     old_value: 如果old_value不为NULL, old_vlaue返回之前定时器设置的超时时间，具体参考timerfd_gettime()函数
     it_interval不为0则表示是周期性定时器。
     it_value和it_interval都为0表示停止定时器
		
     timerfd_settime：能够启动和停止定时器；可以设置第二个参数：flags，0表示是相对定时器，TFD_TIMER_ABSTIME表示是绝对定时器。
     第三个参数设置超时时间，如果为0则表示停止定时器。定时器设置超时方法：
     设置超时时间是需要调用clock_gettime获取当前时间，如果是绝对定时器，那么需要获取CLOCK_REALTIME，在加上要超时的时间。
     如果是相对定时器，要获取CLOCK_MONOTONIC时间
		
  
  		struct itimerspec {
     		struct timespec it_interval;  /* Interval for periodic timer （定时间隔周期）*/
     		struct timespec it_value;     /* Initial expiration (第一次超时时间)*/
 		};
	 
     int timerfd_gettime(int fd, struct itimerspec *curr_value);
	 
	 timerfd_gettime()函数获取距离下次超时剩余的时间
      curr_value.it_value 字段表示距离下次超时的时间，如果改值为0，表示计时器已经解除
      改字段表示的值永远是一个相对值，无论TFD_TIMER_ABSTIME是否被设置
      curr_value.it_interval 定时器间隔时间
	  
	  read函数可以读timerfd，读的内容为uint_64，表示超时次数
	
timefd_*系列函数优点:
 1. 这一组函数不涉及到信号，安全好用
 2. 这一组函数通过操作时间相关的文件描述符实现功能，可以和其它的文件相关操作融为一体
 3. timerf_create(2)函数把时间变成了一个描述符，该文件描述符在定时器超时的那一刻变得可读，这样就方便融入select(2)或poll(2)中去
	 
	 
101   int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
     pthread_atfork()在fork()之前调用，当调用fork时，内部创建子进程前在父进程中会调用prepare，内部创建子进程成功后，父进程会调用parent ，子进程会调用child
	 
	 
102 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    timeout时间内监听到事件，会立即返回。 当timeout为-1是，epoll_wait调用将永远阻塞，直到某个时间发生。当timeout为0时，epoll_wait调用将立即返回.
	epoll_create()、
	epoll_ctl()、
	epoll_wait()、
	close()
	
    POLLIN: 		有数据可读。
	POLLRDNORM: 	有普通数据可读。
	POLLRDBAND:     有优先数据可读。
	POLLPRI:		有紧迫数据可读。
	POLLOUT:		写数据不会导致阻塞。
	POLLWRNORM:		写普通数据不会导致阻塞。
	POLLWRBAND:		写优先数据不会导致阻塞。
	//POLLMSG:	SIGPOLL 消息可用。

	此外，revents域中还可能返回下列事件：
	POLLER:		指定的文件描述符发生错误。
	POLLHUP:	指定的文件描述符挂起事件。
	POLLNVAL:	指定的文件描述符非法。
	
103 	#include <arpe/inet.h>
   这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。
   地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值
   
   int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1
 
   const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
   
104 size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);  strftime是一种计算机函数，根据区域设置格式化本地时间/日期，函数的功能：将时间格式化！！！，或者说格式化一个时间字符串

105 struct tm *localtime_r(const time_t *timep, struct tm *result); // 根据timep 返回本地时区时间信息
    struct tm *gmtime_r(const time_t *timep, struct tm *result); // 根据timep 返回utc时区时间信息
	
	
106  读写锁 
初始化一个读写锁pthread_rwlock_init
读锁定读写锁      pthread_rwlock_rdlock
非阻塞读锁定　　pthread_rwlock_tryrdlock
写锁定读写锁      pthread_rwlock_wrlock
非阻塞写锁定      pthread_rwlock_trywrlock
解锁读写锁         pthread_rwlock_unlock
释放读写锁         pthread_rwlock_destroy

107 获取或设定资源使用限制
	int getrlimit(int resource, struct rlimit *rlim);
	int setrlimit(int resource, const struct rlimit *rlim);
	
resource：可能的选择有
RLIMIT_AS //进程的最大虚内存空间，字节为单位。
RLIMIT_CORE //内核转存文件的最大长度。
RLIMIT_CPU //最大允许的CPU使用时间，秒为单位

struct rlimit {
　　rlim_t rlim_cur;　　//soft limit
　　rlim_t rlim_max;　　//hard limit
};

108  char * basename(char *path)  截取path中的去目录部分的最后的文件或路径名  失败： 返回 NULL
     char *dirname(char *path);  返回截取path中的目录路径指针   失败： 返回 NULL

    path         dirname    basename
    "/usr/lib"    "/usr"    "lib"
    "/usr/"       "/"       "usr"
    "usr"         "."       "usr"
    "/"           "/"       "/"
    "."           "."       "."
    ".."          "."       ".."
	
109 std::mt19937_64  C++11生成32位/64位随机数

110 int getopt(int argc,char * const argv[ ],const char * optstring);

111 #define	EXIT_FAILURE	1	/* Failing exit status.  */
    #define	EXIT_SUCCESS	0
	
112 int chdir（const char * path）;  函数说明：chdir（）用户将当前的工作目录改变成以参数路径所指的目录。

113 char * getcwd(char * buf, size_t size);  getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。

114 int dup(int oldfd);                复制一个已经存在的文件描述符，如果成功，返回复制成功后的文件描述符，失败返回-1
    
	int dup2(int fd, int fd2);    复制一个文件描述符，fd表示已经存在的打开的文件描述符，fd2是指定新的文件描述符，如果fd2等于fd，则直接返回，如果fd2存在并且打开，
	                                   则先close(fd2)后，重新打开，这样fd2和fd就指向了同一个文件（共享打开的文件），如果fd2不存在或者没有打开，
									   则打开fd2，并且指向fd所指向的文件。函数的返回值和fd2一致。该函数可以实现文件的重定位
								
115  pid_t setsid(void); 
	当进程是会话组长时setsid()调用失败。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。
	由于会话过程对控制终端的独占性，进程同时与控制终端脱离

  在Linux系统下，每一个进程都有惟一的一个定时器，该定时器提供了以秒为单位的定时功能。在定时器设置的超时时间到达后，调用alarm的进程将收到SIGALRM信号
  unsigned int alarm(unsigned int seconds);
參数说明：
1）seconds：要设定的定时时间，以秒为单位。在alarm调用成功后開始计时。超过该时间将触发SIGALRM信号。
返回值：
返回当前进程曾经设置的定时器剩余秒数
  
  
116 int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
    struct itimerval 
{
	/* Interval for periodic timer */
	struct timeval it_interval;
	/* Time until next expiration */ 
	struct timeval it_value;    
};
struct timeval 
{
	time_t      tv_sec;         /* seconds */
	suseconds_t tv_usec;        /* microseconds 1/1000000 seconds */
};

  new_value： 参数用来对计时器进行设置，it_interval为计时间隔，it_value为延时时长，下面例子中表示的是在setitimer方法调用成功后，延时it_value后触发一次SIGALRM信号，以后每隔it_interval触发一次SIGALRM信号。
  settimer工作机制是，先对it_value倒计时，当it_value为零时触发信号，然后重置为it_interval，继续对it_value倒计时，一直这样循环下去
  
117 shared_from_this()
    c++11中的shared_from_this()来源于boost中的enable_shared_form_this类和shared_from_this()函数，功能为返回一个当前类的std::share_ptr,使用方法如下


118 C++11的chrono库

119 bool __sync_bool_compare_and_swap (type*ptr, type oldval, type newval, ...)
    type __sync_val_compare_and_swap (type *ptr, type oldval,  type newval, ...)
    这两个函数提供原子的比较和交换，如果*ptr == oldval,就将newval写入*ptr,
    第一个函数在相等并写入的情况下返回true.
    第二个函数在返回操作之前的值。

120 type __sync_lock_test_and_set (type *ptr, type value, ...)
    将*ptr设为value并返回*ptr操作之前的值。

121 void __sync_lock_release (type *ptr, ...)
    将*ptr置0
	
	
121  __sync_synchronize()  内存屏障
    内存屏障是一个程序员要面对的涉及CPU方面知识的一个问题。在多核多线程的情况下，如果你不知道这个CPU乱序执行这个问题的话，将会是一场噩梦，
	无论怎么进行代码走读也不可能发现的bug。不过只要加上一个__sync_synchronize()  问题就迎刃而解

	
122  int sscanf (const char *str,const char * format,........);
     sscanf()会将参数str的字符串根据参数format字符串来转换并格式化数据
	  返回值 成功则返回参数数目，失败则返回-1，错误原因存于errno中。 返回0表示失败    否则，表示正确格式化数据的个数    
	  例如：sscanf(str，"%d%d%s", &i,&i2, &s);    如果三个变成都读入成功会返回3。    如果只读入了第一个整数到i则会返回1。
	 
	 char str[100]; sscanf("12345","%4s",str); printf("%s\n",str); 输出"1234"
	char str[100];  sscanf("12345","%s",str);  printf("%s\n",str);  输出12345
	char str1[100], str2[100], str3[100]; gets(str1); sscanf(str1,"%s%s",str2,str3); printf("%s %s\n",str2,str3); 输入"hello world hello" 输出"hello world"
	
123 信号集处理函数
int sigemptyset(sigset_t *set);  //清空set信号集中的所有信号
int sigfillset(sigset_t *set);  //将所有的信号赋给set信号集
int sigaddset(sigset_t *set, int signo);  //将signo信号加入到set信号集中
int sigdelset(sigset_t *set, int signo);  //将set信号集中的signo信号移除
//这4和函数的返回值：成功返回0;出错返回-1

int sigismember(const sigset_t *set, int signo);  //判断signo信号是否在set信号集中
	
124 int sigaction(int signum,const struct sigaction *act ,struct sigaction *oldact) 
        sigaction函数用来查询和设置信号处理方式，它是用来替换早期的signal函数
            signum     可以指定SIGKILL和SIGSTOP以外的所有信号
            signum参数指出要捕获的信号类型，act参数指定新的信号处理方式，oldact参数输出先前信号的处理方式（如果不为NULL的话）
struct sigaction
{
void (*sa_handler) (int);
void  (*sa_sigaction)(int, siginfo_t *, void *);
sigset_t sa_mask;
int sa_flags;
void (*sa_restorer) (void);
}
sa_handler：此参数和signal()的参数handler相同，此参数主要用来对信号旧的安装函数signal()处理形式的支持  SIG_IGN 忽略信号
sa_sigaction：新的信号安装机制，处理函数被调用的时候，不但可以得到信号编号，而且可以获悉被调用的原因以及产生问题的上下文的相关信息。
sa_mask：用来设置在处理该信号时暂时将sa_mask指定的信号搁置
sa_restorer： 此参数没有使用
sa_flags：用来设置信号处理的其他相关操作，下列的数值可用。可用OR 运算（|）组合
A_NOCLDSTOP:如果参数signum为SIGCHLD，则当子进程暂停时并不会通知父进程
SA_ONESHOT/SA_RESETHAND:当调用新的信号处理函数前，将此信号处理方式改为系统预设的方式
SA_RESTART:被信号中断的系统调用会自行重启  //http://blog.chinaunix.net/uid-28414100-id-5751154.html  应该是函数还会继续等待执行/执行
 void int_handler (int signum)
  {
          printf ("int handler %d/n",signum);
  }
 
  int main(int argc, char **argv)
  {
          char buf[100];
          ssize_t ret;
          struct sigaction oldact;
          struct sigaction act;
 
          act.sa_handler = int_handler;
          act.sa_flags=0;
          act.sa_flags |= SA_RESTART;
          sigemptyset(&act.sa_mask);
          if (-1 == sigaction(SIGINT,&act,&oldact))
          {
                  printf("sigaction failed!/n");
                  return -1;
          }
 
          bzero(buf,100);
 
          ret = read(STDIN_FILENO,buf,10);
          if (ret == -1)
          {
                  printf ("read error %s/n", strerror(errn    o))
          }
          printf ("read %d bytes, content is %s/n",ret,buf    );
          sleep (10);
          return 0;
  }



^Cint handler 2
^Cint handler 2
^Cint handler 2
^Cint handler 2
^Cint handler 2
^Cint handler 2
hgfd
read 5 bytes, content is hgfd
SA_NOMASK/SA_NODEFER:在处理此信号未结束前不理会此信号的再次到来
SA_SIGINFO：信号处理函数是带有三个参数的sa_sigaction
	
125  int clock_getres(clockid_t clk_id, struct timespec *res); 获取对应时钟类型能够提供的时间精确度 
CLOCK_REALTIME:             系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,
                                   //中间时刻如果系统时间被用户改成其他,则对应的时间相应改变
CLOCK_MONOTONIC:            从系统启动这一刻起开始计时,不受系统时间被用户改变的影响
CLOCK_PROCESS_CPUTIME_ID:   本进程到当前代码系统CPU花费的时间
CLOCK_THREAD_CPUTIME_ID:    本线程到当前代码系统CPU花费的时间

struct timespec { 
    time_t   tv_sec;        /* seconds */
	long     tv_nsec;       /* nanoseconds 纳秒*/
};

126   int pipe(int pipefd[2]);  成功：0；失败：-1，设置errno  //https://blog.csdn.net/qq_42914528/article/details/82023408
      函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w
读管道： 
1. 管道中有数据，read返回实际读到的字节数。
2. 管道中无数据：
(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)
(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)

写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)
2. 管道读端没有全部关闭：
(1) 管道已满，write阻塞。
(2) 管道未满，write将数据写入，并返回实际写入的字节数。

管道容量分为pipi capacity 和 pipe_buf .这两者的区别在于pipe_buf定义的是内核管道缓冲区的大小，
这个值的大小是由内核设定的，这个值仅需一条命令就可以查到； ulimit -a ; sizeof(pipe_buf)= 512 bytes* 8 = 4k byte

而pipe capacity指的是管道的最大值，即容量 通过不断写 可以写入65536 字节

127  int setjmp(jmp_buf jb);
     void longjmp(jmp_buf jb, int r);
  setjmp用于保存当前AR到jb变量中；
  而longjmp用于设置当前AR为jb，并跳转到调用setjmp()；之后的第一个语句处。其结果就相当于回到了setjmp()刚执行完毕，只是偷偷的修改了setjmp的返回值。
  setjmp()第一次调用时总是返回0，而通过longjmp(jb,r)跳转后其返回值总是被修改为r，并且r不能为0。这样程序中就很容易根据setjmp()的返回值来判断是否是longjmp()导致了跳转才执行到此
  
128 int system(const char*command)  std::system("ls -l >test.txt");
   执行shell 命令
   
   
129 void sync(void); 
   在操作系统中，除非设置了自动同步，否则为了减少磁盘的写入量，延长磁盘寿命，写入文件时并不是即时写入到磁盘中，
   而是先写入内存，这段内存区域被称为系统缓冲区。在系统缓冲区数据累计到一定数量后（具体数量因系统实际设置而定），
   会有系统进程一次性写入所有缓冲数据。这样，如果意外断电，那么系统缓冲区内数据就会因此丢失
   
130 int daemon(int nochdir, int noclose); daemon()函数适用于希望从控制终端脱离并作为系统守护进程在后台运行的程序
    如果nochdir为零，daemon()将进程的当前工作目录更改为根目录（“/”）; 否则，当前工作目录保持不变。
    如果noclose为零，daemon()将标准输入，标准输出和标准错误重定向到/dev/null; 否则，不会对这些文件描述符进行更改。(参数为0时有效)
    返回值：
    deamon()调用了fork()，如果fork成功，那么父进程就调用_exit()退出，因此只能通过子进程看到进一步的错误。如果成功函数返回0，否则返回-1并设置errno

131 int access(const char *pathname, int mode); 判断文件权限
    R_OK 只判断是否有读权限
	W_OK 只判断是否有写权限
	X_OK 判断是否有执行权限
	F_OK 只判断是否存在
    
    成功返回0 失败返回-1

132 char *strtok_r(char *str, const char *delim, char **saveptr);
   
   str是传入的字符串。需要注意的是  ：第一次使用strtok_r之后，要把str置为NULL,
   delim指向依据分割的字符串。常见的空格“ ”    逗号“,”等
   saveptr保存剩下待分割的字符串

133  boost::spirit 

134 long int strtol(const char *nptr, char **endptr, int base)             long long int strtoll(const char *nptr, char **endptr, int base);
    strtol()会将nptr指向的字符串，根据参数base，按权转化为long int, 然后返回这个值。
参数base的范围为2~36,和0；它决定了字符串以被转换为整数的权值。
可以被转换的合法字符依据base而定，举例来说，当base为2时，合法字符为‘0’，‘1’；base为8时，合法字符为‘0’，‘1’，……‘7’；
 base为10时，合法字符为‘0’，‘1’，……‘9’；base 为16时，合法字符为‘0’，‘1’，……‘9’，‘a’，……‘f’；base为24时，合法字符为‘0’，……‘9’，‘a’，……‘n’，base为36时，
 合法字符为‘0’，……‘9’，‘a’，……‘z’；等等。其中，不区分大小写，比如，‘A’和‘a’会都会被转化为10。
当字符合法时，‘0’，……‘9’依次被转换为十进制的0～9，‘a’，……‘z’一次北转换为十进制的10～35。
strtol()函数检测到第一个非法字符时，立即停止检测，其后的所有字符都会被当作非法字符处理。合法字符串会被转换为long int, 作为函数的返回值。
非法字符串，即从第一个非法字符的地址，被赋给*endptr。**endptr是个双重指针，即指针的指针。strtol()函数就是通过它改变*endptr的值，即把第一个非法字符的地址传给endptr

135 #include <signal.h> 
int sigemptyset(sigset_t *set);                //清空set信号集中的所有信号 
int sigfillset(sigset_t *set);                 //将所有的信号赋给set信号集
int sigaddset(sigset_t *set, int signo);       //将signo信号加入到set信号集中
int sigdelset(sigset_t *set, int signo);       //将set信号集中的signo信号移除
//这4和函数的返回值：成功返回0;出错返回-1
int sigismember(const sigset_t *set, int signo);  //判断signo信号是否在set信号集中
//返回值：若为真返回1;若为假返回-1
信号集类型
  1.概念：一种类型，能够保存多个信号
  2.类型：sigset_t

136 int kill(pid_t pid, int sig);   用于向任何进程组或进程发送信号 kill(getpid(),sig)
pid：可能选择有以下四种
1. pid大于零时，pid是信号欲送往的进程的标识。
2. pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。
3. pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。
4. pid小于-1时，信号将送往以-pid为组标识的进程。

sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在执行
返回值说明： 成功执行时，返回0。失败返回-1，errno被设为以下的某个值 EINVAL：指定的信号码无效（参数 sig 不合法） 
           EPERM；权限不够无法传送信号给指定进程 ESRCH：参数 pid 所指定的进程或进程组不存在
		 
137 int fscanf(FILE *stream, const char *format, ...);
    fscanf() 返回参数列表中被成功赋值的参数个数

138 int daemon(int nochdir, int noclose);   daemon()函数主要用于希望脱离控制台，以守护进程形式在后台运行的程序
    参数nochdir为0时,即可将工作目录修改为根目录
	当noclose为0是，daemon将进程的STDIN, STDOUT, STDERR都重定向到/dev/null
	如果成功函数返回0，否则返回-1并设置errno
	
139 int flock(int fd,int operation);会依参数operation所指定的方式对参数fd所指的文件做各种锁定或解除锁定的动作。
                                    此函数只能锁定整个文件，无法锁定文件的某一区域
   参数 operation有下列四种情况:
   LOCK_SH 建立共享锁定。多个进程可同时对同一个文件作共享锁定。
   LOCK_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。
   LOCK_UN 解除文件锁定状态。
   LOCK_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。通常与LOCK_SH或LOCK_EX 做OR(|)组合。
   单一文件无法同时建立共享锁定和互斥锁定，而当使用dup()或fork()时文件描述词不会继承此种锁定。
   返回值 返回0表示成功，若有错误则返回-1，错误代码存于errno。

140  首先介绍一个重要的结构体：fd_set，它会作为下面某些函数的参数而多次用到，fd_set可以理解为一个集合，
     这个集合中存放的是文件描述符(file descriptor)，即文件句柄
	 
	 1》FD_ZERO
     用法：FD_ZERO(fd_set*);
     用来清空fd_set集合，即让fd_set集合不再包含任何文件句柄。
     2》FD_SET
     用法：FD_SET(int ,fd_set *);
     用来将一个给定的文件描述符加入集合之中
     3》FD_CLR
     用法：FD_CLR(int ,fd_set*);
     用来将一个给定的文件描述符从集合中删除
     4》FD_ISSET
     用法：FD_ISSET(int ,fd_set*);
     检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真，否则，返回假（也可以认为集合中指定的文件描述符是否可以读写）。

140	 int select(int maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout);
      select()用来等待文件描述词状态的改变。参数n代表最大的文件描述词加1，参数readfds、writefds和exceptfds 称为描述词组，是用来回传该描述词的读，写或例外的状况
      https://blog.csdn.net/hmxz2nn/article/details/79777372
1.   int n:是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！
2.   fd_set*readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，
     如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，
     若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化
3.   writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，
     如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，
     若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化
4.   fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常
5.   timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态，第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，
     一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，
	 文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，
	 否则在超时后不管怎样一定返回，返回值同上述.

6.   返回值: 正值：某些文件可读写或出错     0：等待超时，没有可读写或错误的文件    负值：select错误
     返回值：错误返回-1，超时返回0。当关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。
     
	 FD_ZERO(fd_set* fdset)： 将fd_set变量的所有位初始化为0。
     FD_SET（int fd, fd_set* fdset）：在参数fd_set指向的变量中注册文件描述符fd的信息。
     FD_CLR(int fd, fd_set* fdset)：参数fd_set指向的变量中清除文件描述符fd的信息。
     FD_ISSET(int fd, fd_set* fdset)：若参数fd_set指向的变量中包含文件描述符fd的信息，则返回真。


141  FD_SETSIZE 

通常，操作系统通过宏FD_SETSIZE来声明在一个进程中select所能操作的文件描述符的最大数目。例如：
在4.4BSD的头文件中我们可以看到：
＃ifndef FD_SETSIZE
#define FD_SETSIZE 1024
#endif
在红帽Linux的头文件<bits/types.h>中我们可以看到：
＃define __FD_SETSIZE 1024
以及在头文件<sys/select.h>中我们可以看到：
#include <bits/types.h>
#define FD_SETSIZE __FD_SETSIZE
既定义FD_SETSIZE为1024，一个整数占4个字节，既32位，那么就是用包含32个元素的整数数组来表示文件描述符集

142 unsigned long int strtoul(const char *nptr, char **endptr, int base);           //字符数字转换
    unsigned long long int strtoull(const char *nptr, char **endptr,int base);      //字符数字转换
	
143 int vsnprintf(char* str, size_t size, const char* format, va_list ap);
	str 把生成的格式化的字符串存放在这里.
    size str可接受的最大字节数,防止产生数组越界.
    format 指定输出格式的字符串，它决定了你需要提供的可变参数的类型、个数和顺序。
    ap 可变参数
函数功能：将可变参数格式化输出到一个字符数组。
返回值：执行成功，返回写入到字符数组str中的字符个数（不包含终止符），最大不超过size；执行失败，返回负值，并置errno.[1] 

144  std::setprecision( ) 浮点数位数

145 int usleep(useconds_t usec);    //睡眠 ，单位微秒

146 ssize_t read(int fd,void*buf,size_t count)

fd: 是文件描述符, 从command line获取数据时，为0
buf: 为读出数据的缓冲区；
count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保
存在缓冲区buf中，同时文件的当前读写位置向后移）
返回值:
成功：返回读出的字节数
失败：返回-1，并设置errno，如果在调用read
之前到达文件末尾，则这次read返回0

147 ssize_t write(int fd,const void*buf,size_t count);
参数说明：
fd:是文件描述符（输出到command line，就是1）
buf:通常是一个字符串，需要写入的字符串
count：是每次写入的字节数
返回值:
成功：返回写入的字节数
失败：返回-1并设置errno
ps： 写常规文件时，write的返回值通常等于请求写的字节
数count， 而向终端设备或者网络写时则不一定


读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。
从终端设备读，通常以行为单位，读到换行符就返回了。
从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数，后面socket编程部分会详细讲解

写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定。
读常规文件是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回。从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，
如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。同样，写常规文件是不会阻塞的，
而向终端设备或网络写则不一定。

现在明确一下阻塞（Block）这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行，
直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行（Running）状态，
在Linux内核中，处于运行状态的进程分为两种情况
   1. 正在被调度执行。CPU处于该进程的上下文环境中，程序计数器（eip）里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，
      正在读写该进程的地址空间。
   2. 就绪状态。该进程不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，
      那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，
	  同时要兼顾用户体验，不能让和用户交互的进程响应太慢

如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。以read为例，如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK
（或者EAGAIN，这两个宏定义的值相同），表示本来应该阻塞在这里（would block，虚拟语气），事实上并没有阻塞而是直接返回错误，调用者应该试着再读一次（again）。
这种行为方式称为轮询（Poll），调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备



148

typedef struct ucontext_t
  {
    unsigned long int __ctx(uc_flags);
    struct ucontext_t *uc_link;           //为当前context执行结束之后要执行的下一个context，若uc_link为空，执行完当前context之后退出程序
    stack_t uc_stack;                     //为当前context运行的栈信息
    mcontext_t uc_mcontext;               //保存具体的程序执行上下文，如PC值，堆栈指针以及寄存器值等信息。它的实现依赖于底层，是平台硬件相关的。此实现不透明
    sigset_t uc_sigmask;                  //执行当前上下文过程中需要屏蔽的信号列表，即信号掩码
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;



148  void makecontext(ucontext_t* ucp, void (*func)(), int argc, ...);
     初始化一个ucontext_t,func参数指明了该context的入口函数，argc为入口参数的个数，每个参数的类型必须是int类型。
	 另外在makecontext之前，一般需要显示的初始化栈信息以及信号掩码集同时也需要初始化uc_link，以便程序退出上下文后继续执行
149  int swapcontext(ucontext_t* olducp, ucontext_t* newucp);
     原子操作，该函数的工作是保存当前上下文并将上下文切换到新的上下文运行 , 运行newucp指定的上下文
150  int getcontext(ucontext_t* ucp);
     将当前的执行上下文保存在ucp中，以便后续恢复上下文
151  int setcontext(const ucontext_t* ucp);
     将当前程序切换到新的context,在执行正确的情况下该函数直接切换到新的执行状态，不会返回
 注意:setcontext执行成功不返回，getcontext执行成功返回0，若执行失败都返回-1。若uc_link为NULL,执行完新的上下文之后程序结束。

152  trdiff_t类型变量通常用来保存两个指针减法操作的结果  
     int *a=new int(1);        //0x5602ddc65280
     int *b=new int(2);        //0x5602ddc652a0
     ptrdiff_t result=a-b;     //-8

153  reverse  反转序列   //<algorithm>

154 unordered_set和unordered_map内部实现是基于哈希表(hashtable)

155 迭代器失效    (insert, erase都会导致迭代器失效)  
   (vector deque) erase()返回值都是一个迭代器，该迭代器指向被删除元素后面的元素（这个是重点） map没有返回值
    for(vector<int>::iterator iter = ivec.begin(); iter != ivec.end(); ) {
			if((*iter) %2 == 0){
				iter = ivec.erase(iter);
			} else {
                iter++;
            }
	}

    void deleteValueFromVector(Vec &v, int n = 5) {
        typedef vector<int> Vec;
        typedef vector<int>::iterator VecIt;
        VecIt it;
        for(it = v.begin(); it != v.end(); /*不能再自增了*/) {
            if(0 == *it % n) {
                v.erase(it); // vector元素自动向前挪动了(关联的map容器元素不会自动挪动)， 所以不能再把it进行++了,it 如果是最后一个有效值呢(这样也可以)
            } else {
                it++;
            }
        }
    }

    void deleteValueFromMap(Map &m, int n = 5) {
    typedef map<int, int> Map;
    typedef map<int, int>::iterator MapIt;
    MapIt it;
    for(it = m.begin(); it != m.end(); /*不能再自增了*/) {
        if(0 == it->second % n) {
            m.erase(it++);
        } else {
            it++;
        }
    }

156  int stat(const char *restrict path, struct stat *restrict buf);    //获取文件信息
    返回值：成功返回0，失败返回-1；
    ​参数：文件路径（名），struct stat 类型的结构体

157  key_t ftok(const char *pathname, int proj_id);  //把从pathname导出的信息与id的低序8位组合成一个整数IPC键
    pathname：指定的文件，此文件必须存在且可存取
    proj_id：计划代号（project ID）
    系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值。通常情况下，该id值通过ftok函数得到
    在一般的UNIX实现中，是将文件的索引节点号取出，前面加上子序号得到key_t的返回值。如指定文件的索引节点号为65538，换算成16进制为 0x010002，
    而你指定的ID值为38，换算成16进制为0x26，则最后的key_t返回值为0x26010002。
    查询文件索引节点号的方法是： ls -i
成功：返回key_t值（即IPC 键值）
出错：-1，错误原因存于error中

158  int msgget(key_t key, int msgflg)  该函数用来创建和访问一个消息队列

159  size_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);   该函数用来从一个消息队列获取消息

msqid: 由消息队列的标识符
msgp :消息缓冲区指针。消息缓冲区结构为：
struct msgbuf {
long mtype;
char mtext[1];
｝
msgsz: 消息数据的长度
msgtyp: 决定从队列中返回哪条消息：
=0 返回消息队列中第一条消息
>0 返回消息队列中等于mtype 类型的第一条消息。
<0 返回mtype<=type 绝对值最小值的第一条消息。
msgflg 为０表示阻塞方式，设置IPC_NOWAIT 表示非阻塞方式
msgrcv 调用成功返回0，不成功返回-1。



160  int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);  用来向消息队列发送消息的
     msgflg 取0 忽略标志位， 取IPC_NOWAIT 如果消息队列已满，函数返回。否则会阻塞等待消息队列不为满，写入消息
     返回值 0 成功 -1 失败


170  喂狗  int ioctl(int fd, unsigned long request, ...);

171  int clock_gettime(clockid_t clk_id, struct timespec* tp);

clk_id : 检索和设置的clk_id指定的时钟时间。
CLOCK_REALTIME:            系统实时时间,随系统实时时间改变而改变,即从UTC1970-1-1 0:0:0开始计时,
                           中间时刻如果系统时间被用户改成其他,则对应的时间相应改变
CLOCK_MONOTONIC:从系统启动这一刻起开始计时,不受系统时间被用户改变的影响   //系统运行时间
CLOCK_PROCESS_CPUTIME_ID:本进程到当前代码系统CPU花费的时间            //程序运行占用cpu时间，并不是程序运行时间
CLOCK_THREAD_CPUTIME_ID:本线程到当前代码系统CPU花费的时间
struct timespec {
        time_t tv_sec; /* 秒*/
        long tv_nsec; /* 纳秒*/
};

172   void shrink_to_fit();
      请求容器降低其容量和size匹配。
      该请求不具有约束力，容器可以自由地去执行其他的优化方案（capacity可以大于size）。//我查了一下网上说是该方法由编译器决定是否真正释放多余的内存，
      该方法值是提出请求，是否要实现由编译器说了算

173 int _access(char* path,int mode)
    头文件<io.h>
    功能：确定文件或文件夹的访问权限。如果指定的存取方式有效，则函数返回0，否则函数返回-1。
    参数path 是访问文件所在的路径名，mode是访问判断模式，
    具体含义如下：
    　　R_OK 只判断是否有读权限
    　　W_OK 只判断是否有写权限
    　　X_OK 判断是否有执行权限
    　　F_OK 只判断是否存在

174 int tcgetattr(int fd, struct termios *termios_p);    //用于获取与终端相关的参数，提供异步通讯接口      0：成功  -1：错误，
    struct termios *termios_p：返回值保留在termios结构体中：
           tcflag_t c_iflag;      /* input modes */             输入模式标识
           tcflag_t c_oflag;      /* output modes */            输出
           tcflag_t c_cflag;      /* control modes */           控制
           tcflag_t c_lflag;      /* local modes */             本地
           cc_t     c_cc[NCCS];   /* special characters */      控制字符，保存中断驱动程序中的特殊字符
    
    https://blog.csdn.net/dongshibo12/article/details/76209112

175 https://blog.csdn.net/qishi_blog/article/details/9238673
    波特率的设置通常使用cfsetospeed和cfsetispeed函数来完成。获取波特率信息是通过cfgetispeed和cfgetospeed函数来完成的
    int cfsetospeed(struct termios *termptr, speed_t speed);        如果成功返回0,否则返回-1
       struct termios *termptr - 指向termios结构的指针
       speed_t speed - 需要设置的输出波特率
    int cfsetispeed(struct termios *termptr, speed_t speed);        如果成功返回0,否则返回-1
        struct termios *termptr - 指向termios结构的指针
        speed_t speed - 需要设置的输入波特率

176 int tcflush(int fd, int queue_selector);
    fd                // 终端I/O打开的句柄 
    queue_selector    // 控制tcflush的操作，取值为下面三个常数中的一个：
        TCIFLUSH  // 清除正收到的数据，且不会读取出来。
        TCOFLUSH  // 清除正写入的数据，且不会发送至终端。
        TCIOFLUSH // 清除所有正在发生的I/O数据。
    返回值说明：
    0     // 成功
    -1    // 失败，并且为 errno 置值来指示错误

177   int tcsetattr(int fd, int optional_actions, const struct termios *termios_p); 函数用于设置终端的相关参数
      optional_actions可以取如下的值。
      TCSANOW：不等数据传输完毕就立即改变属性。
      TCSADRAIN：等待所有数据传输结束才改变属性。
      TCSAFLUSH：清空输入输出缓冲区才改变属性。

178  char *strsep(char **stringp, const char *delim);
    
   char str[] = "root:/root:/bin/bash";
　　char *buf;
　　char *token;
　　buf = str;
　　while((token = strsep(&buf, ":")) != NULL){
　　printf("%s/n", token);
　　}
    输出  root
         /root
         /bin/bash

179   double ldexp(double x, int exponent) 返回 x 乘以 2 的 exponent 次幂。 
      double sinh(double x)
         返回 x 的双曲正弦。
        9	double tanh(double x)
         返回 x 的双曲正切。
      10	double exp(double x)
         返回 e 的 x 次幂的值。
     11	double frexp(double x, int *exponent)
      把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent。
      12	double ldexp(double x, int exponent)

180 int unlink(const char *pathname);
    unlink()函数功能即为删除文件。执行unlink()函数会删除所给参数指定的文件
    执行unlink()函数并不一定会真正的删除文件，它先会检查文件系统中此文件的连接数是否为1，如果不是1说明此文件还有其他链接对象，
    因此只对此文件的连接数进行减1操作。若连接数为1，并且在此时没有任何进程打开该文件，此内容才会真正地被删除掉。
    在有进程打开此文件的情况下，则暂时不会删除，直到所有打开该文件的进程都结束时文件就会被删除

181 size_t regerror(int errcode, const regex_t *preg, char *errbuf,size_t errbuf_size);
    当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串

182 string::find()
    size_t find (const string& str, size_t pos = 0) const noexcept;
    size_t find (const char* s, size_t pos = 0) const;
    size_t find (const char* s, size_t pos, size_type n) const;
    size_t find (char c, size_t pos = 0) const noexcept;
    返回值都是查找到的字符所做的位置

183  boost::asio::deadline_timer    定时器
     https://www.cnblogs.com/xuaidongstdudyrecording/p/6077639.html

184  boost::asio::io_service

185  int connect(int sockfd, const struct sockaddr* server_addr, socklen_t addrlen)
     返回：0──成功， -1──失败。

186  post = malloc(re_len);
     if(post == NULL){
         return -1;
     }
     sprintf(post, "POST %s HTTP/1.0\r\n", page);
     sprintf(post, "%sHost: %s:%d\r\n",post, host, port);
     sprintf(post, "%s%s", post, HttpsPostHeaders);
     sprintf(post, "%sContent-Length: %d\r\n\r\n", post, len);
     sprintf(post, "%s%s", post, content); 		// 此处需要修改, 当业务需要上传非字符串数据的时候, 会造成数据传输丢失或失败
     printf("post::  \n%s\n", post);

187 ssize_t send(int sockfd, const void *buf, size_t len, int flags);
该函数的第一个参数指定发送端套接字描述符；
第二个参数指明一个存放应用程序要发送数据的缓冲区；
第三个参数指明实际要发送的数据的字节数；
第四个参数一般置0。

188 int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
        pthread_create 创建线程时，若不指定分配堆栈大小，系统会分配默认值，查看默认值方法如下：
# ulimit -s
8192
上述表示为8M；单位为KB
stacksize    堆栈大小  单位 字节char
一般来说 默认堆栈大小为 8388608; 堆栈最小为 16384 。 单位为字节。
堆栈最小值定义为 PTHREAD_STACK_MIN ，包含#include <limits.h>后可以通过打印其值查看。
对于默认值可以通过pthread_attr_getstacksize (&attr, &stack_size); 打印stack_size来查看。
尤其在嵌入式中内存不是很大，若采用默认值的话，会导致出现问题，若内存不足，则 pthread_create 会返回 12，定义如下

189  int pthread_cond_signal(pthread_cond_t *cond);
     使用pthread_cond_signal不会有“惊群现象”产生，他最多只给一个线程发信号。
     假如有多个线程正在阻塞等待着这个条件变量的话，那么是根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。
     如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。
     但无论如何一个pthread_cond_signal调用最多发信一次

190  int pthread_cond_broadcast(pthread_cond_t *cond);

192  PTHREAD_COND_INITIALIZER
    创建互斥量cond：
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER
    还可以通过函数的方式创建：
    int pthread_cond_init(pthread_cond_t *cond,NULL);
    注意：两种方式创建有所区别，第一种是创建静态全局的，所创建的量在全局区，第二种创建的量在栈，
    两种的区别我们可以理解为全局变量和局部变量的差异，对于两种方式，如果创建的是全局的条件量则用第一种方式初始化，
    如果是在函数内部创建则用第二种方式。这里其实跟互斥锁一样，互斥锁也可以用这两种方式初始化，原理相同

193  int aio_read(struct aiocb *aiocbp);  异步读操作，向内核发出读的命令，传入的参数是一个aiocb的结构
     int aio_write(struct aiocb *aiocbp);  异步写操作，向内核发出写的命令，传入的参数仍然是一个aiocb的结构
     int aio_error(const struct aiocb *aiocbp);
            如果该函数返回0，表示aiocbp指定的异步I/O操作请求完成。
            如果该函数返回EINPROGRESS，表示aiocbp指定的异步I/O操作请求正在处理中。
            如果该函数返回ECANCELED，表示aiocbp指定的异步I/O操作请求已经取消。
            如果该函数返回-1，表示发生错误，检查errno
    ssize_t aio_return(struct aiocb *aiocbp);这个函数的返回值相当于同步I/O中，read/write的返回值。只有在aio_error调用后才能被调用
    int aio_cancel(int fd, struct aiocb *aiocbp);
            取消在文件描述符fd上的aiocbp所指定的异步I/O请求。
            如果该函数返回AIO_CANCELED，表示操作成功。
            如果该函数返回AIO_NOTCANCELED，表示取消操作不成功，使用aio_error检查一下状态。
            如果返回-1，表示发生错误，检查errno

    int lio_listio(int mode, struct aiocb *restrict const list[restrict],int nent, struct sigevent *restrict sig)
            使用该函数，在很大程度上可以提高系统的性能，因为再一次I/O过程中，OS需要进行
            用户态和内核态的切换，如果我们将更多的I/O操作都放在一次用户太和内核太的切换中，
            减少切换次数，换句话说在内核尽量做更多的事情。这样可以提高系统的性能。
            用户程序提供一个struct aiocb的数组，每个元素表示一次AIO的请求操作。需要设置struct aiocb
            中的aio_lio_opcode数据成员的值，有LIO_READ，LIO_WRITE和LIO_NOP。
            nent表示数组中元素的个数。最后一个参数是对AIO操作完成后的通知机制的设置

194  int syscall(int number, ...);
    syscall() 执行一个系统调用，根据指定的参数number和所有系统调用的汇编语言接口来确定调用哪个系统调用。
    系统调用所使用的符号常量可以在头文件<sys/syscll.h>里面找到

195  
int io_setup(int maxevents, io_context_t *ctxp);
创建一个异步IO上下文（io_context_t是一个句柄）

int io_destroy(io_context_t ctx);
销毁一个异步IO上下文（如果有正在进行的异步IO，取消并等待它们完成）

long io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp);
提交异步IO请求

long io_cancel(aio_context_t ctx_id, struct iocb *iocb, struct io_event *result);
取消一个异步IO请求

long io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event *events, struct timespec *timeout);
等待并获取异步IO请求的事件（也就是异步请求的处理结果）

196  char *strdup(const char *s)

char * __strdup(const char *s) {
   size_t  len = strlen(s) +1;
   void *new = malloc(len);
   if (new == NULL)
      return NULL;
   return (char *)memecpy(new,s,len);
}

197 int isalpha(int c)    检查参数c是否为英文字母
    相关函数 isalnum，islower，isupper

198 IPv4中使用 gethostbyname()函数完成主机名到地址解析，这个函数仅仅支持IPv4，且不允许调用者指定所需地址类型的任何信息，
    返回的结构只包含了用于存储IPv4地址的空间。IPv6中引入了getaddrinfo()的新API，它是协议无关的，既可用于IPv4也可用于IPv6。
    getaddrinfo函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo的结构（列表）指针而不是一个地址清单。
    这些addrinfo结构随后可由套接口函数直接使用。如此以来，getaddrinfo函数把协议相关性安全隐藏在这个库函数内部。
    应用程序只要处理由getaddrinfo函数填写的套接口地址结构 

函数原型 int getaddrinfo( const char *hostname, const char *service, 
                    const struct addrinfo *hints, struct addrinfo **result );
    gethostbyname() 已经不再维护了,官方推荐用 getaddrinfo() 替代

参数说明
    hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)
    service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等
    hints：可以是一个空指针，也可以是一个指向某个 addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。
    举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成
    SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。
    result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。
    返回值：0——成功，非0——出错

    typedef struct addrinfo {
        int        　　　　    　　ai_flags;//指示在getaddrinfo函数中使用的选项的标志。
        int        　　　　   　　 ai_family;
        int        　　　　    　　ai_socktype;
        int        　　　　　 　　ai_protocol;
        size_t       　　　　 　　ai_addrlen;
        char       　　　　 　　*ai_canonname;
        struct sockaddr    　　*ai_addr;
        struct addrinfo     　　*ai_next;//指向链表中下一个结构的指针。此参数在链接列表的最后一个addrinfo结构中设置为NULL。
    } ADDRINFOA, *PADDRINFOA;
    struct sockaddr {
        ushort  sa_family;
        char    sa_data[14];
    };
    struct sockaddr_in {
        short           sin_family; //指代协议族，在socket编程中只能是 AF_INET
        u_short         sin_port;   //存储端口号（使用网络字节顺序）
        struct in_addr  sin_addr;   //存储IP地址，使用in_addr这个数据结构
        char            sin_zero[8];//为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节。
    };

ai_flags：
Value Meaning
AI_PASSIVE 套接字地址将用于调用bind 函数
AI_CANONNAME 返回规范名称
AI_NUMERICHOST 传递给getaddrinfo函数的nodename参数必须是数字字符串。
AI_ALL If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED.
AI_ADDRCONFIG 只有配置了全局地址后，getaddrinfo才会解析。 IPv6和IPv4环回地址不被认为是有效的全局地址。
AI_V4MAPPED 如果对IPv6地址的getaddrinfo请求失败，则对IPv4地址进行名称服务请求，这些地址将转换为IPv4映射IPv6地址格式。
AI_NON_AUTHORITATIVE 地址信息可以来自非授权命名空间提供商
AI_SECURE 地址信息来自安全信道。
AI_RETURN_PREFERRED_NAMES 地址信息是用于用户的优选名称。
AI_FQDN getaddrinfo将返回名称最终解析为的完全限定域名。 完全限定域名在ai_canonname成员中返回。
这与AI_CANONNAME位标记不同，后者返回在DNS中注册的规范名称，该名称可能与平面名称解析为的完全限定域名不同。
只能设置AI_FQDN和AI_CANONNAME位中的一个。 如果EAI_BADFLAGS同时存在这两个标志，getaddrinfo函数将失败。
AI_FILESERVER 命名空间提供程序提示正在查询的主机名正在文件共享方案中使用。 命名空间提供程序可以忽略此提示。

ai_family: The address family.

AF_UNSPEC 地址系列未指定。
AF_INET IPv4 address family.
AF_NETBIOS NetBIOS地址系列。
AF_INET6 IPv6 address family.
AF_IRDA The Infrared Data Association address family.
AF_BTH Bluetooth address family.

ai_protocol: 协议类型。

Value Meaning
IPPROTO_TCP 传输控制协议（TCP）。 当ai_family成员为AF_INET或AF_INET6且ai_socktype成员为SOCK_STREAM时，这是一个可能的值
IPPROTO_UDP 用户数据报协议（UDP）。 当ai_family成员为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。
IPPROTO_RM PGM协议用于可靠的组播。 当ai_family成员为AF_INET且ai_socktype成员为SOCK_RDM时，这是一个可能的值。 在为Windows Vista及更高版本发布的Windows SDK上，此值也称为IPPROTO_PGM。
可能的选项特定于指定的地址系列和套接字类型。
如果为ai_protocol指定了值0，则调用者不希望指定协议，服务提供者将选择要使用的ai_protocol。 对于IPv4和IPv6之外的协议，将ai_protocol设置为零。
下表列出了ai_protocol成员的通用值，尽管其他许多值也是可能的。

ai_socktype:　　套接字类型

Value Meaning
SOCK_STREAM 使用OOB数据传输机制提供顺序，可靠，双向，基于连接的字节流。使用Internet地址系列（AF_INET或AF_INET6）的传输控制协议（TCP）。如果ai_family成员是AF_IRDA，则SOCK_STREAM是唯一支持的套接字类型。
SOCK_DGRAM 支持数据报，它是无连接的，不可靠的固定（通常小）最大长度的缓冲区。对Internet地址系列（AF_INET或AF_INET6）使用用户数据报协议（UDP）。
SOCK_RAW 提供一个原始套接字，允许应用程序处理下一个上层协议头。要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。要操作IPv6头，必须在套接字上设置IPV6_HDRINCL套接字选项。
SOCK_RDM 提供可靠的消息数据报。这种类型的示例是在Windows中的实用通用多播（PGM）多播协议实现，通常被称为可靠多播节目。
SOCK_SEQPACKET 基于数据报提供伪流包

199  char *gai_strerror(int error);
    getaddrinfo出错时返回非零值，gai_strerror根据返回的非零值返回指向对应的出错信息字符串的指针，其原型如下
    
    常量                     描述
EAI_ADDRFAMILY	     不支持hostname的地址族
EAI_AGAIN	         名字解析中的暂时失败
EAI_BADFLAGS	     ai_flags的值无效
EAI_FAIL	         名字解析中不可恢复的失败
EAI_FAMILY	         不支持ai_family
EAI_MEMORY	         内存分配失败
EAI_NODATA	         没有与hostname相关联的地址
EAI_NONAME	         hostname或service未提供，或者不可知
EAI_SERVICE	         不支持ai_socktype类型的service
EAI_SOCKTYPE	     不支持ai_socktype
EAI_SYSTEM	         errno中有系统错误返回

200  void freeaddrinfo (struct addrinfo*ai);
     getaddrinfo返回的存储空间，包括addrinfo结构、ai_addr结构和ai_canonname字符串，都是用malloc动态获取的。这些空间可调用 freeaddrinfo释放。其原型如下

201 int isupper ( int c );判断一个字符是否是大写字母
    返回值为非零（真）表示c是大写字母，返回值为零（假）表示c不是大写字母。

    int tolower(int c)  字母字符转换成小写
    int touppre()函数是把字符串都转化为大写字母
    
    int isxdigit(int c) 检查参数c是否为16进制数字，真返回非零值，否则返回0。
    isalnum()：判断字符是否为字母或者数字
    isalpha()：判断字符是否为字母
    isdigit()：判断字符是否为数字

202 int isspace(int c) 当c为空白符时，返回true值，否则返回零。（空白符指空格、水平制表、垂直制表、换页、回车和换行符。
    \r    回车，将当前位置移到本行开头
    \n    换行，将当前位置移到下一行开头

203  int semget(key_t  _key ,int  _nsems,int _semflg);
    功能：创建一个新的信号量或获取一个已经存在的信号量的键值
    key  为整型值，用户可以自己设定。有两种情况：
    1.       键值是IPC_PRIVATE，该值通常为0，意思就是创建一个仅能被进程进程给我的信号量。
    2.       键值不是IPC_PRIVATE，我们可以指定键值，例如1234；也可以一个ftok()函数来取得一个唯一的键值。
    _nsems 表示初始化信号量的个数。比如我们要创建一个信号量，则该值为1.,创建2个就是2。
    _semflg  ：信号量的创建方式或权限。有IPC_CREAT，IPC_EXCL。
    IPC_CREAT如果信号量不存在，则创建一个信号量，否则获取。
    IPC_EXCL只有信号量不存在的时候，新的信号量才建立，否则就产生错误。

204  int semop(int   semid ,struct    sembuf   *_sops ,size_t  _nsops);
    功能：用户改变信号量的值。也就是使用资源还是释放资源使用权。
    返回值：成功返回0，失败返回-1；
参数：
    _semid : 信号量的标识码。也就是semget（）的返回值。
    _sops是一个指向结构体数组的指针。
struct   sembuf{
    unsigned short  sem_num;//第几个信号量，第一个信号量为0；
    short  sem_op;//对该信号量的操作。
    short _semflg;
};
sem_num:  操作信号在信号集中的编号。第一个信号的编号为0；
sem_op :  如果其值为正数，该值会加到现有的信号内含值中。通常用于释放所控资源的使用权；如果sem_op的值为负数，而其绝对值又大于信号的现值，
          操作将会阻塞，直到信号值大于或等于sem_op的绝对值。通常用于获取资源的使用权；如果sem_op的值为0，则操作将暂时阻塞，直到信号的值变为0。
_semflg IPC_NOWAIT //对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。
IPC_UNDO //程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。

205 std::transform在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内
    template <class InputIterator, class OutputIterator, class UnaryOperation>
    OutputIterator transform (InputIterator first1, InputIterator last1,
                            OutputIterator result, UnaryOperation op);
    std::vector<int> arr{ 1, 3, 5 };
    std::transform(arr.begin(), arr.end(), arr.begin(),[](int d) -> int {return d * 5; }); 
    或者 std::vector<int> arr2
    std::transform(arr.begin(), arr.end(), arr2.begin(),[](int d) -> int {return d * 5; }); 

206 void *calloc(size_t n, size_t size)；
    在内存的 动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的 指针；如果分配不成功，返回NULL

207 int pipe(int fd[2]);
    pipe函数定义中的fd参数是一个大小为2的一个数组类型的指针。该函数成功时返回0，并将一对打开的文件描述符值填入fd参数指向的数组。失败时返回 -1并设置errno。
    通过pipe函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0]
    一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。
    默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；
    如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。
    如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的read操作将返回0(管道内不存在数据的情况)，
    即读到了文件结束标记(EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有任何进程需要从管道读取数据，
    则针对该管道的写端文件描述符 fd[1] 的write操作将失败，并引发SIGPIPE信号(往读端被关闭的管道或socket连接中写数据)

208 int sysinfo(struct sysinfo *info);    操作成功返回0，错误返回-1；
    
    在Linux 2.3.16中，结构体的信息是（单位是字节）：
    struct sysinfo {                    
        long uptime;              
        /* 启动到现在经过的时间 */                    
        unsigned long loads[3];    
        /* 1, 5, and 15 minute load averages */                    
        unsigned long totalram;  /* 总的可用的内存大小 */  
        unsigned long freeram;   /* 还未被使用的内存大小 */  
        unsigned long sharedram; /* 共享的存储器的大小 */  
        unsigned long bufferram; /* 缓冲区大小 */                    
        unsigned long totalswap; /* 交换区大小 */                    
        unsigned long freeswap;  /* 还可用的交换区大小 */  
        unsigned short procs;    /* 当前进程数目 */  
        char _f[22];         /* 64字节的补丁结构 */
    }
    自Linux 2.3.23(i386), 2.3.48 (all architectures)中，结构体的信息是（单位是mem_unit字节）：
    struct sysinfo {  
        long uptime;          /* 启动到现在经过的时间 */  
        unsigned long loads[3];    
        /* 1, 5, and 15 minute load averages */  
        unsigned long totalram;  /* 总的可用的内存大小 */  
        unsigned long freeram;   /* 还未被使用的内存大小 */  
        unsigned long sharedram; /* 共享的存储器的大小*/  
        unsigned long bufferram; /* 共享的存储器的大小 */  
        unsigned long totalswap; /* 交换区大小 */  
        unsigned long freeswap;  /* 还可用的交换区大小 */  
        unsigned short procs;    /* 当前进程数目 */  
        unsigned long totalhigh; /* 总的高内存大小 */  
        unsigned long freehigh;  /* 可用的高内存大小 */  
        unsigned int mem_unit;   /* 以字节为单位的内存大小 */  
        char _f[20-2*sizeof(long)-sizeof(int)];   
        /* libc5的补丁  
    };

209 gzoffset()    返回压缩文件中将要读或写的位置

210  int setjmp(jmp_buf env);
     void longjmp(jmp_buf env, int val);
    =============================================================
        #include <stdio.h>
        #include <stdlib.h>
        #include <setjmp.h>
        jmp_buf env;
        int my_func(int a, int b) {
            if (b == 0) {
                printf("do not allow division by 0\n");
                longjmp(env, 1);
            }
            return a / b;
        }
        int main(int argc, char const *argv[]) {
            int res = setjmp(env);
            if (res == 0) {
                printf("return from setjmp\n");
                my_func(10, 0);
            } else {
                printf("return from longjmp: %d\n", res);
            }
            return 0;
        }
    -----------------------------------------------------------
            输出结果为：
            return from setjmp
            do not allow division by 0
            return from longjmp: 1
    ===========================================================

211    ioctl(int fd, ind cmd, …)     ioctl是设备驱动程序中对设备的I/O通道进行管理的函数
       在驱动程序中实现的ioctl函数体内，实际上是有一个switch{case}结构，每一个case对应一个命令码，做出一些相应的操作。怎么实现这些操作，
       这是每一个程序员自己的事情。因为设备都是特定的，这里也没法说。关键在于怎样组织命令码，因为在ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径
