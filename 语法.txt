1. override
  在成员函数声明或定义中， override 确保该函数为虚函数并覆写来自基类的虚函数.
  在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息

2. noexcept
  该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化
  如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数， 该函数内部会调用std::abort()终止程序.

 一个操作或者函数不可能抛出任何异常,在以往的C++版本中常用throw()表示，在C++ 11中已经被noexcept代替

3. final
在派生类覆盖的虚函数后面加上final将导致该派生类的派生类无法再去覆盖该虚函数了

4. delete
比如不想让某些可合成的成员函数被用户访问，以前的做法是将该函数定义为private的，比如默认拷贝构造函数。现在的做法只需要在该函数后面加上=delete

5. default,
代表使用编译器合成的函数，只有两类函数式编译器合成的。一是构造函数，二是拷贝函数。其中拷贝函数包括：拷贝构造函数，拷贝赋值重载符，析构函数。因为如果类自己实现了某个构造函数，那么编译器就不会为其合成构造函数，只有手动加上=default才行

class A{
    public:
        A(int a):a(a){}
        A(const A&)=default;
        A& operator=(const A&);
    private:
        int a;
    };

此时就无法通过A a(); 来创建A对象，因为编译器不会为其合成构造函数。采用下面的方法将可以完成。
class A{
    public:
        A()=default;
        A(int a):a(a){}
        A(const A&)=default;
        A& operator=(const A&);
    private:
        int a;
    };
    A& A::operator=(const A&)=default;//需要在类的外部再声明一次。
在上面的例子中，在类内用=default修饰的合成成员函数都是内联的，而在类外用=default修饰的合成成员函数不是内联的.

7. __thread
 __thread 是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。__thread变量每一个线程有一份独立实体，各个线程的值互不干扰。可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。
       __thread使用规则：只能修饰POD类型(类似整型指针的标量，不带自定义的构造、拷贝、赋值、析构的类型，二进制内容可以任意复制memset,memcpy,且内容可以复原)，不能修饰class类型，
	   因为无法自动调用构造函数和析构函数，可以用于修饰全局变量，函数内的静态变量，不能修饰函数的局部变量或者class的普通成员变量，
	   且__thread变量值只能初始化为编译器常量(值在编译器就可以确定const int i=5,运行期常量是运行初始化后不再改变const int i=rand())

8. 左值 右值

左值：指表达式结束后依然存在的持久对象，可以取地址，具名变量或对象
右值：表达式结束后就不再存在的临时对象，不可以取地址，没有名字

9. 左值引用和右值引用
   引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。引用可以改变指针的指向，还可以改变指针所指向的值。
   左值引用：type &引用名 = 左值表达式；
   右值引用：type &&引用名 = 右值表达式；

std::move的优点
  std::move语句可以将左值变为右值而避免拷贝构造。
  std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝

10. static_assert 
    static_assert断言，且可以打印出具体的出错信息。static_assert接收两个参数，一个是断言表达式，此表达式需要返回一个bool值；另一个则是警告信息，通常是字符串。以上代码可以修改如下

11. std::reverse  反转  std::reverse(myvector.begin(),myvector.end()); 
 
12. std::reverse_copy  myvector.resize(9) std::reverse_copy (myints, myints+9, myvector.begin());

13. std::string reserve() 改变容器大小.

14. reinterpret_cast
	reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位

15.
  构造函数(ctor)、复制构造函数(copy)、 赋值函数(assignment)、析构函数(dtor)
  
16. POD 
 POD（Plain Old Data，普通旧数据）类型是从 C++11 开始引入的概念，Plain 代表一个对象是一个普通类型，Old 代表一个对象可以与 C 兼容。
 通俗地讲，一个类、结构、共用体对象或非构造类型对象能通过二进制拷贝（如 memcpy()）后还能保持其数据不变正常使用的就是POD类型的对象。
 严格来讲，一个对象既是普通类型（Trivial Type）又是标准布局类型（Standard-layout Type）那么这个对象就是 POD 类型

17. __type_traits

18. 纯虚类是因为class不产生虚表，只能在派生类中实现虚表

19. std::unique_ptr<>
    “unique”一词有着“唯一的，独一无二”的意思，这主要体现在所有权上，某个 raw 指针同时只能被一个 unique_ptr 指针绑定，我们不能拷贝 unique_ptr 对象，只能转移。
    1. std::unique_ptr<int> up;//可以指向int的unique_ptr，不过是空的
       up.reset(new int(12))

    2. std::unique_ptr<int> up(new int(12));

20 explicit 

21.函数模板实例化：
  template <typename T> void swap(T &a, T&b){}; 
  int i, int j函数调用swap（i，j）导致编译器生成swap（）的一个实例，该实例使用int类型。
  模板并非函数定义，但使用int的模板实例就是函数定义，这种实例化方式被称为隐式实例化。
  C++允许显示实例化，template void swap<int>(int&, int & )
  
22. dynamic_cast
    dynamic_cast依赖于RTTI信息，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。被转换的类型必须是多态（即有虚函数）
	
23 输出格式化 printf("%" PRId64 "\n", value); 
   1.  PRId64  这是一种跨平台的书写方式，主要是为了同时支持32位和64位操作系统。PRId64表示64位整数，在32位系统中表示long long int，在64位系统中表示long int。
   相当于
   printf("%" "ld" "\n", value);  //64bit OS
   printf("%" "lld" "\n", value);  //32bit OS

24 const 修饰成员函数表示传入函数内的为 const *this
     (1)不允许修改成员变量；
　　  (2)mutable修饰符的成员变量，对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的；
	 (3)不允许访问非const函数。
	 
25. volatile

26. requires_capability
    clang的线程安全分析模块 thread safety analysis
	Clang的线程安全分析模块是C++语言的一个扩展，能对代码中潜在的竞争条件进行警告。这种分析是完全静态的（即编译时进行），
	没有运行时的消耗。当前这个功能还在开发中，但它已经具备了足够的成熟度，可以被部署到生产环境中。
	它由Google开发，同时受到CERT（United States Computer Emergency Readiness Team，美国互联网应急中心）
	/SEI（Software Engineering Institute，软件工程中心）的协助，并在Google的内部代码中被广泛应用。
    对于多线程的程序来说，线程安全分析很像一个类型系统。在一个多线程的环境中，程序员除了可以声明一个数据的类型（比如，int, float等）之外，
	还可以声明对数据的访问是如何被控制的。例如，如果变量foo受到互斥锁mu的监控，那么如果如果一段代码在读或者写foo之前没有加锁，就会发出警告。
	同样，如果一段仅应被GUI线程访问的代码被其它线程访问了，也会发出警告.
	
27. guarded_by
	属性是为了保证线程安全，使用该属性后，线程要使用相应变量，必须先锁定mutex_.
	
28. value_type
    
	template<typename T...> vector {
             typedef T value_type;
             ...
    }
	于是 vector<int>::value_type AnInt  等价于 int AnInt
	
29. typeof  __typeof__ 妙用 能推导出函数返回类型。
    int add(int a, int b);  typeof (add(int,int)) ret = 3;
	
30 __builtin_expect 
   __builtin_expect() 是 GCC (version >= 2.96）提供给程序员使用的，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。
   __builtin_expect((x),1)表示 x 的值为真的可能性更大；
   __builtin_expect((x),0)表示 x 的值为假的可能性更大
   一般的使用方法是将__builtin_expect指令封装为likely和unlikely宏。这两个宏的写法如下
   #define likely(x) __builtin_expect(!!(x), 1) //x很可能为真       
   #define unlikely(x) __builtin_expect(!!(x), 0) //x很可能为假

31 syscall(SYS_gettid) 系统调用返回一个 pid_t 类型值，即线程在内核中的ID

32 /proc/self/
   我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，
   就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。
   为了更方便的获取本进程的信息，linux提供了/proc/self/目录，
   这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。
   进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid
   
33  /proc/self/status  					查看进程状态
    /proc/self/stat    					查看进程信息
	/proc/self/task/%d(进程id)/stat      进程的状态信息
	/proc/self/exe                      readlink("/proc/self/exe", buf, sizeof(buf)) 可获取exe文件目录
	/proc/self/fd                       进程打开输入输出设备信息
	
34 std::atomic

35 const对象不能调用非const类型的成员函数。

36 NO_THREAD_SAFETY_ANALYSIS
   NO_THREAD_SAFETY_ANALYSIS是一种函数或方法的属性，它意味着对该函数关闭线程安全分析。它为以下两种函数的实现提供了可能，
   第一，故意设计的线程不安全的代码，第二，代码是线程安全的，但是对于线程安全分析模块来说太复杂，模块无法理解
   
37 ./main & ps -l 同时执行命令

38 多重 catch 语句中，异常类型必须子类在前父类在后，如果你把父类放前面就执行不到后边的了

39 线程创建子进程，子进程的名字和线程名一样。主线程新创建的线程中，fork子进程，子进程的名字是main，推断新线程的名字也是main.

40 printf("%zd\n", s)

z属于length字段，d属于type字段。该表达式用来表明输出格式是长度型(size_t)的有符号整形值。其中size_t在不同位数的操作系统中定义也是不相同的
32位
typedef unsigned int size_t
typedef  int         ssize_t
 
64位
typedef long unsigned int size_t
typedef long  int         ssize_t
如果参数类型是size_t或者ssize_t，在进行格式化输入或输出的时候务必使用‘z’修饰符，以防止显示异常

41  PRIu64  64位打印

42 强调一下，这里将Logger设置为匿名对象是一个非常重要的技巧，因为匿名对象是一使用完就马上销毁，而对于栈上的具名对象则是先创建的后销毁。
   也就是说，如果使用具名对象，则后创建的Logger对象会先于先创建的Logger对象销毁，这就会使得日志内容反序（更准确的说是一个作用域中的日志反序）
   
43 未命名的命名空间
   作用是该命名空间中的内容的作用域只是当前的源文件，而不能被其他源文件使用
   
44 柔性数组
   
struct test
{
  int len;
  int arr[];
}

struct test *a = (test*)malloc(sizeof(test)+sizeof(int)*5);


45.  RAII
   即“Resource Acquisition Is Initialization”，也称为“资源获取即初始化”。是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。
　 RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。
  
46 const 重载函数   //https://www.cnblogs.com/qingergege/p/7609533.html
    （1）const是函数类型的一部分，在实现部分也要带该关键字。
    （2）const关键字可以用于对重载函数的区分。
    （3）常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。
    （4）非常量对象也可以调用常成员函数，但是如果有重载的非常成员函数则会调用非常成员函数
	void fun(char *a)  
	{  
  		cout << "non-const fun() " << a;  
	}  
   
	void fun(const char *a)  
	{  
  		cout << "const fun() " << a;  
	}
	
47 构造函数
   C++在三种情况下会调用拷贝构造函数（可能有纰漏），第一种情况是函数形实结合时，第二种情况是函数返回时，函数栈区的对象会复制一份到函数的返回去，
   第三种情况是用一个对象初始化另一个对象时也会调用拷贝构造函数。除了这三种情况下会调用拷贝构造函数，另外如果将一个对象赋值给另一个对象，这个时候回调用重载的赋值运算符函数

48  移动构造函数

    Str(Str &&s)
        {
            cout<<"移动构造函数..."<<endl;
            str = NULL;
            str = s.str;
            s.str = NULL;
        }
49 移动赋值函数

50 std::move
   注意 std::move 只影响调用函数的选择，它本身不需要任何生成机器码。移动赋值函数 移动构造函数
   被"move"后的对象依然合法并处于未定义状态。也即，被"move"后的string对象的值可以是任意的，可能是空字符串，也可以烫烫烫，也可以是其它的值。
   被"move"后的对象是依然合法的，这个被delete后的指针变成非法不一样。你可以继续使用它，但是要注意重新赋值。
   move的本质就是帮助编译器选择重载函数, 告诉编译器"请尽量把此参数当做右值来处理"
   
   std::move和std::forward只不过就是执行cast的两个函数（实际上是函数模板)

51  offsetof                       //求成员到结构体首地址的距离
    #define offsetof(TYPE, MEMBER) ((size_t)&((TYPE*)0)->MEMBER)

52  container_of            //已知结构体type的成员member的地址ptr，求解结构体type的起始地址
    #define container_of(ptr, type, member) ({                 \
        const typeof(((type*)0)->member)* __mptr = (ptr);      \
        (type*)((char*))__mptr - offsetof(type, member); })
		
		
53  网络字节序和主机字节序
    术语“大端”和“小端”表示多个字节值的哪一端（小端或大端）存储在该值的起始地址
	遗憾的是，这两种字节序之间没有标准可循，两种格式都有系统使用。比如，Inter x86、ARM核采用的是小端模式，Power PC、MIPS UNIX和HP-PA UNIX采用大端模式
	
 网络字节序:
　　网络字节序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用big endian排序方式
 
 主机字节序:
 不同的机器主机字节序不相同，与CPU设计有关，数据的顺序是由cpu决定的，而与操作系统无关。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如x86系列CPU都是little-endian的字节序。

　　由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序
  
54 c++ 数组长度不能为负数，可以根据这个属性检测编译问题  T [sizeof(T) = 0 ? -1,:1]
   数组长度为负数时，报 size of array '  ' is negative 错误
   

55 decltype  选择并返回操作数的数据类型  int a = 1,  &b = a;  decltype(b) c = a;    // c是int&，即引用

56 函数模板默认零值   char c=char()

57 SFINAE  Substitution Failure Is Not An Error)（匹配失败不是异常）
  
 一个例子 template<typename T>
struct has_no_destroy
{
  template <typename C> static char test(decltype(&C::no_destroy));
  template <typename C> static int32_t test(...);
  const static bool value = sizeof(test<T>(0)) == 1;
};

58 迭代器 iterator
    一般来说，迭代器是个数据结构，会将真实的数据地址保存在某个内部的成员变量中，并重载各种运算符（比如解引用运算符*）。
    要取得数据地址，使用 &* 或者 std::addressof(iterator)
	
59  std::is_base_of
    template <class Base, class Derived> struct is_base_of; 
	作用是 判断 Base 是否为 Derived 的基类
	
60  __attribute__((unused))  去除unused 报警
	在C程序中，如果定义了一个静态函数，而没有去使用，编译时会有一个告警：
	而使用attribute((unused))可以告诉编译器忽略此告警.
	
	
70  /dev/null 和 /dev/zero的区别
        1./dev/null:表示 的是一个黑洞，通常用于丢弃不需要的数据输出， 或者用于输入流的空文件
            1.1 将无用的输出流写入到黑洞丢弃。
                curl -Iwww.baidu.com 2>/dev/null | head -l  错误信息定位到黑洞
            1.2 清空文件     
                cat /dev/null > /home/omc/h.txt
            1.3 在书写定时任务总，规范的写法就是将所有定时任务脚本结尾加上>/dev/null 2>&1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃。
                00 01 * * * /bin/sh/server/scripts/mysqlbak.sh >/dev/null 2>&1
        2./dev/zero:当我们使用或者读取他的时候，她是会提供无限连续不断的空的数据流
            2.1覆盖其他的文件信息
            2.2产生指定大小的空文件，如交换文件，模拟虚拟文件系统   
			
71 3个文件描述符存在(0、１、2)；）0表示标准输入，1表示标准输出，2表示标准错误  描述符引用计数，为0时才关闭文件
	extern struct _IO_FILE *stdin;		/* Standard input stream.  */
	extern struct _IO_FILE *stdout;		/* Standard output stream.  */
	extern struct _IO_FILE *stderr;		/* Standard error output stream.  */	
	/* C89/C99 say they're macros.  Make them happy.  */
	#define stdin stdin
	#define stdout stdout
	#define stderr stderr
	
	#define	STDIN_FILENO	0	/* Standard input.  */
	#define	STDOUT_FILENO	1	/* Standard output.  */
	#define	STDERR_FILENO	2	/* Standard error output.  */
	
72 信号量 

#define	SIG_ERR	 ((__sighandler_t) -1)	/* Error return.  */
#define	SIG_DFL	 ((__sighandler_t)  0)	/* Default action.  */
#define	SIG_IGN	 ((__sighandler_t)  1)	/* Ignore signal.  */	
	

72 std::array

73 stdbool.h
   在支持C99标准中，新增了关键字_Bool，其值只能为0或1，这样只要导入 stdbool.h ，就能非常方便的使用我们常用的bool false true来操作布尔类型
   
74 #include_next
   例如有个搜索路径链，在#include中，它们的搜索顺序依次是A，B，C，D和E。在B目录中有个头文件叫a.h，在D目录中也有个头文件叫a.h，
   如果在我们的源代码中这样写#include <a.h>，那么我们就会包含的是B目录中的a.h头文件，如果我们这样写#include_next <a.h>
   那么我们就会包含的是D目录中的a.h头文件。#include_next <a.h>的意思按我们上面的引号包含中的解释来说就是“在B目录中的a.h头文件后面的目录路径（即C，D和E）
   中搜索a.h头文件并包含进来）。#include_next <a.h>的操作会是这样的，它将在A，B，C，D和E目录中依次搜索a.h头文件，那么首先它会在B目录中搜索到a.h头文件，
   那它就会以B目录作为分割点，搜索B目录后面的目录（C，D和E），然后在这后面的目录中搜索a.h头文件，并把在这之后搜索到的a.h头文件包含进来。这样说的话大家应该清楚了吧。

   还有一点是#include_next是不区分<>和""的包含形式的
   
75 lambda 表达式
  
   [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}
   1. [] (int x, int y) -> int { int z = x + y; return z; }
   2. [] 
	
76 乱序执行(乱序执行译作异步执行更贴切)，是指在cpu中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执行，也许后面的指令先执行，
   当然，得保证指令之间不具备相关性
   
77 内存屏障(memory barrier)

78 asm volatile("" ::: "memory") 只是一个编译器障碍。

1）set_mb(),mb(),barrier()函数追踪到底，就是__asm____volatile__("":::"memory"),而这行代码就是内存屏障。
2）__asm__用于指示编译器在此插入汇编语句
3）__volatile__用于告诉编译器，严禁将此处的汇编语句与其它的语句重组合优化。即：原原本本按原来的样子处理这这里的汇编。
4）memory强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。这就阻止了cpu又将registers，cache中的数据用于去优化指令，而避免去访问内存。
5）"":::表示这是个空指令。barrier()不用在此插入一条串行化汇编指令。在后文将讨论什么叫串行化指令。
6）__asm__,__volatile__,memory在前面已经解释


79 __sync_synchronize()也是编译器屏障和完整内存屏障

80 锁
那么我们来温习下操作系统中5个知名的锁概念，每个技术都有适合自己的应用场景，此处引入介绍不再进一步深入展开。

1. 信号量(Semaphore)
Linux中的信号量是一种睡眠锁。如有一个任务试图获得一个已被持有的信号量时，信号量会将其推进等待队列，然后让其睡眠。当持有信号量的进程将信号量开释后，在等待队列中的一个任务将被唤醒，
从而便可以获得这个信号量。 信号量分为二元信号量和多元信号量，所谓二元信号量就是指该信号量只有两个状态，要么被占用，要么空闲;而多元信号量则允许同时被N个线程占有，
超出N个外的占用请求将被阻塞。信号量是“系统级别”的，即同一个信号量可以被不同的进程访问。
2.互斥量 (Mutex)
和二元信号量类似,不同的是互斥量的获取和释放必须是在同一个线程中进行的。如果一个线程不能去释放一个并不是它所占有的互斥量。而信号量是可以由其它线程进行释放的。
3.临界区(Critical Section)
把获取临界区的锁称为进入临界区，而把锁的释放称为离开临界区。Spinlock就是为了保护这临界区。
4. 读写锁(Read-Write Lock)
如果程序大部分时间都是在读取，使用前面的锁时，每次读也要申请锁的，会导致其他线程就无法再对此段数据进行同步读取。我们知道对数据进行读取时，不存在数据同步问题的，那么这些读锁就影响了程序的性能。
读写锁的出现就是为了解决这个问题的。
读写锁，有两种获取方式：共享(Shared)或独占 (Exclusive)。如果当前读写锁处于空闲状态，那么当多个线程同时以共享方式访问该读写锁时，都可以成功;而如果一个线程以独占的方式访问该读写锁，
那么它会等待所有共享访问都结束后才可以成功。在读写锁被独占的过程中，再次共享和独占请求访问该锁，都会进行等待状态。
5. 条件变量(Condition Variable)
条件变量相当于一种通知机制。多个线程可以设置等待该条件变量，一旦另外的线程设置了该条件变量(相当于唤醒条件变量)后，多个等待的线程就可以继续执行了。
以上是操作系统相关的几个概念，信号量也好互斥量也罢，只是不同的手段来实现资源的保护，实际还是根据真实应用需求的来选择。

81 Spinlock
我们来看下spinlock， spinlock叫做自旋锁，最初针对SMP系统，实现在SMP多处理器情况下临界区保护。
主要作用是给临界数据加锁，从而保护临界数据不被同时访问，实现多任务的同步。如果临界数据当前不可访问，那么就自旋直到可以访问为止。
自旋锁和互斥锁存在差异的是自旋锁不会引起调用者睡眠，如果自旋锁无法获取，那么调用者一直循环检测自旋锁直到释放。
spinlock的工作方式本身就体现了它的优缺点，优点是执行速度快，不涉及上下文切换；缺点是耗费CPU资源。
在Linux内核中，自旋锁通常用于包含内核数据结构的操作，可以看到在许多内核数据结构中都嵌入有spinlock，这些大部分就是用于保证它自身被操作的原子性（原子操作atomic operation为"不可被中断的一个或一系列操作"，最后其实是通过底层硬件来保证的），在操作这样的结构体时都经历这样的过程：上锁-操作-解锁。
因为在现代处理器系统中，考虑到中断、内核抢占以及其他处理器的访问，所以spinlock自旋锁应该阻止在代码运行过程中出现的其他并发干扰
	
82 Ctrl+C,操作系统就会向进程发送SIGINT信号
83 按下Ctrl+\（退出）,操作系统就会向进程发送SIGQUIT信号

84 c语言函数前置说明
  #include <stdio.h>

void func();

int func(int a, int b) {
    printf("%d\n", a + b);
    return 0;
}

int main() {
    func(3,5);
    return 0;
} // 不知道为什么这样可以。

85 信号的基本知识
1.信号本质:
信号的本质是软件层次上对中断的一种模拟。它是一种异步通信的处理机制，事实上，进程并不知道信号何时到来。
2.信号来源
(1)程序错误，如非法访问内存
(2)外部信号，如按下了CTRL+C
(3)通过kill或sigqueue向另外一个进程发送信号
3.信号种类
信号分为可靠信号与不可靠信号,可靠信号又称为实时信号，非可靠信号又称为非实时信号。
信号代码从1到32是不可靠信号,不可靠信号主要有以下问题:
(1)每次信号处理完之后，就会恢复成默认处理，这可能是调用者不希望看到的
(2)存在信号丢失的问题
现在的Linux对信号机制进行了改进，因此，不可靠信号主要是指信号丢失。
信号代码从SIGRTMIN到SIGRTMAX之间的信号是可靠信号。可靠信号不存在丢失，由sigqueue发送，可靠信号支持排队。
可靠信号注册机制:
内核每收到一个可靠信号都会去注册这个信号，在信号的未决信号链中分配sigqueue结构，因此，不会存在信号丢失的问题。
不可靠信号的注册机制:
而对于不可靠的信号，如果内核已经注册了这个信号，那么便不会再去注册，对于进程来说，便不会知道本次信号的发生。
可靠信号与不可靠信号与发送函数没有关系，取决于信号代码，前面的32种信号就是不可靠信号，而后面的32种信号就是可靠信号。
4.信号响应的方式
(1)采用系统默认处理SIG_DFL,执行缺省操作
(2)捕捉信号处理，即用户自定义的信号处理函数来处理
(3)忽略信号SIG_IGN ,但有两种信号不能被忽略SIGKILL，SIGSTOP

单线程中信号处理是中断正在执行的任务，响应信号处理函数，处理完后在继续中断的任务



86 前置申明
类或结构体的前向声明只能用来定义指针对象或引用，因为编译到这里时还没有发现定义，不知道该类或者结构的内部成员，没有办法具体的构造一个对象，所以会报错。
将类成员改成指针就好了。 程序中使用incomplete type实现前置声明有助与实现数据的隐藏。要求调用对象的程序段只能使用声明对象的引用或者指针。

87 无符号数3来说，x<<1往左移一位 0011 变成 0110 变成6了.

88    struct  str { int m;};    struct str * pst = malloc(sizeof(*pst));  //这也行??

89 C++中，临时对象都是const类型

90 
（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），
    又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，
    其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
（4）引用与一些操作符的重载：
     流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。
	 可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回 一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！
	 这无法让人接受。对于返回一 个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这 就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

100  ssize_t是有符号整型，在32位机器上等同与int，在64位机器上等同与long int
     size_t 就是无符号型的ssize_t
	 
101 EBNF，是一个计算机用语，意思是扩展的巴科斯范式。
    用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。
    扩展巴科斯-瑙尔范式(EBNF)是表达作为描述计算机编程语言和形式语言的正规方式的上下文无关文法的元语法符号表示法。
	它是基本巴科斯范式(BNF)元语法符号表示法的一种扩展。

102 https://www.boost.org/doc/libs/1_65_1/libs/spirit/example/   //查看example方法
    https://www.boost.org/doc/libs/1_65_1/libs/spirit/example/ 
	
103 https://www.boost.org/doc/libs/1_71_0/libs/spirit/example/qi/calc_utree.cpp  计算器解析
	 
104 通信协议——TLV

105 正交状态机
   正交状态机的意思是可能有多个初始状态，但是这些状态链是互不联系的，既不能从一个正交状态切换到另一个正交状态

106 有限状态机（Finite State Machine或者Finite State Automata)是软件领域中一种重要的工具

107 Linux中的0644 和 0755的权限
	0755->即用户具有读/写/执行权限，组用户和其它用户具有读写权限；
	0644->即用户具有读写权限，组用户和其它用户具有只读权限；
 	一般赋予目录0755权限，文件0644权限
	
108 FILE*fdopen(intfildes,constchar*mode);   //把流与一个文件句柄相接

109 define SIZE_MAX		(18446744073709551615UL)

110 SA_RESTART用在为某个信号设置信号处理函数时，给该信号设置的一个标记。
    一般情况下 ，进程正在执行某个系统调用，那么在该系统调用返回前信号是不会被递送的。但慢速系统调用除外，如读写终端、网络、磁盘，以及wait和pause。这些系 统调用都会返回-1，
	errno置为EINTR当系统调用被中断时，我们可以选择使用循环再次调用，或者设置重新启动该系统调用 (SA_RESTART)。
    一旦给信号设置了SA_RESTART标记，那么当执行某个阻塞系统调用时，收到该信号时，进程不会返回，而是重新执行该系统调用。
	
	信号是异步的，它会在程序的任何地方发生。由此程序正常的执行路径被打破，去执行信号处理函数。
    一般情况下 ，进程正在执行某个系统调用，那么在该系统调用返回前信号是不会被递送的。但慢速系统调用除外，如读写终端、网络、磁盘，以及wait和pause。
	这些系 统调用都会返回-1，errno置为EINTR当系统调用被中断时，我们可以选择使用循环再次调用，或者设置重新启动该系统调用 (SA_RESTART)。
111 SIGINT
    程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程
	
112 在linux下，每个进程都有自己的signal mask，这个信号掩码指定哪个信号被阻塞，哪个不会被阻塞，通常用调用sigmask来处理。同时每个进程还有自己的signal action，  
    //https://www.cnblogs.com/coding-my-life/p/4782529.html
    这个行为集合指定了信号该如何处理，通常调用sigaction来处理。
    信号发生时，哪个线程会收到
    是不是每个线程都有自己的mask及action
    每个线程能按自己的方式处理信号么
　　 首先，信号的传递是根据情况而定的：
   
   如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。
   如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。
   如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，
   然后调用它来处理。(一般从主线程找起)，注意只有一个线程能收到。
　 其次，每个线程都有自己独立的signal mask，但所有线程共享进程的signal action。这意味着，你可以在线程中调用pthread_sigmask(不是sigmask)来决定本线程阻塞哪些信号。
  但你不能调用sigaction来指定单个线程的信号处理方式。如果在某个线程中调用了sigaction处理某个信号，那么这个进程中的未阻塞这个信号的线程在收到这个信号都会按同一种方式处理这个信号。
  另外，注意子线程的mask是会从主线程继承而来的。


113 _Bool是C99新增加的关键字，长度是1

114  value optimized out 变量被编译优化掉了，看不到了


115  当我们编写了一个lambda之后，编译器将该表达式翻译成一个未命名类的未命名对象。该类含有一个重载的函数调用运算符

116 在类体之外定义const成员函数时，还必须加上const关键字

117 数字前缀
　　u或U 表示数字是无符号整型数，如：123u，但并不说明是长整型还是短整型 
   l或L 表示数字是长整型数，如：123l；而123ul就是无符号长整型数；而34.4l就是长双精度浮点数，等效于双精度浮点数 
   i64或I64 表示数字是长长整型数，其是为64位操作系统定义的，长度比长整型数长。如：43i64 
   f或F 表示数字是单精度浮点数，如：12.3f 
   e或E 表示数字的次幂，如：34.4e-2就是0.344；0.2544e3f表示一个单精度浮点数，值为254.4 
   当什么后缀都没写时，则根据有无小数点及位数来决定其具体类型，如：123表示的是有符号整型数；而34.43表示双精度浮点数。 
   为什么要搞这么多事出来，还分什么有符号无符号之类的？这全是因为电脑并非基于数字的，而是基于状态的，详情在下篇中将详细说明。
   作为科学计算，可能经常会碰到使用非十进制数字，如16进制、8进制等，C++也为此提供了一些前缀以进行支持。
   在数字前面加上0x或0X表示这个数字是16进制表示的，如：0xF3Fa、0x11cF。而在前面加一个0则表示这个数字是用8进制表示的，如：0347，变为十进制数就为231。
   但16进制和8进制都不能用于表示浮点数，只能表示整型数，即0x34.343是错误的

118 枚举类型 枚举值可以直接转换成int
    c中 int 能直接转换成枚举值
    c++ 中 int 不能直接转换成枚举值，需要强制转换

119 #include <new>  
    std::nothrow 在内存不足时，new (std::nothrow)并不抛出异常，而是将指针置NULL。
    Task * ptask = new (std::nothrow) Task;  
    if (!ptask)  {  
        std::cerr<<"allocation failure!";  
        std::exit(1);  
    }

    #include <new>                              // std::nothrow

120. MVC模式 
    MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，
    是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，
    在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间

121. value_type  每个STL中的类都有value_type这种东西，通俗的说value_type 就是stl容器盛装的数据的数据类型
	
122. 标准库类型(library type)ptrdiff_t 与 size_t 类型一样,ptrdiff_t 也是一种与机器相关的类型,在 cstddef 头文件中定义。
     size_t 是unsigned 类型,而 ptrdiff_t 则是 signed 整型
     ptrdiff_t与difference_type区别，前面的是c++定义的标准，后面则是STL定义的

    int *a=new int(1);
    int *b=new int(2);
    ptrdiff_t result=a-b;
    cout<<a<<ends<<b<<ends<<result<<endl; //
    000F8F08
    000F8F38
    -12
    可以看出，2个指针相减等于（地址相减的值)/指针所指向的数据类型
    
123. ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，
     没有被收录在ISO-8859-1当中。 因为ISO-8859-1编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流
     都不会被抛弃。换言之，把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题。这是个很重要的特性，MySQL数据库默认编码是Latin1就是利
     用了这个特性。ASCII编码是一个7位的容器，ISO-8859-1编码是一个8位的容器

124. 宽字符wchar_t  占用两个字节  const char * str = L"hello world"

125. 匿名结构体， 匿名联合 brpc->safe_sprintf.h
    union {
    struct {
      int64_t       i;
      unsigned char width;
    };
    const char* str;
    const void* ptr;
  };

126. std::numeric_limits<T>::max()，min()及lowest()

127 ArraySizeHelper     :::brpc->macros.h
    namespace butil {
    template <typename T, size_t N>
    char (&ArraySizeHelper(T (&array)[N]))[N];
    }

128. sizeof是C/C++语言中的keyword，不是函数。对其参数里的表达式是不会在执行期去执行的，而只是在编译期去推算整个表达式的最后的类型信息。
　　比如： int a = 1; sizeof(a++); cout << a;   // a还是1. 不会是2；

129. 
    返回值为数组指针T (*)[N] ::: T (* Foo( param_list ) )[N];
    返回值为数组引用T (&)[N] ::: T (& Foo( param_list ) )[N];

130. template< typename T, size_t N>
     void Fun( T (&)[N] );
     这个模板里既有类型T，又有数值N；模板推导时，是根据Fun的实参来推导得到的。比如：
     int a[5];
     Fun(a); // 编译器经过推导就知道，T=int，N=5。注意这里的N能得到5，是因为Fun的参数声明决定的。
     这里Fun的参数是：数组引用

131. template <typename T, size_t N>
     char (&ArraySizeHelper(T (&array)[N]))[N];
    
132. 数组的引用,  (注意c++没有引用的数组)
     T (&)[N] (注意：有个括号)。比如：
　　 int a[5] = {0};
　　 int (&ra)[5] = a;  //这里ra就是一个对数组a的引用，其这个数组的大小也是5

133. sizeof(一个指针)和sizeof(一个数组)有很大区别
　　int a[5];
　　int *p = a;
　　int (*pa)[5] = &a;
　　// p和pa都是指针，但是指针的类型不同：p的类型是int*；pa的类型是int(*)[5]。
　　sizeof(p)        // = 4;
　　sizeof(a)        // = 20 = 5*sizeof(int)
　　sizeof(*p)       // = sizeof(int) = 4;
　　sizeof(pa)       // = 4;
　　sizeof(*pa)      // = sizeof(a) = 20;

134. try catch    // catch后面语句 "catch later" 会打印  
int func() {
    try {
        throw 1;
    }

    catch(...) {
        std::cerr << " e.what() " << '\n';
    }
    std::cout << "catch later" << std::endl;
    return 0;
}

135

1. 基础数据类型模型定义
C/C++仅仅定义基本数据类型的关系（字长：CHAR<=SHORT<=INT<=LONG），并没有严格定义它们的字长，根据编译器的不同实现，它们的字长表示也不同

LP64指的是LONG/POINTER字长为64位；
ILP64指的是INT/LONG/POINT字长为64位；
LLP64指的是LONGLONG/POINTER字长为64位；
ILP32指的是INT/LONG/POINTER字长为32位；
LP32指的是LONG/POINT字长是32位的，INT字长为16位。
2. 数据模型中数据类型的长度表
ILP32和LP32是32位平台上字长的数据模型，LP64、ILP64、LLP64是64位平台上字长的数据模型

TYPE           LP32    ILP32    LP64    ILP64    LLP64

CHAR           8        8        8        8        8

SHORT          16       16       16       16       16

INT            16       32       32       64       32

LONG           32       32       64       64       32

LONG LONG      64       64       64       64       64

POINTER        32       32       64       64       64 
3. 一些注意点
32位Windows采用的是ILP32数据模型，64位Windows采用LLP64数据模型。
32位的Linux/Unix使用ILP32数据模型，64位Linux/Unix使用LP64数据模型。
为了增加代码的移植性，打印无符号整形数，不管申明时是如何定义的，统一使用 %lu。
为了保证平台的通用性，代码中尽量不要使用long数据库型。
使用INT时也可以使用intptr_t来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台长度，比如：64位机器上长度为8字节，32位机器上长度为4字节。
编写代码时要尽量使用sizeof来计算数据类型的大小。
ssize_t和size_t分别是signsize_t和unsigned signed size of computer word size。它们也是表示计算机的字长，在32位机器上是int型，在64位机器上long型，从某种意义上来说它们等同于intptr_t和 uintptr_t。


136.  delete 
      C++11 中，可在想要 “禁止使用” 的特殊成员函数声明后加 “= delete”，而需要保留的加 "= default" 或者不采取操作

137   auto &h = 42;         // 错误：非常量引用的初始值必须为左值。
      const auto &j = 42;   //正确:常量引用可以绑定到字面值。

138   decltype
      有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。
      还有可能是函数的返回类型为某表达式的的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，
      它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值

139   模板元编程 <模板特化??>
      模版元编程完全不同于普通的运行期程序，它很独特，因为模版元程序的执行完全是在编译期，并且模版元程序操纵的数据不能是运行时变量，
      只能是编译期常量，不可修改，另外它用到的语法元素也是相当有限，不能使用运行期的一些语法，比如if-else，for等语句都不能用。
      因此，模版元编程需要很多技巧，常常需要类型重定义、枚举常量、继承、模板偏特化等方法来配合，因此编写模版元编程比较复杂也比较困难

139  std::numeric_limits<T>::radix
     std::numeric_limits<T>::radix 的值是用于表示该类型的数字系统的底。对于所有二进制数值类型为 2 ，
     但它可以，譬如对 IEEE 754 十进制浮点类型或第三方二进制编码十进制整数为 10 。此常量对所有特化有意义。

140  内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当
     对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性

141  使用const提高程序的健壮性和效率

142  顶层const：不可以改变指向，但是可以改变指向的内容的值。 非顶层cosnt：可以改变指向，但是不可以改变指向的内容

143  __attribute__((warn_unused_result))    判断函数返回值

145  //传入的参数是数组的引用，返回值也是数组的引用
    string (&fun(string (&s)[10]))[10]{
        return s;
    }
146  template<int N>
     void fun(int(&a)[N]);
     如果只要传固定大小的数组，可以把template去掉，N改成大小

     /////  int (&fun(int (&i)[10])) [10];

147  tid是线程在内核态的id，而pthread_selft是线程在用户态的id（posix pthread id)

148  std::string::npos
     static const size_t npos = -1

149  C++二进制文件读取ios::binary
     在C++读取文件时，如果打开方式不显示加上ios::binary标记的话，默认文本模式的。当使用read函数读取一定量的字符时，
     如果这些字符里包含非Ascii码（> 127），读取就会失败。此外，还有和平台相关的换行符带来的问题

150 宏的定义是编译器先展开宏再编译的，也就是说，编译器会事先把出现宏的地方全部替换掉，所以定义他们的先后顺序就无关紧要了

151 
    OO ：Object Oriented ，支持多态这一强大的设计机制，需要付出的代价便是额外的间接性（virtual机制）。
    OB ：Object Based ，非多态的数据封装模型，就是ADT（Abstract Data Type）的概念，
        和OO相比拥有更快的速度而且空间更紧凑（因为不需要virtual）

152  assert在程序的release版本中仍然有效（不要与VC中的ASSERT混淆），要使assert失效，
     只有在包含assert头文件（assert.h）的语句前定义NDEBUG宏或在编译器参数中添加-DNDEBUG参数

153  inline
inline void FuncA(_T para) {
   FuncB(para, para+1);
}

void FuncB(_T paraA, _T paraB) {

}

至于 整个FuncB也会被展开塞进代码里？
这是函数FuncB 会不会内联的问题，和函数FuncA 没有任何关系
可以内联的话 FuncB 被内联进 FuncA
编译器对内联成功的代码，自然不会还原成函数调用了
FuncB不可以内联，那么 FuncA 就被内联成对FuncB函数调用
FuncB可以内联 那么内联 FuncA 就被已经内联到FunA的内部FuncB内内联后的代码取代了,
也就是 FuncB，FuncA 都内联了
注意到FuncB 没有inline
所以不是一定会内联的，所以就看编译器心情了（设定了），
即便很容易内联，因为没有指定，所以就不确定了

154  多级指针const
    void func(const int ** arg) {
    }
int main(int argc, char **argv) {
    int **p;
    func(p);
    return 0;
}
// gcc 编译报错
const int ** p1;  // int元素不可修改
int * const * p2; // int *一级指针不可修改
int ** const p3;  // int **二级指针不可修改

155  ## 是简单的连接符，#@用来给参数加单引号，#用来给参数加双引号即转成字符串














      





	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


   






























































































































































