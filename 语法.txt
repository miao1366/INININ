1. override
  在成员函数声明或定义中， override 确保该函数为虚函数并覆写来自基类的虚函数.
  在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息

2. noexcept
  该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化
  如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数， 该函数内部会调用std::abort()终止程序.

 一个操作或者函数不可能抛出任何异常,在以往的C++版本中常用throw()表示，在C++ 11中已经被noexcept代替

3. final
在派生类覆盖的虚函数后面加上final将导致该派生类的派生类无法再去覆盖该虚函数了

4. delete
比如不想让某些可合成的成员函数被用户访问，以前的做法是将该函数定义为private的，比如默认拷贝构造函数。现在的做法只需要在该函数后面加上=delete

5. default,
代表使用编译器合成的函数，只有两类函数式编译器合成的。一是构造函数，二是拷贝函数。其中拷贝函数包括：拷贝构造函数，拷贝赋值重载符，析构函数。因为如果类自己实现了某个构造函数，那么编译器就不会为其合成构造函数，只有手动加上=default才行

class A{
    public:
        A(int a):a(a){}
        A(const A&)=default;
        A& operator=(const A&);
    private:
        int a;
    };

此时就无法通过A a(); 来创建A对象，因为编译器不会为其合成构造函数。采用下面的方法将可以完成。
class A{
    public:
        A()=default;
        A(int a):a(a){}
        A(const A&)=default;
        A& operator=(const A&);
    private:
        int a;
    };
    A& A::operator=(const A&)=default;//需要在类的外部再声明一次。
在上面的例子中，在类内用=default修饰的合成成员函数都是内联的，而在类外用=default修饰的合成成员函数不是内联的.

7. __thread
 __thread 是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。__thread变量每一个线程有一份独立实体，各个线程的值互不干扰。可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。
       __thread使用规则：只能修饰POD类型(类似整型指针的标量，不带自定义的构造、拷贝、赋值、析构的类型，二进制内容可以任意复制memset,memcpy,且内容可以复原)，不能修饰class类型，
	   因为无法自动调用构造函数和析构函数，可以用于修饰全局变量，函数内的静态变量，不能修饰函数的局部变量或者class的普通成员变量，
	   且__thread变量值只能初始化为编译器常量(值在编译器就可以确定const int i=5,运行期常量是运行初始化后不再改变const int i=rand())

8. 左值 右值

左值：指表达式结束后依然存在的持久对象，可以取地址，具名变量或对象
右值：表达式结束后就不再存在的临时对象，不可以取地址，没有名字

9. 左值引用和右值引用
   引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。引用可以改变指针的指向，还可以改变指针所指向的值。
   左值引用：type &引用名 = 左值表达式；
   右值引用：type &&引用名 = 右值表达式；

std::move的优点
  std::move语句可以将左值变为右值而避免拷贝构造。
  std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝

10. static_assert 
    static_assert断言，且可以打印出具体的出错信息。static_assert接收两个参数，一个是断言表达式，此表达式需要返回一个bool值；另一个则是警告信息，通常是字符串。以上代码可以修改如下

11. std::reverse  反转  std::reverse(myvector.begin(),myvector.end()); 
 
12. std::reverse_copy  myvector.resize(9) std::reverse_copy (myints, myints+9, myvector.begin());

13. std::string reserve() 改变容器大小.

14. reinterpret_cast
	reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位

15.
  构造函数(ctor)、复制构造函数(copy)、 赋值函数(assignment)、析构函数(dtor)
  
16. POD 
 POD（Plain Old Data，普通旧数据）类型是从 C++11 开始引入的概念，Plain 代表一个对象是一个普通类型，Old 代表一个对象可以与 C 兼容。
 通俗地讲，一个类、结构、共用体对象或非构造类型对象能通过二进制拷贝（如 memcpy()）后还能保持其数据不变正常使用的就是POD类型的对象。
 严格来讲，一个对象既是普通类型（Trivial Type）又是标准布局类型（Standard-layout Type）那么这个对象就是 POD 类型

17. __type_traits

18. 纯虚类是因为class不产生虚表，只能在派生类中实现虚表

19. std::unique_ptr<>
    “unique”一词有着“唯一的，独一无二”的意思，这主要体现在所有权上，某个 raw 指针同时只能被一个 unique_ptr 指针绑定，我们不能拷贝 unique_ptr 对象，只能转移。
    1. std::unique_ptr<int> up;//可以指向int的unique_ptr，不过是空的
       up.reset(new int(12))

    2. std::unique_ptr<int> up(new int(12));

20 explicit 

21.函数模板实例化：
  template <typename T> void swap(T &a, T&b){}; 
  int i, int j函数调用swap（i，j）导致编译器生成swap（）的一个实例，该实例使用int类型。
  模板并非函数定义，但使用int的模板实例就是函数定义，这种实例化方式被称为隐式实例化。
  C++允许显示实例化，template void swap<int>(int&, int & )
  
22. dynamic_cast
    dynamic_cast依赖于RTTI信息，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。被转换的类型必须是多态（即有虚函数）
	
23 输出格式化 printf("%" PRId64 "\n", value); 
   1.  PRId64  这是一种跨平台的书写方式，主要是为了同时支持32位和64位操作系统。PRId64表示64位整数，在32位系统中表示long long int，在64位系统中表示long int。
   相当于
   printf("%" "ld" "\n", value);  //64bit OS
   printf("%" "lld" "\n", value);  //32bit OS

24 const 修饰成员函数表示传入函数内的为 const *this
     (1)不允许修改成员变量；
　　  (2)mutable修饰符的成员变量，对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的；
	 (3)不允许访问非const函数。
	 
25. volatile

26. requires_capability
    clang的线程安全分析模块 thread safety analysis
	Clang的线程安全分析模块是C++语言的一个扩展，能对代码中潜在的竞争条件进行警告。这种分析是完全静态的（即编译时进行），
	没有运行时的消耗。当前这个功能还在开发中，但它已经具备了足够的成熟度，可以被部署到生产环境中。
	它由Google开发，同时受到CERT（United States Computer Emergency Readiness Team，美国互联网应急中心）
	/SEI（Software Engineering Institute，软件工程中心）的协助，并在Google的内部代码中被广泛应用。
    对于多线程的程序来说，线程安全分析很像一个类型系统。在一个多线程的环境中，程序员除了可以声明一个数据的类型（比如，int, float等）之外，
	还可以声明对数据的访问是如何被控制的。例如，如果变量foo受到互斥锁mu的监控，那么如果如果一段代码在读或者写foo之前没有加锁，就会发出警告。
	同样，如果一段仅应被GUI线程访问的代码被其它线程访问了，也会发出警告.
	
27. guarded_by
	属性是为了保证线程安全，使用该属性后，线程要使用相应变量，必须先锁定mutex_.
	
28. value_type
    
	template<typename T...> vector {
             typedef T value_type;
             ...
    }
	于是 vector<int>::value_type AnInt  等价于 int AnInt
	
29. typeof  __typeof__ 妙用 能推导出函数返回类型。
    int add(int a, int b);  typeof (add(int,int)) ret = 3;
	
30 __builtin_expect 
   __builtin_expect() 是 GCC (version >= 2.96）提供给程序员使用的，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。
   __builtin_expect((x),1)表示 x 的值为真的可能性更大；
   __builtin_expect((x),0)表示 x 的值为假的可能性更大
   一般的使用方法是将__builtin_expect指令封装为likely和unlikely宏。这两个宏的写法如下
   #define likely(x) __builtin_expect(!!(x), 1) //x很可能为真       
   #define unlikely(x) __builtin_expect(!!(x), 0) //x很可能为假

31 syscall(SYS_gettid) 系统调用返回一个 pid_t 类型值，即线程在内核中的ID

32 /proc/self/
   我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，
   就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。
   为了更方便的获取本进程的信息，linux提供了/proc/self/目录，
   这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。
   进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid
   
33  /proc/self/status  					查看进程状态
    /proc/self/stat    					查看进程信息
	/proc/self/task/%d(进程id)/stat      进程的状态信息
	/proc/self/exe                      readlink("/proc/self/exe", buf, sizeof(buf)) 可获取exe文件目录
	/proc/self/fd                       进程打开输入输出设备信息
	
34 std::atomic

35 const对象不能调用非const类型的成员函数。

36 NO_THREAD_SAFETY_ANALYSIS
   NO_THREAD_SAFETY_ANALYSIS是一种函数或方法的属性，它意味着对该函数关闭线程安全分析。它为以下两种函数的实现提供了可能，
   第一，故意设计的线程不安全的代码，第二，代码是线程安全的，但是对于线程安全分析模块来说太复杂，模块无法理解
   
37 ./main & ps -l 同时执行命令

38 多重 catch 语句中，异常类型必须子类在前父类在后，如果你把父类放前面就执行不到后边的了

39 线程创建子进程，子进程的名字和线程名一样。主线程新创建的线程中，fork子进程，子进程的名字是main，推断新线程的名字也是main.

40 printf("%zd\n", s)

z属于length字段，d属于type字段。该表达式用来表明输出格式是长度型(size_t)的有符号整形值。其中size_t在不同位数的操作系统中定义也是不相同的
32位
typedef unsigned int size_t
typedef  int         ssize_t
 
64位
typedef long unsigned int size_t
typedef long  int         ssize_t
如果参数类型是size_t或者ssize_t，在进行格式化输入或输出的时候务必使用‘z’修饰符，以防止显示异常

41  PRIu64  64位打印

42 强调一下，这里将Logger设置为匿名对象是一个非常重要的技巧，因为匿名对象是一使用完就马上销毁，而对于栈上的具名对象则是先创建的后销毁。
   也就是说，如果使用具名对象，则后创建的Logger对象会先于先创建的Logger对象销毁，这就会使得日志内容反序（更准确的说是一个作用域中的日志反序）
   
43 未命名的命名空间
   作用是该命名空间中的内容的作用域只是当前的源文件，而不能被其他源文件使用
   
44 柔性数组
   
struct test
{
  int len;
  int arr[];
}

struct test *a = (test*)malloc(sizeof(test)+sizeof(int)*5);


45.  RAII
   即“Resource Acquisition Is Initialization”，也称为“资源获取即初始化”。是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。
　 RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。
  
46 const 重载函数   //https://www.cnblogs.com/qingergege/p/7609533.html
    （1）const是函数类型的一部分，在实现部分也要带该关键字。
    （2）const关键字可以用于对重载函数的区分。
    （3）常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。
    （4）非常量对象也可以调用常成员函数，但是如果有重载的非常成员函数则会调用非常成员函数
	void fun(char *a)  
	{  
  		cout << "non-const fun() " << a;  
	}  
   
	void fun(const char *a)  
	{  
  		cout << "const fun() " << a;  
	}
	
47 构造函数
   C++在三种情况下会调用拷贝构造函数（可能有纰漏），第一种情况是函数形实结合时，第二种情况是函数返回时，函数栈区的对象会复制一份到函数的返回去，
   第三种情况是用一个对象初始化另一个对象时也会调用拷贝构造函数。除了这三种情况下会调用拷贝构造函数，另外如果将一个对象赋值给另一个对象，这个时候回调用重载的赋值运算符函数

48  移动构造函数

    Str(Str &&s)
        {
            cout<<"移动构造函数..."<<endl;
            str = NULL;
            str = s.str;
            s.str = NULL;
        }
49 移动赋值函数

50 std::move
   注意 std::move 只影响调用函数的选择，它本身不需要任何生成机器码。移动赋值函数 移动构造函数
   被"move"后的对象依然合法并处于未定义状态。也即，被"move"后的string对象的值可以是任意的，可能是空字符串，也可以烫烫烫，也可以是其它的值。
   被"move"后的对象是依然合法的，这个被delete后的指针变成非法不一样。你可以继续使用它，但是要注意重新赋值。
   move的本质就是帮助编译器选择重载函数, 告诉编译器"请尽量把此参数当做右值来处理"
   
   std::move和std::forward只不过就是执行cast的两个函数（实际上是函数模板)

51  offsetof                       //求成员到结构体首地址的距离
    #define offsetof(TYPE, MEMBER) ((size_t)&((TYPE*)0)->MEMBER)

52  container_of            //已知结构体type的成员member的地址ptr，求解结构体type的起始地址
    #define container_of(ptr, type, member) ({                 \
        const typeof(((type*)0)->member)* __mptr = (ptr);      \
        (type*)((char*))__mptr - offsetof(type, member); })
		
		
53  网络字节序和主机字节序
    术语“大端”和“小端”表示多个字节值的哪一端（小端或大端）存储在该值的起始地址
	遗憾的是，这两种字节序之间没有标准可循，两种格式都有系统使用。比如，Inter x86、ARM核采用的是小端模式，Power PC、MIPS UNIX和HP-PA UNIX采用大端模式
	
 网络字节序:
　　网络字节序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用big endian排序方式
 
 主机字节序:
 不同的机器主机字节序不相同，与CPU设计有关，数据的顺序是由cpu决定的，而与操作系统无关。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如x86系列CPU都是little-endian的字节序。

　　由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序
  
54 c++ 数组长度不能为负数，可以根据这个属性检测编译问题  T [sizeof(T) = 0 ? -1,:1]
   数组长度为负数时，报 size of array '  ' is negative 错误
   

55 decltype  选择并返回操作数的数据类型  int a = 1,  &b = a;  decltype(b) c = a;    // c是int&，即引用

56 函数模板默认零值   char c=char()

57 SFINAE  Substitution Failure Is Not An Error)（匹配失败不是异常）
  
 一个例子 template<typename T>
struct has_no_destroy
{
  template <typename C> static char test(decltype(&C::no_destroy));
  template <typename C> static int32_t test(...);
  const static bool value = sizeof(test<T>(0)) == 1;
};

58 迭代器 iterator
    一般来说，迭代器是个数据结构，会将真实的数据地址保存在某个内部的成员变量中，并重载各种运算符（比如解引用运算符*）。
    要取得数据地址，使用 &* 或者 std::addressof(iterator)
	
59  std::is_base_of
    template <class Base, class Derived> struct is_base_of; 
	作用是 判断 Base 是否为 Derived 的基类
	
60  __attribute__((unused))  去除unused 报警
	在C程序中，如果定义了一个静态函数，而没有去使用，编译时会有一个告警：
	而使用attribute((unused))可以告诉编译器忽略此告警.
	
	
70  /dev/null 和 /dev/zero的区别
        1./dev/null:表示 的是一个黑洞，通常用于丢弃不需要的数据输出， 或者用于输入流的空文件
            1.1 将无用的输出流写入到黑洞丢弃。
                curl -Iwww.baidu.com 2>/dev/null | head -l  错误信息定位到黑洞
            1.2 清空文件     
                cat /dev/null > /home/omc/h.txt
            1.3 在书写定时任务总，规范的写法就是将所有定时任务脚本结尾加上>/dev/null 2>&1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃。
                00 01 * * * /bin/sh/server/scripts/mysqlbak.sh >/dev/null 2>&1
        2./dev/zero:当我们使用或者读取他的时候，她是会提供无限连续不断的空的数据流
            2.1覆盖其他的文件信息
            2.2产生指定大小的空文件，如交换文件，模拟虚拟文件系统   
			
71 3个文件描述符存在(0、１、2)；）0表示标准输入，1表示标准输出，2表示标准错误  描述符引用计数，为0时才关闭文件
	extern struct _IO_FILE *stdin;		/* Standard input stream.  */
	extern struct _IO_FILE *stdout;		/* Standard output stream.  */
	extern struct _IO_FILE *stderr;		/* Standard error output stream.  */	
	/* C89/C99 say they're macros.  Make them happy.  */
	#define stdin stdin
	#define stdout stdout
	#define stderr stderr
	
	#define	STDIN_FILENO	0	/* Standard input.  */
	#define	STDOUT_FILENO	1	/* Standard output.  */
	#define	STDERR_FILENO	2	/* Standard error output.  */
	
72 信号量 

#define	SIG_ERR	 ((__sighandler_t) -1)	/* Error return.  */
#define	SIG_DFL	 ((__sighandler_t)  0)	/* Default action.  */
#define	SIG_IGN	 ((__sighandler_t)  1)	/* Ignore signal.  */	
	

72 std::array

73 stdbool.h
   在支持C99标准中，新增了关键字_Bool，其值只能为0或1，这样只要导入 stdbool.h ，就能非常方便的使用我们常用的bool false true来操作布尔类型
   
74 #include_next
   例如有个搜索路径链，在#include中，它们的搜索顺序依次是A，B，C，D和E。在B目录中有个头文件叫a.h，在D目录中也有个头文件叫a.h，
   如果在我们的源代码中这样写#include <a.h>，那么我们就会包含的是B目录中的a.h头文件，如果我们这样写#include_next <a.h>
   那么我们就会包含的是D目录中的a.h头文件。#include_next <a.h>的意思按我们上面的引号包含中的解释来说就是“在B目录中的a.h头文件后面的目录路径（即C，D和E）
   中搜索a.h头文件并包含进来）。#include_next <a.h>的操作会是这样的，它将在A，B，C，D和E目录中依次搜索a.h头文件，那么首先它会在B目录中搜索到a.h头文件，
   那它就会以B目录作为分割点，搜索B目录后面的目录（C，D和E），然后在这后面的目录中搜索a.h头文件，并把在这之后搜索到的a.h头文件包含进来。这样说的话大家应该清楚了吧。

   还有一点是#include_next是不区分<>和""的包含形式的
   
75 lambda 表达式
  
   [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}
   1. [] (int x, int y) -> int { int z = x + y; return z; }
   2. [] 

    1.[var]表示值传递方式捕捉变量var；
    2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；
    3.[&var]表示引用传递捕捉变量var；
    4.[&]表示引用传递方式捕捉所有父作用域的变量（包括this）；
    5.[this]表示值传递方式捕捉当前的this指针

    1.[=,&a,&b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;
    2.[&,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量
    3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）

76 乱序执行(乱序执行译作异步执行更贴切)，是指在cpu中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执行，也许后面的指令先执行，
   当然，得保证指令之间不具备相关性
   
77 内存屏障(memory barrier)

78 asm volatile("" ::: "memory") 只是一个编译器障碍。

1）set_mb(),mb(),barrier()函数追踪到底，就是__asm____volatile__("":::"memory"),而这行代码就是内存屏障。
2）__asm__用于指示编译器在此插入汇编语句
3）__volatile__用于告诉编译器，严禁将此处的汇编语句与其它的语句重组合优化。即：原原本本按原来的样子处理这这里的汇编。
4）memory强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。这就阻止了cpu又将registers，cache中的数据用于去优化指令，而避免去访问内存。
5）"":::表示这是个空指令。barrier()不用在此插入一条串行化汇编指令。在后文将讨论什么叫串行化指令。
6）__asm__,__volatile__,memory在前面已经解释


79 __sync_synchronize()也是编译器屏障和完整内存屏障

80 锁
那么我们来温习下操作系统中5个知名的锁概念，每个技术都有适合自己的应用场景，此处引入介绍不再进一步深入展开。

1. 信号量(Semaphore)
Linux中的信号量是一种睡眠锁。如有一个任务试图获得一个已被持有的信号量时，信号量会将其推进等待队列，然后让其睡眠。当持有信号量的进程将信号量开释后，在等待队列中的一个任务将被唤醒，
从而便可以获得这个信号量。 信号量分为二元信号量和多元信号量，所谓二元信号量就是指该信号量只有两个状态，要么被占用，要么空闲;而多元信号量则允许同时被N个线程占有，
超出N个外的占用请求将被阻塞。信号量是“系统级别”的，即同一个信号量可以被不同的进程访问。
2.互斥量 (Mutex)
和二元信号量类似,不同的是互斥量的获取和释放必须是在同一个线程中进行的。如果一个线程不能去释放一个并不是它所占有的互斥量。而信号量是可以由其它线程进行释放的。
3.临界区(Critical Section)
把获取临界区的锁称为进入临界区，而把锁的释放称为离开临界区。Spinlock就是为了保护这临界区。
4. 读写锁(Read-Write Lock)
如果程序大部分时间都是在读取，使用前面的锁时，每次读也要申请锁的，会导致其他线程就无法再对此段数据进行同步读取。我们知道对数据进行读取时，不存在数据同步问题的，那么这些读锁就影响了程序的性能。
读写锁的出现就是为了解决这个问题的。
读写锁，有两种获取方式：共享(Shared)或独占 (Exclusive)。如果当前读写锁处于空闲状态，那么当多个线程同时以共享方式访问该读写锁时，都可以成功;而如果一个线程以独占的方式访问该读写锁，
那么它会等待所有共享访问都结束后才可以成功。在读写锁被独占的过程中，再次共享和独占请求访问该锁，都会进行等待状态。
5. 条件变量(Condition Variable)
条件变量相当于一种通知机制。多个线程可以设置等待该条件变量，一旦另外的线程设置了该条件变量(相当于唤醒条件变量)后，多个等待的线程就可以继续执行了。
以上是操作系统相关的几个概念，信号量也好互斥量也罢，只是不同的手段来实现资源的保护，实际还是根据真实应用需求的来选择。

81 Spinlock
我们来看下spinlock， spinlock叫做自旋锁，最初针对SMP系统，实现在SMP多处理器情况下临界区保护。
主要作用是给临界数据加锁，从而保护临界数据不被同时访问，实现多任务的同步。如果临界数据当前不可访问，那么就自旋直到可以访问为止。
自旋锁和互斥锁存在差异的是自旋锁不会引起调用者睡眠，如果自旋锁无法获取，那么调用者一直循环检测自旋锁直到释放。
spinlock的工作方式本身就体现了它的优缺点，优点是执行速度快，不涉及上下文切换；缺点是耗费CPU资源。
在Linux内核中，自旋锁通常用于包含内核数据结构的操作，可以看到在许多内核数据结构中都嵌入有spinlock，这些大部分就是用于保证它自身被操作的原子性（原子操作atomic operation为"不可被中断的一个或一系列操作"，最后其实是通过底层硬件来保证的），在操作这样的结构体时都经历这样的过程：上锁-操作-解锁。
因为在现代处理器系统中，考虑到中断、内核抢占以及其他处理器的访问，所以spinlock自旋锁应该阻止在代码运行过程中出现的其他并发干扰
	
82 Ctrl+C,操作系统就会向进程发送SIGINT信号
83 按下Ctrl+\（退出）,操作系统就会向进程发送SIGQUIT信号

84 c语言函数前置说明
  #include <stdio.h>

void func();

int func(int a, int b) {
    printf("%d\n", a + b);
    return 0;
}

int main() {
    func(3,5);
    return 0;
} // 不知道为什么这样可以。

85 信号的基本知识
1.信号本质:
信号的本质是软件层次上对中断的一种模拟。它是一种异步通信的处理机制，事实上，进程并不知道信号何时到来。
2.信号来源
(1)程序错误，如非法访问内存
(2)外部信号，如按下了CTRL+C
(3)通过kill或sigqueue向另外一个进程发送信号
3.信号种类
信号分为可靠信号与不可靠信号,可靠信号又称为实时信号，非可靠信号又称为非实时信号。
信号代码从1到32是不可靠信号,不可靠信号主要有以下问题:
(1)每次信号处理完之后，就会恢复成默认处理，这可能是调用者不希望看到的
(2)存在信号丢失的问题
现在的Linux对信号机制进行了改进，因此，不可靠信号主要是指信号丢失。
信号代码从SIGRTMIN到SIGRTMAX之间的信号是可靠信号。可靠信号不存在丢失，由sigqueue发送，可靠信号支持排队。
可靠信号注册机制:
内核每收到一个可靠信号都会去注册这个信号，在信号的未决信号链中分配sigqueue结构，因此，不会存在信号丢失的问题。
不可靠信号的注册机制:
而对于不可靠的信号，如果内核已经注册了这个信号，那么便不会再去注册，对于进程来说，便不会知道本次信号的发生。
可靠信号与不可靠信号与发送函数没有关系，取决于信号代码，前面的32种信号就是不可靠信号，而后面的32种信号就是可靠信号。
4.信号响应的方式
(1)采用系统默认处理SIG_DFL,执行缺省操作
(2)捕捉信号处理，即用户自定义的信号处理函数来处理
(3)忽略信号SIG_IGN ,但有两种信号不能被忽略SIGKILL，SIGSTOP

单线程中信号处理是中断正在执行的任务，响应信号处理函数，处理完后在继续中断的任务



86 前置申明
类或结构体的前向声明只能用来定义指针对象或引用，因为编译到这里时还没有发现定义，不知道该类或者结构的内部成员，没有办法具体的构造一个对象，所以会报错。
将类成员改成指针就好了。 程序中使用incomplete type实现前置声明有助与实现数据的隐藏。要求调用对象的程序段只能使用声明对象的引用或者指针。

87 无符号数3来说，x<<1往左移一位 0011 变成 0110 变成6了.

88    struct  str { int m;};    struct str * pst = malloc(sizeof(*pst));  //这也行??

89 C++中，临时对象都是const类型

90 
（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），
    又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，
    其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
（4）引用与一些操作符的重载：
     流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。
	 可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回 一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！
	 这无法让人接受。对于返回一 个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这 就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

100  ssize_t是有符号整型，在32位机器上等同与int，在64位机器上等同与long int
     size_t 就是无符号型的ssize_t
	 
101 EBNF，是一个计算机用语，意思是扩展的巴科斯范式。
    用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。
    扩展巴科斯-瑙尔范式(EBNF)是表达作为描述计算机编程语言和形式语言的正规方式的上下文无关文法的元语法符号表示法。
	它是基本巴科斯范式(BNF)元语法符号表示法的一种扩展。

102 https://www.boost.org/doc/libs/1_65_1/libs/spirit/example/   //查看example方法
    https://www.boost.org/doc/libs/1_65_1/libs/spirit/example/ 
	
103 https://www.boost.org/doc/libs/1_71_0/libs/spirit/example/qi/calc_utree.cpp  计算器解析
	 
104 通信协议——TLV

105 正交状态机
   正交状态机的意思是可能有多个初始状态，但是这些状态链是互不联系的，既不能从一个正交状态切换到另一个正交状态

106 有限状态机（Finite State Machine或者Finite State Automata)是软件领域中一种重要的工具

107 Linux中的0644 和 0755的权限
	0755->即用户具有读/写/执行权限，组用户和其它用户具有读写权限；
	0644->即用户具有读写权限，组用户和其它用户具有只读权限；
 	一般赋予目录0755权限，文件0644权限
	
108 FILE*fdopen(intfildes,constchar*mode);   //把流与一个文件句柄相接    FILE *f = fdopen(fd, "w+");
    fdopen 函数用于在一个已经打开的文件描述符上打开一个流，其第1个参数表示一个已经打开的文件描述符，第2个参数type的意义和fopen函数的第2个参数一 样。
    只有一点不同的是，由于文件已经被打开，所以fdopen函数不会创建文件，而且也不会将文件截短为0，这一点要特别注意

109 define SIZE_MAX		(18446744073709551615UL)

110 SA_RESTART用在为某个信号设置信号处理函数时，给该信号设置的一个标记。
    一般情况下 ，进程正在执行某个系统调用，那么在该系统调用返回前信号是不会被递送的。但慢速系统调用除外，如读写终端、网络、磁盘，以及wait和pause。这些系 统调用都会返回-1，
	errno置为EINTR当系统调用被中断时，我们可以选择使用循环再次调用，或者设置重新启动该系统调用 (SA_RESTART)。
    一旦给信号设置了SA_RESTART标记，那么当执行某个阻塞系统调用时，收到该信号时，进程不会返回，而是重新执行该系统调用。
	
	信号是异步的，它会在程序的任何地方发生。由此程序正常的执行路径被打破，去执行信号处理函数。
    一般情况下 ，进程正在执行某个系统调用，那么在该系统调用返回前信号是不会被递送的。但慢速系统调用除外，如读写终端、网络、磁盘，以及wait和pause。
	这些系 统调用都会返回-1，errno置为EINTR当系统调用被中断时，我们可以选择使用循环再次调用，或者设置重新启动该系统调用 (SA_RESTART)。
111 SIGINT
    程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程
	
112 在linux下，每个进程都有自己的signal mask，这个信号掩码指定哪个信号被阻塞，哪个不会被阻塞，通常用调用sigmask来处理。同时每个进程还有自己的signal action，  
    //https://www.cnblogs.com/coding-my-life/p/4782529.html
    这个行为集合指定了信号该如何处理，通常调用sigaction来处理。
    信号发生时，哪个线程会收到
    是不是每个线程都有自己的mask及action
    每个线程能按自己的方式处理信号么
　　 首先，信号的传递是根据情况而定的：
   
   如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。
   如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。
   如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，
   然后调用它来处理。(一般从主线程找起)，注意只有一个线程能收到。
   其次，每个线程都有自己独立的signal mask，但所有线程共享进程的signal action。这意味着，你可以在线程中调用pthread_sigmask(不是sigmask)来决定本线程阻塞哪些信号。
   但你不能调用sigaction来指定单个线程的信号处理方式。如果在某个线程中调用了sigaction处理某个信号，那么这个进程中的未阻塞这个信号的线程在收到这个信号都会按同一种方式处理这个信号。
   另外，注意子线程的mask是会从主线程继承而来的。


113 _Bool是C99新增加的关键字，长度是1

114  value optimized out 变量被编译优化掉了，看不到了


115  当我们编写了一个lambda之后，编译器将该表达式翻译成一个未命名类的未命名对象。该类含有一个重载的函数调用运算符

116 在类体之外定义const成员函数时，还必须加上const关键字

117 数字前缀
　　u或U 表示数字是无符号整型数，如：123u，但并不说明是长整型还是短整型 
   l或L 表示数字是长整型数，如：123l；而123ul就是无符号长整型数；而34.4l就是长双精度浮点数，等效于双精度浮点数 
   i64或I64 表示数字是长长整型数，其是为64位操作系统定义的，长度比长整型数长。如：43i64 
   f或F 表示数字是单精度浮点数，如：12.3f 
   e或E 表示数字的次幂，如：34.4e-2就是0.344；0.2544e3f表示一个单精度浮点数，值为254.4 
   当什么后缀都没写时，则根据有无小数点及位数来决定其具体类型，如：123表示的是有符号整型数；而34.43表示双精度浮点数。 
   为什么要搞这么多事出来，还分什么有符号无符号之类的？这全是因为电脑并非基于数字的，而是基于状态的，详情在下篇中将详细说明。
   作为科学计算，可能经常会碰到使用非十进制数字，如16进制、8进制等，C++也为此提供了一些前缀以进行支持。
   在数字前面加上0x或0X表示这个数字是16进制表示的，如：0xF3Fa、0x11cF。而在前面加一个0则表示这个数字是用8进制表示的，如：0347，变为十进制数就为231。
   但16进制和8进制都不能用于表示浮点数，只能表示整型数，即0x34.343是错误的

118 枚举类型 枚举值可以直接转换成int
    c中 int 能直接转换成枚举值
    c++ 中 int 不能直接转换成枚举值，需要强制转换

119 #include <new>  
    std::nothrow 在内存不足时，new (std::nothrow)并不抛出异常，而是将指针置NULL。
    Task * ptask = new (std::nothrow) Task;  
    if (!ptask)  {  
        std::cerr<<"allocation failure!";  
        std::exit(1);  
    }

    #include <new>                              // std::nothrow

120. MVC模式 
    MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，
    是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，
    在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间

121. value_type  每个STL中的类都有value_type这种东西，通俗的说value_type 就是stl容器盛装的数据的数据类型
	
122. 标准库类型(library type)ptrdiff_t 与 size_t 类型一样,ptrdiff_t 也是一种与机器相关的类型,在 cstddef 头文件中定义。
     size_t 是unsigned 类型,而 ptrdiff_t 则是 signed 整型
     ptrdiff_t与difference_type区别，前面的是c++定义的标准，后面则是STL定义的

    int *a=new int(1);
    int *b=new int(2);
    ptrdiff_t result=a-b;
    cout<<a<<ends<<b<<ends<<result<<endl; //
    000F8F08
    000F8F38
    -12
    可以看出，2个指针相减等于（地址相减的值)/指针所指向的数据类型
    
123. ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，
     没有被收录在ISO-8859-1当中。 因为ISO-8859-1编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流
     都不会被抛弃。换言之，把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题。这是个很重要的特性，MySQL数据库默认编码是Latin1就是利
     用了这个特性。ASCII编码是一个7位的容器，ISO-8859-1编码是一个8位的容器

124. 宽字符wchar_t  占用两个字节  const char * str = L"hello world"

125. 匿名结构体， 匿名联合 brpc->safe_sprintf.h
    union {
    struct {
      int64_t       i;
      unsigned char width;
    };
    const char* str;
    const void* ptr;
  };

126. std::numeric_limits<T>::max()，min()及lowest()

127 ArraySizeHelper     :::brpc->macros.h
    namespace butil {
    template <typename T, size_t N>
    char (&ArraySizeHelper(T (&array)[N]))[N];
    }

128. sizeof是C/C++语言中的keyword，不是函数。对其参数里的表达式是不会在执行期去执行的，而只是在编译期去推算整个表达式的最后的类型信息。
　　比如： int a = 1; sizeof(a++); cout << a;   // a还是1. 不会是2；

129. 
    返回值为数组指针T (*)[N] ::: T (* Foo( param_list ) )[N];
    返回值为数组引用T (&)[N] ::: T (& Foo( param_list ) )[N];

130. template< typename T, size_t N>
     void Fun( T (&)[N] );
     这个模板里既有类型T，又有数值N；模板推导时，是根据Fun的实参来推导得到的。比如：
     int a[5];
     Fun(a); // 编译器经过推导就知道，T=int，N=5。注意这里的N能得到5，是因为Fun的参数声明决定的。
     这里Fun的参数是：数组引用

131. template <typename T, size_t N>
     char (&ArraySizeHelper(T (&array)[N]))[N];
    
132. 数组的引用,  (注意c++没有引用的数组)
     T (&)[N] (注意：有个括号)。比如：
　　 int a[5] = {0};
　　 int (&ra)[5] = a;  //这里ra就是一个对数组a的引用，其这个数组的大小也是5

133. sizeof(一个指针)和sizeof(一个数组)有很大区别
　　int a[5];
　　int *p = a;
　　int (*pa)[5] = &a;
　　// p和pa都是指针，但是指针的类型不同：p的类型是int*；pa的类型是int(*)[5]。
　　sizeof(p)        // = 4;
　　sizeof(a)        // = 20 = 5*sizeof(int)
　　sizeof(*p)       // = sizeof(int) = 4;
　　sizeof(pa)       // = 4;
　　sizeof(*pa)      // = sizeof(a) = 20;

134. try catch    // catch后面语句 "catch later" 会打印  
int func() {
    try {
        throw 1;
    }

    catch(...) {
        std::cerr << " e.what() " << '\n';
    }
    std::cout << "catch later" << std::endl;
    return 0;
}

135

1. 基础数据类型模型定义
C/C++仅仅定义基本数据类型的关系（字长：CHAR<=SHORT<=INT<=LONG），并没有严格定义它们的字长，根据编译器的不同实现，它们的字长表示也不同

LP64指的是LONG/POINTER字长为64位；
ILP64指的是INT/LONG/POINT字长为64位；
LLP64指的是LONGLONG/POINTER字长为64位；
ILP32指的是INT/LONG/POINTER字长为32位；
LP32指的是LONG/POINT字长是32位的，INT字长为16位。
2. 数据模型中数据类型的长度表
ILP32和LP32是32位平台上字长的数据模型，LP64、ILP64、LLP64是64位平台上字长的数据模型

TYPE           LP32    ILP32    LP64    ILP64    LLP64

CHAR           8        8        8        8        8

SHORT          16       16       16       16       16

INT            16       32       32       64       32

LONG           32       32       64       64       32

LONG LONG      64       64       64       64       64

POINTER        32       32       64       64       64 
3. 一些注意点
32位Windows采用的是ILP32数据模型，64位Windows采用LLP64数据模型。
32位的Linux/Unix使用ILP32数据模型，64位Linux/Unix使用LP64数据模型。
为了增加代码的移植性，打印无符号整形数，不管申明时是如何定义的，统一使用 %lu。
为了保证平台的通用性，代码中尽量不要使用long数据库型。
使用INT时也可以使用intptr_t来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台长度，比如：64位机器上长度为8字节，32位机器上长度为4字节。
编写代码时要尽量使用sizeof来计算数据类型的大小。
ssize_t和size_t分别是signsize_t和unsigned signed size of computer word size。它们也是表示计算机的字长，在32位机器上是int型，在64位机器上long型，从某种意义上来说它们等同于intptr_t和 uintptr_t。


136.  delete 
      C++11 中，可在想要 “禁止使用” 的特殊成员函数声明后加 “= delete”，而需要保留的加 "= default" 或者不采取操作

137   auto &h = 42;         // 错误：非常量引用的初始值必须为左值。
      const auto &j = 42;   //正确:常量引用可以绑定到字面值。

138   decltype
      有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。
      还有可能是函数的返回类型为某表达式的的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，
      它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值

139   模板元编程 <模板特化??>
      模版元编程完全不同于普通的运行期程序，它很独特，因为模版元程序的执行完全是在编译期，并且模版元程序操纵的数据不能是运行时变量，
      只能是编译期常量，不可修改，另外它用到的语法元素也是相当有限，不能使用运行期的一些语法，比如if-else，for等语句都不能用。
      因此，模版元编程需要很多技巧，常常需要类型重定义、枚举常量、继承、模板偏特化等方法来配合，因此编写模版元编程比较复杂也比较困难

139  std::numeric_limits<T>::radix
     std::numeric_limits<T>::radix 的值是用于表示该类型的数字系统的底。对于所有二进制数值类型为 2 ，
     但它可以，譬如对 IEEE 754 十进制浮点类型或第三方二进制编码十进制整数为 10 。此常量对所有特化有意义。

140  内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当
     对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性

141  使用const提高程序的健壮性和效率

142  顶层const：不可以改变指向，但是可以改变指向的内容的值。 非顶层cosnt：可以改变指向，但是不可以改变指向的内容

143  __attribute__((warn_unused_result))    判断函数返回值

145  //传入的参数是数组的引用，返回值也是数组的引用
    string (&fun(string (&s)[10]))[10]{
        return s;
    }
146  template<int N>
     void fun(int(&a)[N]);
     如果只要传固定大小的数组，可以把template去掉，N改成大小

     /////  int (&fun(int (&i)[10])) [10];

147  tid是线程在内核态的id，而pthread_selft是线程在用户态的id（posix pthread id)

148  std::string::npos
     static const size_t npos = -1

149  C++二进制文件读取ios::binary
     在C++读取文件时，如果打开方式不显示加上ios::binary标记的话，默认文本模式的。当使用read函数读取一定量的字符时，
     如果这些字符里包含非Ascii码（> 127），读取就会失败。此外，还有和平台相关的换行符带来的问题

150 宏的定义是编译器先展开宏再编译的，也就是说，编译器会事先把出现宏的地方全部替换掉，所以定义他们的先后顺序就无关紧要了

151 
    OO ：Object Oriented ，支持多态这一强大的设计机制，需要付出的代价便是额外的间接性（virtual机制）。
    OB ：Object Based ，非多态的数据封装模型，就是ADT（Abstract Data Type）的概念，
        和OO相比拥有更快的速度而且空间更紧凑（因为不需要virtual）

152  assert在程序的release版本中仍然有效（不要与VC中的ASSERT混淆），要使assert失效，
     只有在包含assert头文件（assert.h）的语句前定义NDEBUG宏或在编译器参数中添加-DNDEBUG参数

153  inline
inline void FuncA(_T para) {
   FuncB(para, para+1);
}

void FuncB(_T paraA, _T paraB) {

}

至于 整个FuncB也会被展开塞进代码里？
这是函数FuncB 会不会内联的问题，和函数FuncA 没有任何关系
可以内联的话 FuncB 被内联进 FuncA
编译器对内联成功的代码，自然不会还原成函数调用了
FuncB不可以内联，那么 FuncA 就被内联成对FuncB函数调用
FuncB可以内联 那么内联 FuncA 就被已经内联到FunA的内部FuncB内内联后的代码取代了,
也就是 FuncB，FuncA 都内联了
注意到FuncB 没有inline
所以不是一定会内联的，所以就看编译器心情了（设定了），
即便很容易内联，因为没有指定，所以就不确定了

154  多级指针const
    void func(const int ** arg) {
    }
int main(int argc, char **argv) {
    int **p;
    func(p);
    return 0;
}
// gcc 编译报错
const int ** p1;  // int元素不可修改
int * const * p2; // int *一级指针不可修改
int ** const p3;  // int **二级指针不可修改

155  ## 是简单的连接符，#@用来给参数加单引号，#用来给参数加双引号即转成字符串

156  __FILE__    //根据编译时给的路径赋值

157  #define list_entry(ptr, type, member) / 
     ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))

158   __attribute__ ((__packed__))
      不想要字节对齐的时候，有没有办法取消字节对齐？答案是可以，就是在结构体声明当中，
      加上__attribute__ ((__packed__))关键字，它可以做到让我们的结构体，按照紧凑排列的方式，占用内存
      数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，
      以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行

159  memset() 和 {0} 的区别
     {0} 可能有移植性问题，虽然绝大多数编译器看到{0} 都是将数组全部初始化为0， 但是不保证所有编译器都是这样实现的

160  constexpr
        const并未区分出编译期常量和运行期常量
        constexpr限定在了编译期常量
        
        C++11中的constexpr指定的函数返回值和参数必须要保证是字面值，而且必须有且只有一行return代码，
        这给函数的设计者带来了更多的限制，比如通常只能通过return 三目运算符+递归来计算返回的字面值。
        而C++14中只要保证返回值和参数是字面值就行了，函数体中可以加入更多的语句，方便了更灵活的计算
        链接：https://www.jianshu.com/p/34a2a79ea947

161  模板会进行类型推倒
        class A {
            public:
                template<typename T, class CB>
                static void func(const std::string &name, T *first, T *last, CB callback) {
                    std::cout << "hello world" << std::endl;
                    callback();
                    return ;
                }
        };
    
        int main() {   
            int arr[10] = {0};
            A::func("hello", arr, arr + 10, [](void){
                std::cout << "hello world" << std::endl;
            });
            return 0;
        }

162  std::function对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较

163  成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。
     因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了
    
# 164  C++中，如果要在一个类A的声明中用到另一个类B的指针或引用，需要包含类B的头文件，如果不想包含，可以使用向前声明。
#     但是，如果是结构体（struct定义的），好像不支持向前声明，C++中类和结构体差别不大，只是默认权限不同
#     （class默认为私有，struct默认为公有），所以如果想使用向前声明，请使用class定义类型。
#     但是如果类A的声明中用到类B的对象，则必须包含类B的头文件，向前声明无效

165  简单来说，前置声明最大的好处就是『节省编译时间』
     需要的是前置声明xxxPrivate/xxxImpl类，而不是前置声明xxx类

166 C和C ++在表面上相似，但每个编译成一组非常不同的代码。当您使用C ++编译器包含头文件时，编译器需要C ++代码。但是，
    如果它是一个C头，则编译器需要将头文件中包含的数据编译为某种格式--C ++'ABI'或'应用程序二进制接口'，因此链接器会扼杀。
    这比将C ++数据传递给期望C数据的函数更可取。（为了深入了解真正的细节，C ++的ABI通常会“破坏”它们的函数/方法的名称，
    所以在printf()不将原型标记为C函数的情况下进行调用_Zprintf，C ++实际上会生成代码调用，最后加上额外的废话。 ）
    所以：extern "C" {...}当包括ac头时使用- 就这么简单。否则，您将在编译的代码中出现不匹配，并且链接器将会阻塞。
    但是，对于大多数标头，您甚至不需要它，extern因为大多数系统C标头已经考虑到它们可能包含在C ++代码中并且
    已经包含extern它们的代码

167 初始化数组时可以用{0}， 结构体用{0}只是初始化了部分，是部分初始化， 可以用{} 初始化 ?? 好像也不太行

168 std::future可以从异步任务中获取结果，一般与std::async配合使用，std::async用于创建异步任务，实际上就是创建一个线程执行相应任务。　　

   std::async会首先创建线程执行is_prime(700020007)， 任务创建之后，std::async立即返回一个std::future对象。
   主线程既可使用std::future::get获取结果，如果调用过程中，任务尚未完成，则主线程阻塞至任务完成。
   主线程也可使用std::future::wait_for等待结果返回，wait_for可设置超时时间，如果在超时时间之内任务完成，则返回std::future_status::ready状态；
   如果在超时时间之内任务尚未完成，则返回std::future_status::timeout状态。

169      container_of
         #define container_of(ptr, type, member) ({             /
         const typeof( ((type *)0)->member ) *__mptr = (ptr);     /
         (type *)( (char *)__mptr - offsetof(type,member) );})
         
        #define offsetof(TYPE, MEMBER) ((size_t)&((TYPE*)0)->MEMBER)
        
        struct test_struct {
            int num;
            char ch;
            float fl;
        };
        
        struct test_struct init_test_struct = { 99, 'C', 59.12 };
        char *char_ptr = &init_test_struct.ch;
        struct test_struct *test_struct = container_of(char_ptr, struct test_struct, ch);
        printf(" test_struct->num = %d\n test_struct->ch = %c\n test_struct->fl = %f\n", 
            test_struct->num, test_struct->ch, test_struct->fl);

170  typeof  
    下面这两个等效声明,用于声明int类弄的变量a
    typeof(int) a;
    typeof('b') a; //相当于获取'b'的类型,定义一个变量
    int my_atoi(const char *str)
    typeof( my_atoi(str2)) sum = 100;   //相当于等同去int sum;
    如果将typeof用于表达式,则该表达式不会执行,只会得到表达式的类型

171  std::promise
#include <iostream>
#include <future>
#include <chrono>
void Thread_Fun1(std::promise<int> &p) {
	//为了突出效果，可以使线程休眠5s
	std::this_thread::sleep_for(std::chrono::seconds(5));
	int iVal = 233;
	std::cout << "传入数据(int)：" << iVal << std::endl;
	//传入数据iVal
	p.set_value(iVal);
}
void Thread_Fun2(std::future<int> &f) {
	//阻塞函数，直到收到相关联的std::promise对象传入的数据
	auto iVal = f.get();		//iVal = 233
	std::cout << "收到数据(int)：" << iVal << std::endl;
}
int main()
{
	//声明一个std::promise对象pr1，其保存的值类型为int
	std::promise<int> pr1;
	//声明一个std::future对象fu1，并通过std::promise的get_future()函数与pr1绑定
	std::future<int> fu1 = pr1.get_future();
	//创建一个线程t1，将函数Thread_Fun1及对象pr1放在线程里面执行
	std::thread t1(Thread_Fun1, std::ref(pr1));
	//创建一个线程t2，将函数Thread_Fun2及对象fu1放在线程里面执行
	std::thread t2(Thread_Fun2, std::ref(fu1));
	//阻塞至线程结束
	t1.join();
	t2.join();
	return 1;
}
 可以看到std::future对象fu1先是通过std::promise的函数get_future()与std::promise对象pr1相绑定，
 pr1在线程t1中通过set_value()传入共享数据，fu1在线程t2中通过阻塞函数get()获取到传入的数据


 172  经常看到ContextImpl类继承了Context类。
      ContextImpl Impl是代表什么含义，表示是Context的继承类才这样命名的吗？
      这是 接口 和 实现类的方式
      ContextImpl 就是接口的实现类，Context是一个抽象类
    
173  抽象类构造函数

1.
    虽然抽象类不能被实例化，但是抽象类的派生类将所有虚函数都实现的话，派生类可以实例化，此时派生类的实例化会用到系统默认给抽象类合成
    的构造函数。因此，抽象类有构造函数，但是不能实例化
2.
    有用的话就需要。你不写编译器也会给你生成一个。抽象类的构造函数当然有用（如果其实你想问的是这个的话）。
    一个是构造函数一定会被调用到（构造函数的调用是逐级的，不是只调用叶子类的构造函数。另一个，有时候抽象类的基类也可以是非抽象类。
    这时候构造函数的作用之一就是从非抽象的派生类传递调用给非抽象（当然也有抽象的）的基类

174 异常　throw
        1. 指定异常
        T   funNname（ parameterlist ） throw（ T1， T2，····，Tn）；
        其中 T 是类型， parameterlist 是参数列表， 而类型 T1， T2，····，Tn 是函数会抛出的异常。

        2. 不抛出异常
        T   funNname（ parameterlist ） throw（ ）；
    
175 std::chrono::duration   std :: chrono :: duration基于秒
    template<class _Rep, class _Period = ratio<1> > class duration
    第一个参数_Rep代表用什么样的类型来保存这个时间长度，必须是内置数值型或者是功能上类似内置数值型的类型(这个没有试过，应该是提供内置类型的所有接口就可以)。
    第二个参数_Period必须是std::ration模板类的一个实例，代表一个时间单位。_Period缺省值为std::ration<1>，
    此时它的单位为秒。它只有一个成员变量，用于保存_Period的个数

    duration<int, std::milli>代表以int保存的，单位为1/1000秒(毫秒)的时间长度。duration<int, std::milli> d(5)，则d代表5毫秒。
    duration<short, std::ratio<1,50>>代表以short保存的，单位为1/50秒的时间长度。duration<short, std::ratio<1,50>> d(50)，则d代表1秒

    chrono::duration<int,ratio<60>> two_minutes(2);
    chrono::duration<int,ratio<1,1000>> two_milliseconds(2);
    chrono::duration<int,ratio<60 * 60 * 24>> two_days(2);

176 chrono中有三种时钟：system_clock，steady_clock和high_resolution_clock

178 指针数组　new int *[4]

179 C++语言本身或标准程序库所抛出的所有异常，都派生自基类exception。

（1）语言本身所支持的异常

bad_alloc：new操作失败会抛出。
bad_cast：执行期间加在一个引用上面的动态性型别转换操作失败时抛出。
bad_typeid：执行RTTI时，交给typeid的参数为零或空指针时抛出
bad_exception：非预期的异常

C++标准程序库发出的异常
2）C++标准程序库发出的异常
总是派生自logic_error。逻辑错误是由于程序内部逻辑而导致的错误。逻辑错误是可以避免的，且在程序开始执行之前，能够被检测到。
错误分类解释及举例：
domain_error：专业领域内的范畴 invalid_argument：无效参数，比如讲bitset以char而非0或1进行初始化 length_error：可能超越了最大极限，
比如对着某个字符串附加太多字符。 out_of_range：参数不再预期范围内。例如在诸如array的容器或字符串string中采用一个错误索引。

3）程序作用域之外发出的异常
总是派生自runtime_error，用来指出“不在程序范围内，且不容易回避”的事件。此类错误只在程序执行时才是可检测的。C++标准库中的定义如下：
range_error：内部计算时发生区间错误
overflow_error：算数运算时发生上溢
underflow_error：算数运算时发生下溢

180 std::is_class是类模板。用于判断某个类型是否是一个类类型（联合不是类类型）
    std::is_union是类模板。用于判断某个类型是否是一个联合类型。
    
    integral_constant是一个用于包装目的的类

190  模板类友好类 template<class, class> friend class Reducer

191  const_cast< >

192  std::launch::async，那么就是声明的时候就回去创建新的线程 系统默认使用的就是这个参数


https://blog.csdn.net/qq_40666620/article/details/102639505

193  std::defer_lock调用std::unique_lock 的构造函数，锁不会自动锁定

194 try_lock()
    尝试给互斥量加锁，如果拿不到锁，返回false,如果拿到了锁，返回true,这个函数是不阻塞的

195  条件变量必须在获得锁权限后才能调用notify();

196  编译动态库时如果有依赖其他动态库，只需要依赖库的头文件即可。

197  把数组定义为一个类型，这样函数传值时相当于传送地址了。  typedef struct __jmp_buf_tag jmp_buf[1];

198  骚操作001
            struct people {
                int id;
                char name[1];
            };
            struct people * a = malloc(sizeof(struct people) + 7);
            a->id = 0;
            sprintf(&a->name,"Poly000");

199 内存对齐
    内存对齐是操作系统为了快速访问内存而采取的一种策略。那么为什么要内存对齐呢？因为处理器读写数据，并不是以字节为单位，而是以块(2,4,8,16字节)为单位进行的，
    而且由于操作系统的原因，块的起始地址必须整除块大小。如果不进行对齐，那么本来只需要一次进行的访问，可能需要好几次才能完成，并且还要进行额外的数据分离和合并，
    导致效率低下。更严重地，有的CPU因为不允许访问unaligned address，就报错，或者打开调试器或者dump core，比如sun sparc solaris绝对不会容忍你访问unaligned address，
    都会以一个core结束你的程序的执行。所以一般编译器都会在编译时做相应的优化以保证程序运行时所有数据地址都是在'aligned address'上的，这就是内存对齐的由来。
    为了更好理解上面的意思，这里给出一个示例。在32位系统中，假如一个int变量在内存中的地址是0x00ff42c3,因为int是占用4个字节，所以它的尾地址应该是0x00ff42c6，
    这个时候CPU为了读取这个int变量的值，就需要先后读取两个4字节的块，分别是0x00ff42c0~0x00ff42c3和0x00ff42c4~0x00ff42c7，然后通过移位等一系列的操作来得到，
    在这个计算的过程中还有可能引起一些总线数据错误的。但是如果编译器对变量地址进行了对齐，比如放在0x00ff42c0，CPU就只需要一次就可以读取到，这样的话就加快读取效率。
    综合，内存对齐的原因有2点：
        (1) 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
        (2) 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要至少要两次内存访问；而对齐的内存访问仅需要一次访问

200 emplace_back()和push_back()的区别
            emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，
            然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，
            则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
            为了让大家清楚的了解它们之间的区别，我们创建一个包含类对象的 vector 容器，如下所示：
            #include <vector> 
            #include <iostream> 
            using namespace std;
            class testDemo
            {
            public:
                testDemo(int num):num(num){
                    std::cout << "调用构造函数" << endl;
                }
                testDemo(const testDemo& other) :num(other.num) {
                    std::cout << "调用拷贝构造函数" << endl;
                }
                testDemo(testDemo&& other) :num(other.num) {
                    std::cout << "调用移动构造函数" << endl;
                }
            private:
                int num;
            };
            int main()
            {
                cout << "emplace_back:" << endl;
                std::vector<testDemo> demo1;
                demo1.emplace_back(2);  
                cout << "push_back:" << endl;
                std::vector<testDemo> demo2;
                demo2.push_back(2);
            }
            运行结果为：
            emplace_back:
            调用构造函数
            push_back:
            调用构造函数
            调用移动构造函数

201     malloc
        Windows里malloc时，操作系统分配内存时会在分配的内存前面多分配20个字节，其中前16个字节用于内存管理时使用，后4个字节用于标识内存边界。
        分配空间后面也会有4个字节用于标识边界。
        如malloc分配一个n字节的空间，实际的内存为
        返回的指针指向如下内存段的首地址
        |16个字节的内存管理信息|4字节边界|n字节的空间|4字节边界|
        这里的第5个字节到第8字节是一个4字节整形，记录着内存空间的大小
        这也就解释了为什么我们可以malloc一个0字节的空间，也能正常返回指针

        机64位机,只要malloc传的参数小于24(包括0) 则分配24字节，不同机器可能会有出入 若大于24字节, 例如1000,则分配1000或者1000大一点预分配内存

202 is_arithmetic    检查类型是否为算术类型   //muduo
class A {};
 
int main()
{
    std::cout << std::boolalpha
        << "A:           " << std::is_arithmetic_v<A>           << '\n' // false
        << "bool:        " << std::is_arithmetic_v<bool>        << '\n' // true
        << "int:         " << std::is_arithmetic_v<int>         << '\n' // true
        << "int const:   " << std::is_arithmetic_v<int const>   << '\n' // true
        << "int &:       " << std::is_arithmetic_v<int&>        << '\n' // false
        << "int *:       " << std::is_arithmetic_v<int*>        << '\n' // false
        << "float:       " << std::is_arithmetic_v<float>       << '\n' // true
        << "float const: " << std::is_arithmetic_v<float const> << '\n' // true
        << "float &:     " << std::is_arithmetic_v<float&>      << '\n' // false
        << "float *:     " << std::is_arithmetic_v<float*>      << '\n' // false
        << "char:        " << std::is_arithmetic_v<char>        << '\n' // true
        << "char const:  " << std::is_arithmetic_v<char const>  << '\n' // true
        << "char &:      " << std::is_arithmetic_v<char&>       << '\n' // false
        << "char *:      " << std::is_arithmetic_v<char*>       << '\n' // false
        ;
}

203 O_NONBLOCK和O_NDELAY所产生的结果都是使I/O变成非搁置模式(non-blocking)，在读取不到数据或是写入缓冲区已满会马上return，
   而不会搁置程序动作，直到有数据或写入完成。它们的差别在于设立O_NDELAY会使I/O函式马上回传0，但是又衍生出一个问题，因为读取到档案结尾时所回传的也是0，
   这样无法得知是哪中情况；因此，O_NONBLOCK就产生出来，它在读取不到数据时会回传-1，并且设置errno为EAGAIN。不过需要注意的是，在GNU C中O_NDELAY只是为了与BSD的程序兼容，
   实际上是使用O_NONBLOCK作为宏定义，而且O_NONBLOCK除了在ioctl中使用，还可以在open时设定

   O_NOCTTY如果路径名指向终端设备，不要把这个设备用作控制终端
   对于串口的打开操作，必须使用O_NOCTTY参数，它表示打开的是一个终端设备，程序不会成为该端口的控制终端。如果不使用此标志，任务的一个输入(比如键盘终止信号等)都会影响进程

204 栈  ：先进后出（LIFO-last in first out） 仅允许在表的一端进行插入和删除运算
    队列：先进先出（FIFO-first in first out）
    数组元素与栈的增长方向：C与C++语言规范都规定了数组元素是分布在连续递增的地址上
    C与C++语言的数组元素要分配在连续递增的地址上，也不反映栈的增长方向。
    void test(char *para1，char *param2，char *param3, char *param4) {} 
    在linux中，栈由高地址往低地址生长,调用test函数时，其参数入栈情况如下 函数参数是以栈的形式存取，从右至左入栈
    ---------- 0xffffffff
    | 其他内存 |
    ----------  栈底
    | param4  |
    ----------
    | param3  |
    ----------
    | param2  |
    ----------
    | param1  |
    ----------
    | list    |
    ----------  栈顶
    | 其他内存 |
    ----------  0

va_start宏，获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）：
#define va_start(list,param1)   ( list = (va_list)&param1+ sizeof(param1) )
va_arg宏，获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）：
#define va_arg(list,mode)   ( (mode *) ( list += sizeof(mode) ) )[-1]
va_end宏，清空va_list可变参数列表：
#define va_end(list) ( list = (va_list)0 )
#include <stdio.h> 
 
//获取参数列表中的所有参数，并打印
void PrintInt(int cnt, ...) 
{ 
  int *temp = &cnt;
  temp++;
  for (int i = 0; i < cnt; ++i) 
  { 
    printf("%d\n", *temp); 
    temp++; 
  } 
}
 
int main(void)
{
    int a = 1; 
    int b = 2; 
    int c = 3; 
    int d = 4;
    PrintInt(4, a, b, c, d); 
    return 0;
}
执行程序后输出： 
1
2
3
4



205.  悬垂引用
    std::vector<std::string> v;
    v.push_back("hello");
    std::string &x = v[0];

    首先必须明白空悬指针是针对动态内存来说明的：

eg：p=new int ;
delete p;
当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多及其上指针仍保留着（已经释放了的）动态内存的地址。在delete之后，
指针就变成了人们所说的空悬指针，即，指向一块曾经保存数据对象但现在已经无效的内存的指针。
未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题：在指针即将要理考其作用域之前释放掉它所关联的内存。
这样，在指针关联的内存被释放后，就没有机会使用指针了。如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就可以清楚地指出指针不指向任何对象


206  typedef struct __jmp_buf_tag jmp_buf[1];

207 比特序(bit order) 
    字节序是一个对象中的多个字节之间的顺序问题，比特序就是一个字节中的8个比特位(bit)之间的顺序问题。一般情况下系统的比特序和字节序是保持一致的

208  do while{0}
    1. 隔离环境.(如变量，if语句)
    2. 可以使用break语句。

209  对于C++11的6种并发查了不少相关资料，这里作一个总结和理解
std::memory_order_relaxed,std::memory_order_consume,std::memory_order_acquire
std::memory_order_release,std::memory_order_acq_rel,std::memory_order_seq_cst

relaxed的内存序：
没有顺序一致性的要求，也就是说同一个线程的原子操作还是按照happens-before关系，但不同线程间的执行关系是任意

sequential consistency(内存一致性)
这个是以牺牲优化效率，来保证指令的顺序一致执行，相当于不打开编译器优化指令，按照正常的指令序执行(happens-before)，多线程各原子操作也会Synchronized-with，
（譬如atomic::load()需要等待atomic::store()写下元素才能读取，同步过程），当然这里还必须得保证一致性，读操作需要在“一个写操作对所有处理器可见”的时候才能读，
适用于基于缓存的体系结构。

acquire-release 获取-释放一致性
这个是对relaxed的加强，relax序由于无法限制多线程间的排序，所以引入synchronized-with，但并不一定意味着，统一的操作顺序

memory_order_consume
这个内存序是 “获取-释放”的一部分，它依赖于数据，可以展示线程间的先行关系。
携带依赖

210. atomic_load_explicit（const volatile A * obj，memory_order order）;
以原子方式加载并返回指向的原子变量的当前值obj。该操作是原子读取操作。
第一个版本根据命令对内存进行访问memory_order_seq_cst，第二个版本根据内存访问内存访问order。order必须是一个memory_order_relaxed，memory_order_consume，
memory_order_acquire或memory_order_seq_cst。否则，行为是不确定的。
这是为所有原子对象类型定义的通用函数A。该参数是指向易失性原子类型的指针，以接受非易失性和易失性（例如内存映射I/O）原子变量的地址。C是与之对应的非原子类型A。
obj    指向要访问的原子对象的指针
order  此操作的内存同步排序

210. __restrict
要理解 restrict，先要知道什么是 Pointer aliasing。
Pointer aliasing 是指两个或以上的指针指向同一数据，例如
int i = 0;
int *a = &i;
int *b = &i;
这样会有什么问题呢？
如果编译器采用最安全的假设，即不理会两个指针会否指向同一数据，那么通过指针读写数据是很直观的。
然而，这种假设会令编译器无法优化，例如：
int foo(int *a, int *b)
{
    *a = 5;
    *b = 6;
    return *a + *b; // 不一定是 11！
}
如果 a 和 b 都指向同一数据，*b = 6 会导致 *a = 6，返回12。所以编译器在做 *a + *b 的时候，需要重新读取 *a 指向的数据：
foo:
    movl    $5, (%rdi)    # 存储 5 至 *a
    movl    $6, (%rsi)    # 存储 6 至 *b
    movl    (%rdi), %eax  # 重新读取 *a （因为有可能被上一行指令造成改变）
    addl    $6, %eax      # 加上 6
    ret
如果我们确保两个指针不指向同一数据，就可以用 restrict 修饰指针类型：
int rfoo(int *restrict a, int *restrict b)
{
    *a = 5;
    *b = 6;
    return *a + *b;
}
编译器就可以根据这个信息，做出优化：
rfoo:
    movl      $11, %eax   # 在编译期已计算出 11
    movl      $5, (%rdi)  # 存储 5 至 *a
    movl      $6, (%rsi)  # 存储 6 至 *b
    ret

但如果用了 restrict 去修饰两个指针，而它们在作用域内又指向同一地址，那么是未定义行为。
总括而言，restrict 是为了告诉编译器额外信息（两个指针不指向同一数据），从而生成更优化的机器码。注意，编译器是无法自行在编译期检测两个指针是否 alias。如使用 restrict，
程序员也要遵守契约才能得出正确的代码（指针不能指向相同数据）。
以个人经验而言，编写代码时通常会忽略 pointer aliasing 的问题。更常见是在性能剖测时，通过反编译看到很多冗余的读取指令，才会想到加入 restrict 关键字来提升性能。

211. DAG(Direct Acyclic Graph)中文名叫有向无环图，按照数学上的定义，DAG是一个没有有向循环的、有限的有向图

212. 
// %.*s 其中的.*表示显示的精度 对字符串输出(s)类型来说就是宽度
// 这个*代表的值由后面的参数列表中的整数型(int)值给出
// 例如：
printf("%.*s\n", 1, "abc");        // 输出a
printf("%.*s\n", 2, "abc");        // 输出ab
printf("%.*s\n", 3, "abc");        // 输出abc >3是一样的效果 因为输出类型type = s，遇到'\0'会结束

213. uninitialized_var    变量没有初始化。
这个宏的定义如下：
#define uninitialized_var(x) x = x
可以看到是将自己赋值给自己，这样就消除了没有初始化的警告

214.  如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），
      就需要新的机制来实现。这就是TLS。

215. memory_order_relaxed 
    只保证当前操作的原子性，不考虑线程间的同步，其他线程可能读到新值，也可能读到旧值。比如 C++ shared_ptr 里的引用计数，我们只关心当前的应用数量，
    而不关心谁在引用谁在解引用

    没有顺序一致性的要求，也就是说同一个线程的原子操作还是按照happens-before关系，但不同线程间的执行关系是任意。
    由于Relaxed ordering 仅仅保证load()和store()是原子操作，除此之外，不提供任何跨线程的同步。
    如果某个操作只要求是原子操作，除此之外，不需要其它同步的保障，就可以使用 Relaxed ordering。程序计数器是一种典型的应用场景：
    
216. 
        PTHREAD_DESTRUCTOR_ITERATIONS     线程退出时操作系统实现试图销毁线程特定数据的最大次数    _SC_THREAD_DESTRUCTOR_ITERATIONS
        PTHREAD_KEYS_MAX                  进程可以创建的键的最大数目                          _SC_THREAD_KEYS_MAX
        PTHREAD_STACK_MIN                 一个线程的栈可用的最小字节数                         _SC_THREAD_STACK_MIN
        PTHREAD_THREADS_MAX               进程可以创建的最大线程数                            _SC_THREAD_THREADS_MAX
        原文链接：https://blog.csdn.net/yzhang6_10/article/details/51994346

217. thread_local变量是C++ 11新引入的一种存储类型。它会影响变量的存储周期(Storage duration)
     有且只有thread_local关键字修饰的变量具有线程周期(thread duration)，这些变量(或者说对象）在线程开始的时候被生成(allocated)，
     在线程结束的时候被销毁(deallocated)。并且每 一个线程都拥有一个独立的变量实例(Each thread has its own instance of the object)。
     thread_local 可以和static 与 extern关键字联合使用，这将影响变量的链接属性(to adjust linkage)。

218. __thread是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。__thread变量每一个线程有一份独立实体，各个线程的值互不干扰。
     可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量
     Thread Local Storage 线程局部存储(tls)是一种机制,通过这一机制分配的变量,每个当前线程有一个该变量的实例

219. futex (fast userspace mutex) 
     是Linux的一个基础组件，可以用来构建各种更高级别的同步机制，比如锁或者信号量等等，POSIX信号量就是基于futex构建的。
     大多数时候编写应用程序并不需要直接使用futex，一般用基于它所实现的系统库就够了

  历史
    传统的SystemV IPC(inter process communication)进程间同步机制都是通过内核对象来实现的，以 semaphore 为例，当进程间要同步的时候，必须通过系统调用semop(2)
    进入内核进行PV操作。系统调用的缺点是开销很大，需要从user mode切换到kernel mode、保存寄存器状态、从user stack切换到kernel stack、等等，通常要消耗上百条指令。
    事实上，有一部分系统调用是可以避免的，因为现实中很多同步操作进行的时候根本不存在竞争，即某个进程从持有semaphore直至释放semaphore的这段时间内，
    常常没有其它进程对同一semaphore有需求，在这种情况下，内核的参与本来是不必要的，可是在传统机制下，持有semaphore必须先调用semop(2)进入内核去看看有没有人和它竞争，
    释放semaphore也必须调用semop(2)进入内核去看看有没有人在等待同一semaphore，这些不必要的系统调用造成了大量的性能损耗。

  futex设计思想
     futex的解决思路是：在无竞争的情况下操作完全在user space进行，不需要系统调用，仅在发生竞争的时候进入内核去完成相应的处理(wait 或者 wake up)。
     所以说，futex是一种user mode和kernel mode混合的同步机制，需要两种模式合作才能完成，futex变量必须位于user space，而不是内核对象，
     futex的代码也分为user mode和kernel mode两部分，无竞争的情况下在user mode，发生竞争时则通过sys_futex系统调用进入kernel mode进行处理
     futex的解决思路是：在无竞争的情况下操作完全在user space进行，不需要系统调用，仅在发生竞争的时候进入内核去完成相应的处理(wait 或者 wake up)。
     所以说，futex是一种user mode和kernel mode混合的同步机制，需要两种模式合作才能完成，futex变量必须位于user space，而不是内核对象，
     futex的代码也分为user mode和kernel mode两部分，无竞争的情况下在user mode，发生竞争时则通过sys_futex系统调用进入kernel mode进行处理
    链接：https://www.jianshu.com/p/d17a6152740c

220. __attribute__((always_inline))

221. 理想的同步机制应该是在没有锁冲突的情况下在用户态利用原子指令就解决问题，而需要挂起等待时再使用内核提供的系统调用进行睡眠与唤醒。
     换句话说，用户态的spinlock在trylock失败时，能不能让进程挂起，并且由持有锁的线程在unlock时将其唤醒？

222. 在Unix系统中，传统的进程间同步机制都是通过对内核对象操作来完成的，这个内核对象在需要同步的进程中都是可见的，进程间的同步是通过系统调用在内核中完成。
     这种同步方式因为涉及用户态和内核态的切换，效率比较低。而且只要使用了传统的同步机制，进入临界区时即使没有其他的进程竞争也必须切换到内核态来检查内核同步对象的状态，
     这种不必要的切换显然带来了大量的浪费

223.     extern int  __futex_wake_ex(volatile void *ftx, int pshared, int val);
         extern int  __futex_wait_ex(volatile void *ftx, int pshared, int val, const struct timespec *timeout);
         这两个函数比前面的多了一个参数pshared。pshared的值为true表示wake和wait操作是用于进程间的挂起和唤醒；值为false表示操作用于进程内线程的挂起和唤醒。
         当pshared的值为false时，执行Futex系统调用的操作码为:
         FUTEX_WAIT|FUTEX_PRIVATE_FLAG，
         FUTEX_WAKE|FUTEX_PRIVATE_FLAG

        这是linux / glibc完成的一项优化，可以在进程之间不共享futex时更快。除非在互斥锁上设置PTHREAD_PROCESS_SHARED属性，
        否则Glibc将使用每个futex调用的_PRIVATE版本

224. syscall()

一般情况下，用户进程是不能访问内核的。它既不能访问内核所在的内存空间，也不能调用内核中的函数。系统调用是一个例外。其原理是：
    (1)进程先用适当的值填充寄存器
    (2)然后调用一个特殊的指令
    (3)这个指令会让用户程序跳转到一个事先定义好的内核中的一个位置
    （4）进程可以跳转到的固定的内核位置。这个过程检查系统调用号，这个号码告诉内核进程请求哪种服务。然后，它查看系统调用表(sys_call_table)找到所调用的内核函数入口地址。接着，就调用函数，等返回后，做一些系统检查，最后返回到进程。

    内核提供用户空间程序与内核空间进行交互的一套标准接口，这些接口让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。用户空间发生请求，
    内核空间负责执行，这些接口便是用户空间和内核空间共同识别的桥梁，这里提到两个字“受限”，是由于为了保证内核稳定性，而不能让用户空间程序随意更改系统，
    必须是内核对外开放的且满足权限的程序才能调用相应接口。
    在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，
    只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于每个系统调用都会有一个对应的系统调用号，
    比很多操作系统要少很多。
    安全性与稳定性：内核驻留在受保护的地址空间，用户空间程序无法直接执行内核代码，也无法访问内核数据，通过系统调用
    性能：Linux上下文切换时间很短，以及系统调用处理过程非常精简，内核优化得好，所以性能上往往比很多其他操作系统执行要好

225. ：那就是在信号处理函数中不能调用非异步安全(asynchronous-safe)的函数，localtime不是一个异步安全函数。

226. 线程安全    :
     异步信号安全 :
     可重入      :
异步信号安全:
    诸如printf之类的标准库函数内部实现可能有个互斥锁，这个互斥锁是专门针对于IO缓冲区的，也就是说每个逻辑执行流要打印前(打印意味着要向缓冲区写入字符)都要获得锁，
    然后把要打印的内容输入缓冲区，最后释放互斥锁。
  解释:
    由于要在打印前获取互斥锁，所以在信号处理程序中调用printf可能要出现死锁：当前逻辑执行流调用printf，正好取得锁时，信号发生了，此时执行流不得不调用信号处理函数，
    正巧信号处理函数也要执行打印printf，同样要获取缓冲区控制锁，但是锁已经被自己先前lock了(这正是自己二次加锁死锁现象)，所以出现了死锁。
    同样这个也可以很好的解释为什么线程调用printf不会死锁，因为即使如果一个线程正加好锁发生线程切换，新来的线程要执行printf，但是发现缓冲区已锁，自己睡眠等待即可，
    不会出现死锁，到先前那个线程执行完打印后，自然会释放锁的。
  原文链接：https://blog.csdn.net/qq_44947859/article/details/89737666

227. 