1.查看端口信息: netstat -tnlp
netstat -anp | grep 8210

-a, --all, --listening     display all sockets (default: connected)
-n, --numeric              don't resolve names
-p, --programs             display PID/Program name for sockets
-l, --listening            display listening server sockets
-t                         选项列出 TCP 协议的连接：


2. locate sqlite3.so
是在后台数据库中按文件名搜索（也只能按文件名搜索），搜索速度较快
这个数据库的目录，不同的linux发行版不同，在centos6.10中，这个数据库的目录为：/var/lib/mlocate/mlocate.db
这个数据库默认一天一更新，所以一般新建的文件，如果不手动更新该数据库，在该天内是无法使用locate命令来查看文件位置的，更新该数据库的命令为：updatedb
模糊查找文
locate sqlite3.so

update db;


3.md5sum
md5sum libface_matcher.so ../x86/libface_matcher.so 

4. ldd
ldd fms_master | grep OpenCL

5文件拷贝
scp -r dev_restserver_20200609.tgz yanyan@192.168.0.36:
5.1 cp 
	 - r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名    ...cp -r ./project_run/ ./20200709bak

6 rar文件解压

rar x 文件名
unrar e file.rar //解压rar

7 tar文件解压

tar -xvf file.tar //解压 tar包
tar -xzvf file.tar.gz //解压tar.gz
tar -xjvf file.tar.bz2   //解压 tar.bz2
tar -xZvf file.tar.Z   //解压tar.Z

参数：
-c ：建立一个压缩文件的参数指令(create 的意思)；
-x ：解开一个压缩文件的参数指令！
-t ：查看 tarfile 里面的文件！ 特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。
-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？
-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？
-v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！
-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成『 tar -zcvPf tfile sfile』才对喔！
-p ：使用原文件的原来属性（属性不会依据使用者而变）
-P ：可以使用绝对路径来压缩！
-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！
--exclude FILE：在压缩的过程中，不要将 FILE 打包


unzip file.zip //解压zip
zip -r tmp.zip ./tmp/

压缩文件：
tar -cf all.tar *.jpg   -c是表示产生新的包，-f指定包的文件名。
tar -zcvf /home/xahot.tar.gz /xahot
tar -zcvf 打包后生成的文件名全路径 要打包的目录



8杀掉进程
sudo kill -9 20113
kill -s 9 1827


9查看进程

ps aux | grep python
-a 显示同一终端下的所有程序
-u 指定用户的所有进程
-aux 显示所有包含其他使用者的行程


USER ：进程的所属用户，
PID ：进程的进程ID号， 
%CPU ：进程占用的 CPU资源 百分比，
%MEM ：进程占用的 物理内存 百分比， 
VSZ ：进程使用掉的虚拟内存量 (Kbytes) ，
RSS ：进程占用的固定的内存量 (Kbytes) ，
TTY ：与进程相关联的终端（tty),?代表无关,tty1-tty6是本机上面的登入者程序,pts/0表示为由网络连接进主机的程序。
STAT ：进程的状态，具体见2.1列出来的部分 ，
START ：进程开始创建的时间 ，
TIME ：进程使用的总cpu时间，
COMMAND : 进程对应的实际程序。

在Linux中，状态如下：

D 不可中断 Uninterruptible sleep (usually IO)
R 正在运行，或在队列中的进程
S 处于休眠状态
T 停止或被追踪
Z 僵尸进程
W 进入内存交换（从内核2.6开始无效）
X 死掉的进程

< 高优先级
N 低优先级
L 有些页被锁进内存
s 包含子进程
+ 位于后台的进程组
l 多线程，克隆线程

根据以上信息，sl+ 其处于休眠状态，多线程，且是后台进程。



10 重定向文件

2>1 | tee a.log  标准错误输出重定向到标准输出，然后标准输出定向到a.log
2>&1 | tee a.log  标准错误输出重定向到标准输出，然后标准输出定向到a.log 控制台也有输出打印

./fms_master 2>&1 | tee a.log

11 网络抓包
sudo tcpdump -i enp4s0 -w test.pcap

监视指定网络接口的数据包:  tcpdump -i eth1    -w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析

12 查看显卡信息 nvidia-smi

13 mkdir -p 递归创建目录，即使上级目录不存在，会按目录层级自动创建目录 

14. 远程连接 
  ssh senscape@192.168.0.174        ssh 用户名@主机名（IP地址）

15. 关闭 mosquitto 服务     sudo service mosquitto stop

16. ip---给网卡配置多个IP地址（别名）以及删除  
    ip addr add CIDR dev 网卡名 label 网卡名:num    sudo ip addr add 192.168.5.242/24 dev eth0 label eth0:2

17. mosquitto_sub -v -t /recog/senscape -u admin -P Senscape -h 192.168.0.244
    u:user 
	p:password 
	h:host
	v, –verbose：冗长地打印收到的消息。若指定该选项，打印消息时前面会打印主题名——“主题 消息内容”，否则，只打印消息内容
	t, –topic：指定订阅的消息主题，允许同时订阅到多个主题
	
	
	mosquitto_sub -t mqttjs_f8be9d3a -u admin -P Senscape
	mosquitto_sub -t senscape_sub -u admin -P Senscape
	
18. 间歇执行命令---watch
    -d | --differences           高亮显示差异部分
	-n                           指定时间间隔
    watch -d -n 0.1 'ps aux | head -1;ps aux |grep -v PID |sort -rn -k +4 | head -2'

19  ps aux | head -1;ps aux |grep -v PID |sort -rn -k +4 | head -2
   打印前两个占用内存最大的进程
   
20 htop  查看内存信息

21 scp  
    本地上传到远端:		scp -r /root/lk root@43.224.34.73:/home/lk/cpfile。
    远端上传到本地：       scp -r root@43.224.34.73:/home/lk /root。
	scp 01log.log senscape@192.168.0.174:/home/senscape /home/miao  //把远端senscape@192.168.0.174:/home/senscape下的 01log.log 拷贝到本地  /home/miao 下       
   
22 dns 配置
 vi /etc/resolv.con
 nameserver 114.114.114.14  
 nameserver 8.8.8.8

23  ssh-keygen -f "/home/senscape/.ssh/known_hosts" -R 192.168.0.243

24 设置句柄，永久有效
 vim /etc/security/limits.conf 
 添加
 * soft  nofile 65535   //* 代表所有用户
 * hard nofile 65535
 ??? 奇怪 本地查看不生效，远程登录看时有效

25 ubuntu18.04配置ip  /etc/netplan/01-network-manager-all.yaml 

network:
  version: 2
  renderer: NetworkManager
  ethernets:
          eno1: (网卡名)
             dhcp4: no
             addresses: [192.168.0.174/24]                                 [192.168.0.174/25]
             gateway4: 192.168.0.1                                         192.168.0.129
             nameservers:
                     addresses: [8.8.8.8,114.114.114.114]

26 查看可打开文件句柄数  ulimit -n

27 find /usr/ -name "rsa.h"
   find /usr/ -name "libssl*"
   
28  nmon  性能分析工具

29 which 查看可执行文件的位置
   which cat

 
30 c++filt  c++过滤函数编译修饰名
   c++filt _ZN15IFaceRecognizer11GetInstanceEi  -->  IFaceRecognizer::GetInstance(int)
   
31 lpr  打印文件
   
32 VPATH

33 whoami  打印用户名

34 arch  主要用于显示当前主机的硬件结构类型

35 size   test.o  用于查看目标文件、库或可执行文件中各段及其总和的大小

36 objdump -h test.o
	
37 echo -e   //后面语句中的特殊字符要转义

38 run-parts  就是执行目录下的所有的脚本
   
   -v --verbose：详尽输出模式，包括错误信息
   --report：只打印输出

39 test
    test命令是shell环境中测试条件表达式的实用工具

40 anacron 
   anacron 是用来做什么的呢？设想这样一个场景，Linux 服务器会在周末关机两天，但是设定的定时任务大多在周日早上进行，但在这个时间点，服务器又处于关机状态，导致系统很多定时任务无法运行。
   又比如，我们需要在凌晨 5 点 05 分执行系统的日志备份，但 Linux 服务器不是 24 小时开机的，在晚上需要关机，白天上班之后才会再次开机，在这个定时任务的执行时间我们的服务器刚好没有开机，
   那么这个定时任务就不会执行了。anacron 就是用来解决这个问题的
   
41 文件内容查找
   grep -rl "keyword" ./ 
   
42 文件内容查找
1、
find / -name '*' | xargs grep 'route'
在根文件夹下查找含有关键字route的文件，列出文件名和route所在行。
2、
find / -name '*.txt' | xargs grep 'route'
在根文件夹下查找后缀名为txt且含有关键字route的文件，列出文件名和route所在行。
 
43  Linux下用ifconfig命令设置IP、掩码、网关

设置IP和掩码
ifconfig eth0 192.168.5.40 netmask 255.255.255.0
设置网关
route add default gw 192.168.5.1

44 free -m 查看内存

    Mem:内存的使用情况总览表。
    totel:机器总的物理内存 单位为：M
    used：用掉的内存。
    free:空闲的物理内存

   free -g 

45 增加交换内存                    //https://blog.csdn.net/hongge_smile/article/details/105685318
sudo fallocate -l 4G /swapfile   或者sudo dd if=/dev/zero of=/swapfile bs=2048 count=2097152
sudo mkswap /swapfile
sudo swapon /swapfile


46  sshfs  链接远程目录
sshfs miao@192.168.0.243:/home/miao/project_run/workspace/FaceRecognitionRK3399 ./FaceRecog/
sshfs firefly@192.168.0.244:/home/firefly/workspace/FaceRecognitionRK3399 ./ -o nonempty

47 journalctl  查询系统日志的工具
   journalctl -xe  // -e 从结尾开始看  -x 相关目录(如:问题相关的网址)
   
48 systemd即为system daemon,是linux下的一种init软件,  作为init系统，systemd进程作为系统中的1号进程.
   Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器

49 mount是Linux下的一个命令，它可以将分区挂接到Linux的一个文件夹下，从而将分区和该目录联系起来

50  find ./ -type f|grep so  //递归查找目录下文件名包含so的文件

51 dpkg -l 命令会列出系统中所有已安装的软件包信息。结合grep

52 ctrl + r  查找历史命令

53 sudo dpkg -i <package.deb>

54 find . -type f -name "*.c" | xargs cat | wc -l       //统计当前目录下.c文件共有多少行

55 1.  uname   列出系统信息， 可以 --help  // uname -a
2.  cat  /../  | awk '{print $4}' | awk -F"."'{print $1"."$2}'
3.  cat >./eof.txt <<-EOF 
[ubuntu] 
nameserver 114.114.114.114
EOF

4. EOF是END Of File的缩写,表示自定义终止符.既然自定义,那么EOF就不是固定的,可以随意设置别名,在linux按ctrl-d就代表EOF.
EOF一般会配合cat能够多行文本输出.
其用法如下:
<<EOF        //开始
....
EOF            //结束
还可以自定义，比如自定义：
<<BBB        //开始
....
BBB              //结束
通过cat配合重定向能够生成文件并追加操作,在它之前先熟悉几个特殊符号:
< :输入重定向
> :输出重定向
>> :输出重定向,进行追加,不会覆盖之前内容
<< :标准输入来自命令行的一对分隔号的中间内容.

5 IFS
    Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符（internal field separator）

6  tee命令主要被用来向standout(标准输出流，通常是命令执行窗口）输出的同时也将内容输出到文件

7 wait命令介绍
   wait [作业指示或进程号]
   1.等待作业号或者进程号制定的进程退出，返回最后一个作业或进程的退出状态状态。
     如果没有制定参数，则等待所有子进程的退出，其退出状态为0.
8. time 
   可以统计程序运行时间

9. seq 
     -w, --equal-width 在列前添加0 使得宽度相同

10.  id命令可以显示真实有效的用户ID(UID)和组ID(GID)

11. useradd   添加用户

12.  passwd  命令用来更改使用者的密码

13. -f   是否是文件

14.  date +%F
      2020-09-06

15   ssh 后面可以添加命令语句

16 ll /proc/$$/fd     $$ 当前进程

17  source命令即点(.)命令
    source命令（从 C Shell 而来）是bash shell的内置命令。点命令，就是个点符号，（从Bourne Shell而来）是source的另一名称。
    source（或点）命令通常用于重新执行刚修改的初始化文档，如 .bash_profile 和 .profile 这些配置文件, 重新加载配置文件


source命令的一个妙用#
在编译核心时，常常要反复输入一长串命令，如
复制代码
make mrproper
make menuconfig
make dep
make clean
make bzImage
.......
复制代码

这些命令既长，又繁琐。而且有时候容易输错，浪费你的时间和精力。如果把这些命令做成一个文件，让它自动按顺序执行，对于需要多次反复编译核心的用户来说，会很方便


18  系统调用exec是以新的进程去代替原来的进程，但进程的PID保持不变。
      因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。
      原进程的代码段，数据段，堆栈段被新的进程所代替

19  mkfifo [ -m Mode ] File …          管道文件
      mkfifo 命令创建由 File 参数指定的 FIFO 特别文件

20 read  
    -u [ n ] 读取一位数的文件描述符号码 n 作为输入。文件描述符可以用 ksh exec 内置命令打开。
    n 的缺省值是 0，表示的是键盘。值 2 表示标准错误

21 shell expect spawn   exp_continue               
    远程交互命令

22 ［interact］ 
　　执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。
       如果没有这一句登录完成后会退出，而不是留在远程终端上.

23 expect eof        结束交互

24  ssh-copy-id 将本机的公钥复制到远程机器的authorized_keys文件中，
      ssh-copy-id也能让你有到远程机器的home, ~./ssh , 和 ~/.ssh/authorized_keys的权利
	  
25 declare 命令用于声明 shell 变量 declare --help

26  echo  -n   不换行

27  grep  "break"

28  head命令输出文件开头部分，默认情况下显示文件的头10行

29  sed 'd'  'i'

30 sed       参数
   -p        打印
   -s        查找
   -d        删除
   /  /      正则匹配
   !         非
   ~         可以组成奇数行/偶数行  具体的可以查查资料  

31 vim   
   r 参数   读入其他文件  

32 sed -r 's/(.)(.)(.*)/\1YYY\2\3/' passwd  // 在passwd文件每行的第一个字母后面添加YYY
   sed -r 's/(.*)(.)/\1YYY\2/' passwd       // 在passwd文件每行的倒数第二个字母后面添加YYY  
   
33 sudo ifconfig enp4s0  192.168.1.111
   sudo service network-manager restart
   sudo service networking restart
   interface eth0
   static ip_address=192.168.0.245
   static routers=192.168.0.1
   static domain_name_servers=114.114.114.114

34  df -hl   //查看硬盘使用情况 

35 ps -ef | wc -l    //查看系统中的总的进程数

36  pstree -apnh     //查看进程间关系

37 mosquitto_sub -v -t /v1/# -u admin -P Senscape -h 192.168.0.201    //定阅所有推送到平台的消息

38   cut是一个将文本按列进行划分的文本处理工具。cut命令逐行读入文本，
     然后按列划分字段并进行提取、输出等操作
39   op -d 1 -p pid  //设置为delay 1s  pid 进程id
PID（Process ID）：进程标示号。
USER：进程所有者的用户名。
PR：进程的优先级别。
NI：进程的优先级别数值。
VIRT：进程占用的虚拟内存值。
RES：进程占用的物理内存值。
SHR：进程使用的共享内存值。
S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。
%CPU：该进程占用的CPU使用率。
%MEM：该进程占用的物理内存和总内存的百分比。
TIME＋：该进程启动后占用的总的CPU时间。
Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行
 
40  sudo ldconfig  // 加载库文件

41  chown -R  // 更换文件用户
    sudo chown -R  senscape:senscape ./sensorcontroller/    //     sudo chown -R  用户名:密码   目录

42 ping www.sohu.com -I wwan0
	
43 tar cf a.tar ./0820/*.txt   // 打包0820目录下所有txt文件

45 sudo ip address add 192.168.1.188/24 dev eno1

46  &命令
    功能：加在一个命令的最后，可以把这个命令放在后台执行

47 jobs命令
   功能：查看当前终端后台运行的任务
   
48-- 网关部署
    cd /userdata/project_run
	cp ./smart_gateway.service  /lib/systemd/system/
    
	systemctl enable smart_gateway.service #开机运行服务
	service smart_gateway start  //开启服务
	
	sudo apt-get install mosquitto
	修改 /lib/systemd/system/mosquitto.service文件  -c参数为/userdata/project_run/toolsets/senscape.conf
	
	sudo apt-get install mosquitto -y
	sudo apt-get install mosquitto-clients -y
   
49  nohup command &   // 后台运行程序

50  readelf命令，一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，
    动态库(*.so)或者静态库(*.a) 等包含ELF格式的文件  // readelf ./smart_gateway -ld

51  ping -S 10.35.116.221 www.baidu.com    //指定地址ping 网络

52  查看系统运行信息
    uptime 
    who -b         查看最后一次系统启动的时间。
    who -r         查看当前系统运行时间
    last reboot    可以看到Linux系统历史启动的时间

    uptime -p      //up 1 week, 2 days, 38 minutes
    
    ps -p 1391 -o etime    //    ELAPSED 9-00:45:28

53  ps -aux
    user      pid      %CPU      %MEM      VSZ       RSS      TTY      STAT      START      TIME      COMMAND
USER      //用户名 
%CPU      //进程占用的CPU百分比 
%MEM      //占用内存的百分比 
VSZ       //该进程使用的虚拟內存量（KB） 
RSS       //该进程占用的固定內存量（KB）（驻留中页的数量） 
STAT      //进程的状态 
START     //该进程被触发启动时间 
TIME      //该进程实际使用CPU运行的时间

其中STAT状态位常见的状态字符有
D      //无法中断的休眠状态（通常 IO 的进程）； 
R      //正在运行可中在队列中可过行的； 
S      //处于休眠状态； 
T      //停止或被追踪； 
W      //进入内存交换 （从内核2.6开始无效）； 
X      //死掉的进程 （基本很少见）； 
Z      //僵尸进程； 
<      //优先级高的进程 
N      //优先级较低的进程 
L      //有些页被锁进内存； 
s      //进程的领导者（在它之下有子进程）； 
l      //多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）； 
+      //位于后台的进程组


54  ps -ef
    UID      PID      PPID      C      STIME      TTY      TIME      CMD
    UID    //用户ID、但输出的是用户名 
    PID    //进程的ID 
    PPID    //父进程ID 
    C      //进程占用CPU的百分比 
    STIME  //进程启动到现在的时间 
    TTY    //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 
    CMD    //命令的名称和参数

55 
查看物理CPU个数，可以看到cpu编号，同一个编号当然是同一个cpu
grep 'physical id' /proc/cpuinfo 

查看core的个数
grep 'core id' /proc/cpuinfo | sort -u |wc -l

查看总线程数量
grep 'processor' /proc/cpuinfo | sort -u | wc -l

查看cpu信息
lscpu

56 
pstree -p ${pid}    //查看一个进程下的所有线程

57 java获取线程状态

使用Thread类的getState()方法可以获得线程的状态，该方法的返回值是Thread.state,他是线程状态的枚举。枚举常量表如下：
Thread.state的枚举常量说明
枚举常量	    含义	        枚举常量	         含义
NEW	        新建状态	        TIMED_WAITING	 休眠状态
RUNNABLE	运行(可运行)状态	 WAITING	      等待状态
BLOCKED	    阻塞状态	        TERMINATED	     终止状态

58 yum install -y lrzsz
   sz 命令发送文件到本地：
   rz 命令本地上传文件到服务器

59 ln -sf 
   软链接: 全称是软链接文件，英文叫作 symbolic link。这类文件其实非常类似于 Windows 里的快捷方式，这个软链接文件（假设叫 VA）的内容，
          其实是另外一个文件（假设叫 B）的路径和名称，当打开 A 文件时，实际上系统会根据其内容找到并打开 B 文件。
   硬链接: 全称叫作硬链接文件，英文名称是 hard link。这类文件比较特殊，这类文件（假设叫 A）会拥有自己的 inode 节点和名称，其 inode 会指向文件内容所在的数据块。
          与此同时，该文件内容所在的数据块的引用计数会加 1。当此数据块的引用计数大于等于 2 时，则表示有多个文件同时指向了这一数据块。一个文件修改，多个文件都会生效。
          当删除其中某个文件时，对另一个文件不会有影响，仅仅是数据块的引用计数减 1。当引用计数为 0 时，则系统才会清除此数据块

60  telnet 是一个阉割版的 ssh ，它数据不加密，数据容易被盗窃，也容易受中间人攻击，所以默认情况下 telnet 端口是必须要被关闭的
    测试端口  telnet 192.168.31.100 8081   连接失败表示端口未占用。否则表示被占用,
    连接远程  telnet 182.168.1.28

61 21是ftp 22是ssh

62 mmap

63    修改时区    tzselect
   1.  选择 4 asia  -> 9 china  -> 1 beijing  -> 1 yes
   2.  cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime
   3.  date -R //显示时间和时区
   https://blog.csdn.net/zhengchaooo/article/details/79500032

64  uname -s    // Linux
    uname -m    // x86_64


65  dirname    dirname命令去除文件名中的非目录部分，仅显示与目录有关的内容
    dirname    //        --> /
    dirname    /a/b/     --> /a

66  basename   获取末尾的文件名或路径名
    basename  /etc/passwd   --> passwd
    basename  /etc/         --> etc

67  # mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用
    # mkdir -- -f 这样-f就不会被作为选项。

68  getopt 
    getopt -o v: --long headers:,libs:,cc:,cxx:,with-glog,with-thrift,with-mesalink,nodebugsymbols -n config_brpc -- --headers=/usr/include --libs=/usr/lib
    
    -a, --alternative            允许长选项以 - 开始
    -h, --help                   这个简短的用法指南
    -l, --longoptions <长选项>  要识别的长选项
    -n, --name <程序名>         将错误报告给的程序名
    -o, --options <选项字符串>  要识别的短选项
    -q, --quiet                  禁止 getopt(3) 的错误报告
    -Q, --quiet-output           无正常输出
    -s, --shell <shell>          设置 shell 引用规则
    -T, --test                   测试 getopt(1) 版本
    -u, --unquoted               不引用输出
    -V, --version                输出版本信息

69  head   tail
   head命令与tail命令用法相似，head命令用于查看文档的开始指定数量的字符块，默认显示文档的前 10 行，如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题
   -c,       --bytes=[-]K           k,显示文档开始的前k个字节，-k,不显示文档结尾的最后 k 个字节
   -n,       --lines=[-]K           k,显示文档开始的前k行，-k,不显示文档结尾的最后 k 行
   -q,       --quiet  --silent      不显示包含给定文件名的文件头
   -v,       --verbose 　　          总是显示包含给定文件名的文件头
   --help                           显示此帮助信息并退出
   --version                        显示版本信息并退出

70  find 
    -not            #非，取反
    -user           #文件所有人
    -group          #文件所有组
    -a              #并且关系
    -o              #或者关系
    find /usr/lib/ -name libprotobuf.a -o name libprotobuf.so
    
    -type   #文件类型
    主要的文件类型：
    f        #普通文件
    d        #目录
    b        #块设备
    s        #套接字
    c        #字符设备
    l        #链接
    p        #管道
---
    -P      不跟踪符号链接(默认行为)
    -L      当 find 检查或打印有关文件的信息时, 所使用的信息应取自链接指向的文件的属性, 而不是链接本身
    -H      和 -L 参数刚好相反,  当 find 检查或打印有关文件的信息时, 所使用的信息应取自符号链接的属性

71    查看进程里的线程
    top  -Hp     11675
    ps   -T -p   11675

72   strace    可用来跟踪用户空间进程的系统调用和信号的
     https://www.cnblogs.com/machangwei-8/p/10388883.html

73   apt-cache search zlib

74. strace   ltrace    
    strace —— Trace system calls and signals。 跟踪进程的系统调用或信号产生的情况。
    ltrace —— A library call tracer。 跟踪进程调用库函数的情况
    https://blog.csdn.net/uisoul/article/details/83143290

75. sudo /usr/sbin/tcpdump -v  -i eth0:2  host 192.168.5.242 and 192.168.5.196 

      tcpdump 的抓包保存到文件的命令参数是-w xxx.cap
      抓eth1的包 
      tcpdump -i eth1 -w /tmp/xxx.cap 
      抓 192.168.1.123的包 
      tcpdump -i eth1 host 192.168.1.123 -w /tmp/xxx.cap 
      抓192.168.1.123的80端口的包 
      tcpdump -i eth1 host 192.168.1.123 and port 80 -w /tmp/xxx.cap 
      抓192.168.1.123的icmp的包 
      tcpdump -i eth1 host 192.168.1.123 and icmp -w /tmp/xxx.cap 
      抓192.168.1.123的80端口和110和25以外的其他端口的包 
      tcpdump -i eth1 host 192.168.1.123 and ! port 80 and ! port 25 and ! port 110 -w /tmp/xxx.cap 

76    df -h查看系统中文件的使用情况
      du -sh *查看当前目录下各个文件及目录占用空间大小

77  ln -s  ./.vim/.vimrc  .

78  pushd : push (in) directory,将目录压栈,最后一个压入的目录位于栈顶;    pushd +3
    popd : pop (out) directory,将目录栈逐个弹出
    pushd不带参数，就会在栈顶的两个目录之间切换．如果需要调整到其他目录，可以使用+n参数．具体每个栈内目录编号，通过dirs -v查看
    cd -  两个目录切换

    dirs -v
    dirs -c  清空目录堆栈

    cmake -DgRPC_INSTALL=ON -DgRPC_BUILD_TESTS=OFF -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=/usr/local/  ../..

79  which  查看某个可执行文件的位置

80. ` `  执行命令后的内容

81  pkg-config能够程序依赖的头文件和库文件的位置指出来，给编译器使用
    pkg-config同其他命令一样，有很多选项，不过我们一般只会用到--libs和--cflags

82  export http_proxy="http://192.168.0.58:1087"
    export https_proxy="http://192.168.0.58:1087"
    ssh senscape@192.168.0.58

83  more
more命令的作用：分屏显示文件内容
选项：
-b 回滚一屏
-f 向前滚一屏

84 df ./  查看当前目录所在磁盘分区

85  文件误删恢复
方法一  https://www.cnblogs.com/jiftle/p/10966636.html
1. debugfs
2. open 分区磁盘    //可以通过 df ./查看
3. ls -d  文件目录
4. logdump  -i <文件对应的序号>
5. 

Inode 37490843 is at group 4576, block 149946532, offset 3328
Journal starts at block 65938, transaction 6070501
Found sequence 6047747 (not 6074623) at block 103701: end of journal.

sudo dd if=/dev/sda2 of=/home/miao/2021/02/MingXing/grpcDemo/CMakeLists.txt bs=3328 count=1 skip=149946532

bs与offset值一致，skip与block值一致

方法二 grep -a -B 30 -A 150 'function checkInt() ' /dev/sda1 > tmp.txt
其中-a表示把分区看成文本形式(分区本身是二进制形式的)，-B 30 -A 150表示找到搜索的内容就打印前面30行和后面150行
如果分区比较大可能需要一定的搜索时间，完成之后打开tmp.txt，你会发现在一堆乱码中镶嵌着你要恢复的本文

86  sudo apt full-upgrade
    sudo do-release-upgrade -m desktop 

87  export    撤销用　unset 

88  echo  $SHELL    查看当前终端运行的shell

89  pstree -p {pid}

90  timeout
    运行指定的命令，如果在指定时间后仍在运行，则杀死该进程。用来控制程序运行的时间
    timeout 10 command
    如过command命令在10秒内结束，则平安结束，运行超过10秒，将被强行kill掉

91  grep "miao" /var/log/auth.log
    grep “Out of memory” /var/log/syslog

92  可以使用 grep 来查找哪些用户失败登录的次数最多。这些都是潜在的攻击者正在尝试和访问失败的账户。这是一个在 ubuntu 系统上的例子
$ grep "invalid user" /var/log/auth.log | cut -d ' ' -f 10 | sort | uniq -c | sort -nr
23 oracle
18 postgres
17 nagios
10 zabbix
6 test

93  grep -a "Accepted publickey" /var/log/auth.log | cut -d ' ' -f 9 | sort | uniq -c | sort -nr #查看通过秘钥登录的用户及登录次数

94  dmesg
    命令用于打印Linux系统开机启动信息，kernel会将开机信息存储在ring buffer中。您若是开机时来不及查看信息，可利用dmesg来查看
    （print or control the kernel ring buffer）。开机信息亦保存在/var/log/dmesg的文件里

95  从2012年开始，大部分linux发行版本开始从传统的systemv初始化系统移植到一个叫做systemd的全新系统。
    systemd用来启动系统并管理进程。systemd包含了一个叫做journalctl的辅助组件，其主要作用是管理系统的事件日志记录

96  ulimit -c查看是否开启。如果输出为0，则没有开启，需要执行ulimit -c unlimited 开启core dump功能
    ulimit -c unlimited   //unlimited 代表不限制core文件大小， 可以指定core文件大小 ulimit -c 1024  

    core文件生成路径: 输入可执行文件运行命令的同一路径下
    gdb peer_tracker.wd  core （peer_tracker.wd为执行的文件）

97  dmesg命令行实用程序用于在Linux和其他类似Unix的操作系统中打印和控制内核环形缓冲区。对于检查内核启动消息和调试与硬件相关的问题很有用
    dmesg -c        在显示的同时，clean掉dmesg缓存中信息
    dmesg -d        显示dmesg中两条打印信息的时间间隔
    dmesg | tail    显示dmesg最近一次的输出

98  insmod指Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。
    这类可载入的模块，通常是设备驱动程序。
        -f    不检查kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。
        -k    将模块设置为自动卸除。
        -m    输出模块的载入信息。
        -o    <模块名称> 　指定模块的名称，可使用模块文件的文件名。
        -p    测试模块是否能正确地载入kernel。
        -s    将所有信息记录在系统记录文件中。
        -v    执行时显示详细的信息。
        -x    不要汇出模块的外部符号。
        -X    汇出模块所有的外部符号，此为预设值。

    lsmod                  查看已加载的驱动模块列表
    rmmod <module_name>    卸载驱动模块 

99  mknod命令用于创建Linux中的字符设备文件和块设备文件。
    mknod /dev/hello c 232 0
    
100  uptime -p             显示系统启动运行时间
     ps -p 818 -o etime    查看进程运行时间
     pidof wget            查看进程wget的pid

101  sudo apt-get upgrade     升级全部软件
     sudo apt-get update      查看那些软件可以升级
     apt list --upgradable    #查看可升级列表

    #安装最新redis
    sudo apt-get install redis
    #安装指定版本redis
    sudo apt-get install redis=3.0

    可以用sudo apt-get install pkgname  升级特定软件
    
102 cat /proc/cpuinfo

103 rpm 安装
    sudo alien -i ./XMind-2020-for-Linux-x86-64bit-10.3.1-202101132117.rpm

104  sudo ip addr del 192.168.1.242 dev enp4s0
     取消网卡enp4s0添加的虚拟地址

105  查看CPU信息（型号）             cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
# 查看物理CPU个数                    cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
# 查看每个物理CPU中core的个数(即核数)  cat /proc/cpuinfo| grep "cpu cores"| uniq
# 查看逻辑CPU的个数                  cat /proc/cpuinfo| grep "processor"| wc -l

106  sudo ifconfig enp4s0 down    // enp4s0 网卡驱动关闭
     sudo ifconfig enp4s0 up      // enp4s0 网卡驱动开启

107  sudo ethtool eth1，Speed那行代表了是万兆网卡
     Speed: 1000Mb/s
     这里的万兆网卡单位是Mb，跟我们上面讲的MB不一样，需要换算成MB=10000/8

108 sort是在Linux里非常常用的一个命令

109 history history 10  //显示最近10条终端执行过的命令
    
    有 4 种方法可以快速重复执行上一条命令:
            1.使用上方向键，并回车执行。
            2.按 !! 并回车执行。
            3.输入 !-1 并回车执行。
            4.按 Ctrl+P 并回车执行。
            
    !4 执行历史记录里的第四条记录
    !command 从最近的命令查到以command开头的命令执行
    使用Ctrl+r反向查询历史命令，将匹配的最新一条显示出来,如果还想继续向上查询，继续按Ctrl+r

110 cksum命令用于检查文件的CRC是否正确。确保文件从一个系统传输到另一个系统的过程中不被损坏

111 nm  names的缩写， nm命令主要是用来列出某些文件中的符号(说白了就是一些函数和全局变量等).

112 strings    工具可以对任何文件的内容进行分析，并输出可打印字符长度不小于4的串
    1.  strings命令很简单， 看起来好像没什么， 但实际有很多用途。 下面， 我来举一个例子。  在大型的软件开发中， 假设有100个.c/.cpp文件， 
        这个.cpp文件最终生成10个.so库， 那么怎样才能快速知道某个.c/.cpp文件编译到那个.so库中去了呢？ 当然， 你可能要说， 
        看makefile不就知道了。 对， 看makefile肯定可以， 但如下方法更好， 直接用命令：
        strings -f "*.so" | grep "xxxxxx"

113 
    1.查看当前正在使用的shell
        echo $SHELL
        /bin/bash
    2.查看系统中安装了哪些shell
    cat /etc/shells 
        /bin/sh
        /bin/bash
        /sbin/nologin
        /bin/dash
        /bin/tcsh
        /bin/csh

114 /etc/passwd   可以修改用户的终端

115 ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件
1.ar基本用法
    ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。
    下面是ar命令的格式：
    ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files...
    例如我们可以用ar rv libtest.a hello.o hello1.o来
    生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-'字符，也可以
    没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。
    {dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：

    d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。
    m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用'a'，'b'，或'i'任选项移动到指定的位置。
    p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。
    q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。'a'，'b'，或'i'任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用'ar s'或ranlib来更新库的符号表索引。
    r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。
    t：显示库的模块表清单。一般只显示模块名。
    x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。

    a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。
    b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。
    c：创建一个库。不管库是否存在，都将创建。
    f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。
    i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。
    l：暂未使用
    N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。
    o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。
    P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。
    s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。
    S：不创建目标文件索引，这在创建较大的库时能加快时间。
    u：一般说来，命令ar r...插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。
    v：该选项用来显示执行操作选项的附加信息。
    V：显示ar的版本。

116. chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息(ubuntu 没有这个命令)
        chkconfig –list        #列出所有的系统服务
        chkconfig –add httpd        #增加httpd服务
        chkconfig –del httpd        #删除httpd服务
        chkconfig –level httpd 2345 on        #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态
        chkconfig –list        #列出系统所有的服务启动情况
        chkconfig –list mysqld        #列出mysqld服务设置情况
        chkconfig –level 35 mysqld on        #设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭
        chkconfig mysqld on        #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级

117  service --status-all    列出所有服务(service).
     systemctl list-units --type=service： 列出正在运行的服务

118  在Systemd出现之前，Linux系统及各应用的日志都是分别管理的，Systemd开始统一管理了所有Unit的启动日志，
     这样带来的好处就是可以只用一个 journalctl命令，查看所有内核和应用的日志。
     1. 基础用法
        1.1 查看所有日志(默认显示本次启动的所有日志)
        [root@devops-101 ~]# journalctl
        查看本次启动的所有日志也可以使用
        [root@devops-101 ~]# journalctl -b
        1.2 查看内核日志
        [root@devops-101 ~]# journalctl -k
        1.3 查看指定时间的日志
        通过--since和--until选项，可以过滤任意时间限制，显示指定条件之前、之后或之间的日志。
        [root@devops-101 ~]# journalctl --since="2018-09-21 10:21:00"
        查询一个时间段范围内的日志。
        [root@devops-101 ~]# journalctl --since="2018-09-21 10:21:00" --until="2018-09-21 10:22:00"
        1.4 根据不同的主题进行过滤筛选
        根据服务筛选
        [root@devops-101 ~]# journalctl -u kubelet.service
        [root@devops-101 ~]# journalctl -u kubelet
        根据进程ID查询
        如果进程使用了systemd托管日志，则可以通过以下命令查找进程对应的日志。
        [root@devops-101 ~]# journalctl _PID=1
        Systemd journal 有很多可以用来过滤的字段，可以通过 man systemd.journal-fields 查看所有可以用来过滤的字段。对于用来筛选的字段，可以使用-F参数来查看所有可以用来过滤的值，例如journalctl -F _PID。
        按优先级
        操作系统提供了从0 (emerg) 到 7 (debug) 一共7个级别的日志，可以配合-p参数分别查看对应级别的日志。
        [root@devops-101 ~]# journalctl -p 5 -u kubelet
        7个级别的含义为
            0: emerg
            1: alert
            2: crit
            3: err
            4: warning
            5: notice
            6: info
            7: debug

119 minicom  -s  重新配置参数    进入后 a:配置设备描述符  e:设置波特率，停止位

120  nautilus
     nautilus是GNOME桌面下的一个文件管理工具。 通过这个命令我们可以在终端下非常方便的打开指定目录的文件。
     $ nautilus . // 命令后面一个“.”，表示当前目录

121  sudo dpkg -r 软件名“进行卸载

122     xargs 
        $ cat /etc/passwd | grep root
        上面的代码使用了管道命令（|）。管道命令的作用，是将左侧命令（cat /etc/passwd）的标准输出转换为标准输入，提供给右侧命令（grep root）作为参数。
        因为grep命令可以接受标准输入作为参数，所以上面的代码等同于下面的代码。
        $ grep root /etc/passwd
        但是，大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。举例来说，echo命令就不接受管道传参。
        $ echo "hello world" | echo
        上面的代码不会有输出。因为管道右侧的echo不接受管道传来的标准输入作为参数。
        xargs命令的作用，是将标准输入转为命令行参数。
        $ echo "hello world" | xargs echo
        hello world
        上面的代码将管道左侧的标准输入，转为命令行参数hello world，传给第二个echo命令。
        xargs的作用在于，大多数命令（比如rm、mkdir、ls）与管道一起使用时，都需要xargs将标准输入转为命令行参数。
        
123    nproc 命令显示当前进程可用的CPU数目

124    sysctl命令用于运行时配置内核参数，这些参数位于/proc/sys目录下
            常用参数的意义：
                -w   临时改变某个指定参数的值，如
                     sysctl -w net.ipv4.ip_forward=1
                -a   显示所有的系统参数
                -p   从指定的文件加载系统参数，如不指定即从/etc/sysctl.conf中加载

125     apt-get install inetutils-ping  net-tools
 
126     比如说我们要安装skype，就用在缓存中搜索一下skype这个软件
        命令：
        sudo apt-cache search skype
        sudo apt-get remove软件名

127     aarch64-linux-gnu-gcc    -v

128     file filename　　#filename表示要查看的文件名

129    linux 如何查看一个软连接实际指向的文件的位置  
       在Linux命令行界面输入命令:ls -al 带有“->”符号的则为软连接

130     
        将没有出现 root 的行取出来
        $ grep -v root /etc/passwd

131    回收站位置  ~/.local/share/Trash

132    Linux中修改环境变量及生效方法
       方法一：
　　        在/etc/profile文件中添加变量【对所有用户生效(永久的)】
　　        用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。
　　        要让刚才的修改马上生效，需要执行以下代码
　　        # source /etc/profile
　　    方法二：
　　        在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】
　　        用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。
　　        要让刚才的修改马上生效，需要在用户目录下执行以下代码
　　        # source .bash_profile

133    echo miao | sudo -S docker ps -a

134     sudo apt-get install sshpass
        sshpass -p senscape ssh senscape@192.168.0.195

135 linux系统下给命令指定别名alias命令用法:
在linux系统中如果命令太长又不符合用户的习惯，那么我们可以为它指定一个别名。虽然可以为命令建立“链接”解决长文件名的问题，但对于带命 令行参数的命令，
链接就无能为力了。而指定别名则可以解决此类所有问题。只要举一些例子就可以了：
alias l='ls -l' ;用 l 代替 ls -l 命令(Xenix 下就有类似的 l 命令)
alias cd..='cd ..' ;用 cd.. 代替 cd .. 命令(对在 DOS 下使用惯了 cd.. 的人帮助很大)
alias md='mkdir' ;用 md 代替 mkdir 命令(对在 DOS 下…)
alias c:='mount /dev/hda1 /mnt/c & cd /mnt/c' ;用 c: 命令代替命令序列：安装 DOS 分区，再进入。

136  Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。其主要功能是统计指定文件中的字节数、字数、行数，
     并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。
选项参数主要有：
    -c 统计字节数。
    -l 统计行数。
    -m 统计字符数。这个标志不能与 -c 标志一起使用。
    -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串

137  nproc 机器的cpu核数

138 谷歌屏蔽不能复制文字
    chrome -> setting -> Debugger -> Disable JavaScript

139 grep正则表达式元字符集：
 ^ 锚定行的开始 如：'^grep'匹配所有以grep开头的行。 
 $ 锚定行的结束 如：'grep$'匹配所有以grep结尾的行。
 grep -w   精确匹配
 grep 命令加 -E参数，这一扩展允许使用扩展模式匹配。例如，要抽取城市代码为219或216，方法如下：
 grep –E '219|216'
 grep -q 用于if逻辑判断      安静模式，不打印任何标准输出。如果有匹配的内容则立即返回状态值0
 grep -E：支持使用扩展的正则表达式元字符；
 egrep：支持扩展的正则表达式实现类似grep文本过滤功能；grep -E


140. tar zxvf output.tgz -C ./

141. 如果安装过程中提示缺少相关依赖，则执行如下命令解决：sudo apt -f install

142. cheese  /dev/video1     // 打开摄像头 

143. 
echo -e "\a"          //终端发出声音
echo -e "\007"        //终端发出声音

144.  du -sh *查看当前目录下各个文件及目录占用空间大小
      df -T可以查看已经挂载的分区和文件系统类型
      df-T可以查看已经挂载的分区和文件系统类型
      fdisk -l 可以显示出所有挂载和未挂载的分区，但不显示文件系统类型
      parted -l  可以查看未挂载的文件系统类型，以及那些分区尚未格式化
      lsblk -f  也可以查看未挂载的文件系统类型

144. 实例1：直接远程连接某台主机：
     命令：sshpass -p xxx ssh root@192.168.11.11

145. ssh -o StrictHostKeyChecking=no

146. pidof命令用于查找指定名称的进程的进程号id号

147 top命令详解    //https://www.cnblogs.com/edgedance/p/7044753.html
Linux top命令的用法详细详解
查看多核CPU命令
mpstat -P ALL  和  sar -P ALL 
说明：sar -P ALL > aaa.txt   重定向输出内容到文件 aaa.txt
top命令经常用来监控Linux的系统状况，比如cpu、内存的使用，程序员基本都知道这个命令，但比较奇怪的是能用好它的人却很少，例如top监控视图中内存数值的含义就有不少的曲解。
本文通过一个运行中的WEB服务器的top监控截图，讲述top视图中的各种数据的含义，还包括视图中各进程（任务）的字段的排序。
top进入视图
top视图 01
top视图 01
【top视图 01】是刚进入top的基本视图，我们来结合这个视图讲解各个数据的含义。
第一行：
10:01:23 — 当前系统时间
126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）
2 users — 当前有2个用户登录系统
load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。
第二行：
Tasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。
第三行：cpu状态
6.7% us — 用户空间占用CPU的百分比。
0.4% sy — 内核空间占用CPU的百分比。
0.0% ni — 改变过优先级的进程占用CPU的百分比
92.9% id — 空闲CPU百分比
0.0% wa — IO等待占用CPU的百分比
0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
0.0% si — 软中断（Software Interrupts）占用CPU的百分比
在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。
第四行：内存状态
8306544k total — 物理内存总量（8GB）
7775876k used — 使用中的内存总量（7.7GB）
530668k free — 空闲内存总量（530M）
79236k buffers — 缓存的内存量 （79M）
第五行：swap交换分区
2031608k total — 交换区总量（2GB）
2556k used — 使用的交换区总量（2.5M）
2029052k free — 空闲交换区总量（2GB）
4231276k cached — 缓冲的交换区总量（4GB）
这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器“危矣”：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。
第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。
如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：530668+79236+4231276 = 4.7GB。
对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。
第六行是空行
第七行以下：各进程（任务）的状态监控
PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）
多U多核CPU监控
在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：
top视图 02
top视图 02
观察上图，服务器有16个逻辑CPU，实际上是4个物理CPU。
进程字段排序
默认进入top时，各进程是按照CPU的占用量来排序的，在【top视图 01】中进程ID为14210的Java进程排在第一（cpu占用100%），进程ID为14183的java进程排在第二（cpu占用12%）。可通过键盘指令来改变排序字段，比如想监控哪个进程占用MEM最多，我一般的使用方法如下：
1. 敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：
top视图 03
top视图 03
我们发现进程id为10704的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（runing）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。
2. 敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：
top视图 04
top视图 04
可以看到，top默认的排序列是“%CPU”。
3. 通过”shift + >”或”shift + <”可以向右或左改变排序列，下图是按一次”shift + >”的效果图：
top视图 05
top视图 05
视图现在已经按照%MEM来排序了。
改变进程显示字段
1. 敲击“f”键，top进入另一个视图，在这里可以编排基本视图中的显示字段：
top视图 06
top视图 06
这里列出了所有可在top基本视图中显示的进程字段，有”*”并且标注为大写字母的字段是可显示的，没有”*”并且是小写字母的字段是不显示的。如果要在基本视图中显示“CODE”和“DATA”两个字段，可以通过敲击“r”和“s”键：
top视图 07
top视图 07
2. “回车”返回基本视图，可以看到多了“CODE”和“DATA”两个字段：
top视图 08
top视图 08
top命令的补充
top命令是Linux上进行系统监控的首选命令，但有时候却达不到我们的要求，比如当前这台服务器，top监控有很大的局限性。这台服务器运行着websphere集群，有两个节点服务，就是【top视图 01】中的老大、老二两个java进程，top命令的监控最小单位是进程，所以看不到我关心的java线程数和客户连接数，而这两个指标是java的web服务非常重要的指标，通常我用ps和netstate两个命令来补充top的不足。
监控java线程数：
ps -eLf | grep java | wc -l
监控网络客户连接数：
netstat -n | grep tcp | grep 侦听端口 | wc -l

148. jq   //json解析

149. 通过使用tr，您可以非常容易地实现 sed 的许多最基本功能。您可以将 tr 看作为 sed的（极其）简化的变体：它可以用一个字符来替换另一个字符，
     或者可以完全除去一些字符。您也可以用它来除去重复字符。这就是所有 tr所能够做的
     tr -c -d -s [“string1_to_translate_from”] [“string2_to_translate_to”] < input-file

    -c 用字符串1中字符集的补集替换此字符集，要求字符集为ASCII。
    -d 删除字符串1中所有输入字符。
    -s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。
    input-file是转换文件名。虽然可以使用其他格式输入，但这种格式最常用

150. cut  linux字符截取命令

151. echo \c
     我们也可以使用\c转义符，表示不换行输出，但是当”\c”后面仍然存在字符时，”\c”后面的字符将不会被输出，如果”\c”后面不存在任何字符时，
     效果与使用”echo -n”相同,示例如下。

152. grep是管道符的作用，相当于将前面的搜索内容传递给grep之后的命令，^d表示查找开头为字母d的文件或行

153. Linux命令手动清除缓存  echo 3 > /proc/sys/vm/drop_caches

154. kill -0 pid 不发送任何信号，但是系统会进行错误检查。
     所以经常用来检查一个进程是否存在，存在返回0；不存在返回1

155. 
wc -c filename：显示一个文件的字节数
wc -m filename：显示一个文件的字符数
wc -l filename：显示一个文件的行数
wc -L filename：显示一个文件中的最长行的长度
wc -w filename：显示一个文件的字数

156. sort是在Linux里非常常用的一个命令，管排序的
        function version_lt() { test "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" != "$1"; }

157.  wget  选项
-O：下载并以指定的文件名保存；
-nh：不查询主机名称；
-v：显示详细执行过程；
-V：显示版本信息；
--passive-ftp：使用被动模式PASV连接FTP服务器；
--follow-ftp：从HTML文件中下载FTP连接文件

158.  
-a ：相当于 -pdr 的意思（参数pdr分别为：保留权限，复制软链接本身，递归复制)
-p ：连同档案的属性一起复制过去，而非使用预设属性；
-d ：若来源文件为连结文件的属性(link file)，则复制连结文件属性而非档案本身；
-f ：为强制 (force) 的意思，若有重复或其它疑问时，不会询问使用者，而强制复制；

159. ip---给网卡配置多个IP地址（别名）以及删除
格式：ip addr add CIDR dev 网卡名 label 网卡名:num
例子：ip addr add 3.3.3.3/24 dev eth1 label eth1:2

删除
格式：ip addr del CIDR dev 网卡名
例子： sudo ip addr del 192.168.1.15/24 dev eno1:1

159. umount /dev/hda2  

160. export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib

161. grep -v 
    cat test.log | grep "login"|grep -v "deviceType"
    上面的命令的意思是：找出test.log中包含login信息的,且没有deviceType这个字段的

162. chrony是一个开源的自由软件，它能保持系统时钟与时钟服务器（NTP）同步，让时间保持精确。它由两个程序组成：chronyd和chronyc。
     chronyd是一个后台运行的守护进程，用于调整内核中运行的系统时钟和时钟服务器同步。它确定计算机增减时间的比率，并对此进行补偿。 
     chronyc提供了一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。 

     chronyc sources -v    查看时间同步源

163. alsamixer   调节音量

164. https://www.cnblogs.com/liulaolaiu/p/11744497.html
举例说明：
要将目录logs打包压缩并分割成多个1M的文件，可以用下面的命令：
tar cjf - logs/ |split -b 1m - logs.tar.bz2.
完成后会产生下列文件：
-rw-r--r-- 1 httpd nobody 1048576 Oct 5 15:37 logs.tar.bz2.aa
-rw-r--r-- 1 httpd nobody 1048576 Oct 5 15:37 logs.tar.bz2.ab
-rw-r--r-- 1 httpd nobody 1048576 Oct 5 15:37 logs.tar.bz2.ac
-rw-r--r-- 1 httpd nobody 1048576 Oct 5 15:38 logs.tar.bz2.ad
-rw-r--r-- 1 httpd nobody 1048576 Oct 5 15:38 logs.tar.bz2.ae
-rw-r--r-- 1 httpd nobody 829440 Oct 5 15:39 logs.tar.bz2.af
这样存储压缩包的目的就达到了，可是当要解压的时候要怎么做呢？只要执行下面的命令就可以了：
cat logs.tar.bz2.a* | tar xj
这里对命令做一些讲解。
压缩和分割命令行中红色部分的为命令对应的I/O文件名参数，其中-表示标准输入或输出。那么结合上面的例子，tar命令表示的意思就是将logs目录压缩，生成的结果直接输送到标准输出上；
而split命令表示从标准输入获得文件内容进行分割，结果文件前缀为logs.tar.bz2.。二者再通过管道将各自的标准输入输出对接起来。
这里再解释一下split命令的参数含义：
-b SIZE 指定每个文件的大小，其单位可以为b（512字节）、k（1K）、m（1M）
-d 使用数字而不是字母作为后缀名
-a X 指定后缀名的长度，默认为2位
这样上面的命令就可以变化为：
tar cjf - logs/ |split -b 1m -d -a 1- logs.tar.bz2.

165. 